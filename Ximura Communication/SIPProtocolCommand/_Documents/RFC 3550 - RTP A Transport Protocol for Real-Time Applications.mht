From: "Saved by Windows Internet Explorer 7"
Subject: rfc 3550
Date: Wed, 25 Oct 2006 02:44:12 +0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0002_01C6F7DF.743F21E0"
X-MimeOLE: Produced By Microsoft MimeOLE V6.0.5600.16384

This is a multi-part message in MIME format.

------=_NextPart_000_0002_01C6F7DF.743F21E0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://tools.ietf.org/html/rfc3550

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" =
"http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<HTML lang=3Den xml:lang=3D"en"><HEAD><TITLE>rfc 3550</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1252">
<META content=3Dindex,follow name=3Drobots>
<META content=3D"rfcmarkup version 1.31" name=3Dcreator>
<SCRIPT src=3D"http://tools.ietf.org/js/MochiKit.js"=20
type=3Dtext/javascript></SCRIPT>
<LINK href=3D"/rfc.png" type=3Dimage/png rel=3Dicon><LINK =
href=3D"/rfc.png"=20
type=3Dimage/png rel=3D"shortcut icon">
<STYLE type=3Dtext/css>BODY {
	FONT-SIZE: 1em; MARGIN: 8px
}
H1 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
H2 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
H3 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
H4 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
H5 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
H6 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
h7 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
h8 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
h9 {
	DISPLAY: inline; FONT-SIZE: 1em; LINE-HEIGHT: 0pt; FONT-FAMILY: =
monospace; WHITE-SPACE: pre
}
.pre {
	FONT-FAMILY: monospace; WHITE-SPACE: pre
}
.header {
	FONT-WEIGHT: bold
}
.header2 {
	FONT-WEIGHT: bold
}

@media Print   =20
{
BODY {
	FONT-SIZE: 10.5pt
}
H1 {
	FONT-SIZE: 10.5pt
}
H2 {
	FONT-SIZE: 10.5pt
}
H3 {
	FONT-SIZE: 10.5pt
}
H4 {
	FONT-SIZE: 10.5pt
}
H5 {
	FONT-SIZE: 10.5pt
}
H6 {
	FONT-SIZE: 10.5pt
}
h7 {
	FONT-SIZE: 10.5pt
}
h8 {
	FONT-SIZE: 10.5pt
}
h9 {
	FONT-SIZE: 10.5pt
}
A:link {
	TEXT-DECORATION: none
}
A:visited {
	TEXT-DECORATION: none
}
.break {
	PAGE-BREAK-BEFORE: always
}
.noprint {
	DISPLAY: none
}

}

@media Screen   =20
{
.grey {
	COLOR: #777
}
.grey A:link {
	COLOR: #777
}
.grey A:visited {
	COLOR: #777
}

}
</STYLE>

<SCRIPT><!--=0A=
    function addHeaderTags() {=0A=
	headertags =3D getElementsByTagAndClassName("span", "header");=0A=
	for ( i=3D0; i < headertags.length; i++) {=0A=
	    elem =3D headertags[i];=0A=
	    if (elem) {=0A=
		level =3D elem.getAttribute("level");=0A=
		elem.innerHTML =3D "<H"+level+">"+elem.innerHTML+"</H"+level+">";		=0A=
	    }=0A=
	}=0A=
    }=0A=
    // -->=0A=
    </SCRIPT>

<META content=3D"MSHTML 6.00.5600.16384" name=3DGENERATOR></HEAD>
<BODY onload=3DaddHeaderTags()><SPAN class=3D"pre noprint">[<A=20
href=3D"http://tools.ietf.org/rfc/">RFCs</A>] [<A=20
href=3D"http://tools.ietf.org/id/">I-Ds</A>] [<A=20
href=3D"http://tools.ietf.org/rfc/rfc3550.txt">Plain =
Text</A>]</SPAN><PRE>                                                    =
                   =20


Network Working Group                                     H. Schulzrinne
Request for Comments: 3550                           Columbia University
Obsoletes: <A href=3D"http://tools.ietf.org/html/rfc1889">1889</A>       =
                                        S.  Casner
Category: Standards Track                                  Packet Design
                                                            R. Frederick
                                                  Blue Coat Systems Inc.
                                                             V. Jacobson
                                                           Packet Design
                                                               July 2003


          <SPAN class=3Dheader level=3D"1">RTP: A Transport Protocol for =
Real-Time Applications</SPAN>

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

Abstract

   This memorandum describes RTP, the real-time transport protocol.  RTP
   provides end-to-end network transport functions suitable for
   applications transmitting real-time data, such as audio, video or
   simulation data, over multicast or unicast network services.  RTP
   does not address resource reservation and does not guarantee
   quality-of-service for real-time services.  The data transport is
   augmented by a control protocol (RTCP) to allow monitoring of the
   data delivery in a manner scalable to large multicast networks, and
   to provide minimal control and identification functionality.  RTP and
   RTCP are designed to be independent of the underlying transport and
   network layers.  The protocol supports the use of RTP-level
   translators and mixers.

   Most of the text in this memorandum is identical to <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A> which it
   obsoletes.  There are no changes in the packet formats on the wire,
   only changes to the rules and algorithms governing how the protocol
   is used.  The biggest change is an enhancement to the scalable timer
   algorithm for calculating when to send RTCP packets in order to
   minimize transmission in excess of the intended rate when many
   participants join a session simultaneously.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 1]</SPAN>
<A id=3Dpage-2 href=3D"http://tools.ietf.org/html/rfc3550#page-2" =
name=3Dpage-2><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


Table of Contents

   1.  Introduction ................................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-4">4</A>
       1.1  Terminology ............................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-5">5</A>
   2.  RTP Use Scenarios ...........................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-5">5</A>
       2.1  Simple Multicast Audio Conference ......................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-6">6</A>
       2.2  Audio and Video Conference .............................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-7">7</A>
       2.3  Mixers and Translators .................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-7">7</A>
       2.4  Layered Encodings ......................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-8">8</A>
   3.  Definitions .................................................   =
<A href=3D"http://tools.ietf.org/html/rfc3550#page-8">8</A>
   4.  Byte Order, Alignment, and Time Format ......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-12">12</A>
   5.  RTP Data Transfer Protocol ..................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-13">13</A>
       5.1  RTP Fixed Header Fields ................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-13">13</A>
       5.2  Multiplexing RTP Sessions ..............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-16">16</A>
       5.3  Profile-Specific Modifications to the RTP Header .......  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-18">18</A>
            5.3.1  RTP Header Extension ............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-18">18</A>
   6.  RTP Control Protocol -- RTCP ................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-19">19</A>
       6.1  RTCP Packet Format .....................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-21">21</A>
       6.2  RTCP Transmission Interval .............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-24">24</A>
            6.2.1  Maintaining the Number of Session Members .......  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-28">28</A>
       6.3  RTCP Packet Send and Receive Rules .....................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-28">28</A>
            6.3.1  Computing the RTCP Transmission Interval ........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-29">29</A>
            6.3.2  Initialization ..................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-30">30</A>
            6.3.3  Receiving an RTP or Non-BYE RTCP Packet .........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-31">31</A>
            6.3.4  Receiving an RTCP BYE Packet ....................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-31">31</A>
            6.3.5  Timing Out an SSRC ..............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-32">32</A>
            6.3.6  Expiration of Transmission Timer ................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-32">32</A>
            6.3.7  Transmitting a BYE Packet .......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-33">33</A>
            6.3.8  Updating we_sent ................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-34">34</A>
            6.3.9  Allocation of Source Description Bandwidth ......  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-34">34</A>
       6.4  Sender and Receiver Reports ............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-35">35</A>
            6.4.1  SR: Sender Report RTCP Packet ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-36">36</A>
            6.4.2  RR: Receiver Report RTCP Packet .................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-42">42</A>
            6.4.3  Extending the Sender and Receiver Reports .......  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-42">42</A>
            6.4.4  Analyzing Sender and Receiver Reports ...........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-43">43</A>
       6.5  SDES: Source Description RTCP Packet ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-45">45</A>
            6.5.1  CNAME: Canonical End-Point Identifier SDES Item .  46
            6.5.2  NAME: User Name SDES Item .......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-48">48</A>
            6.5.3  EMAIL: Electronic Mail Address SDES Item ........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-48">48</A>
            6.5.4  PHONE: Phone Number SDES Item ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-49">49</A>
            6.5.5  LOC: Geographic User Location SDES Item .........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-49">49</A>
            6.5.6  TOOL: Application or Tool Name SDES Item ........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-49">49</A>
            6.5.7  NOTE: Notice/Status SDES Item ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-50">50</A>
            6.5.8  PRIV: Private Extensions SDES Item ..............  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-50">50</A>
       6.6  BYE: Goodbye RTCP Packet ...............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-51">51</A>
       6.7  APP: Application-Defined RTCP Packet ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-52">52</A>
   7.  RTP Translators and Mixers ..................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-53">53</A>
       7.1  General Description ....................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-53">53</A>



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 2]</SPAN>
<A id=3Dpage-3 href=3D"http://tools.ietf.org/html/rfc3550#page-3" =
name=3Dpage-3><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


       7.2  RTCP Processing in Translators .........................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-55">55</A>
       7.3  RTCP Processing in Mixers ..............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-57">57</A>
       7.4  Cascaded Mixers ........................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-58">58</A>
   8.  SSRC Identifier Allocation and Use ..........................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-59">59</A>
       8.1  Probability of Collision ...............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-59">59</A>
       8.2  Collision Resolution and Loop Detection ................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-60">60</A>
       8.3  Use with Layered Encodings .............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-64">64</A>
   9.  Security ....................................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-65">65</A>
       9.1  Confidentiality ........................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-65">65</A>
       9.2  Authentication and Message Integrity ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-67">67</A>
   10. Congestion Control ..........................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-67">67</A>
   11. RTP over Network and Transport Protocols ....................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-68">68</A>
   12. Summary of Protocol Constants ...............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-69">69</A>
       12.1 RTCP Packet Types ......................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-70">70</A>
       12.2 SDES Types .............................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-70">70</A>
   13. RTP Profiles and Payload Format Specifications ..............  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-71">71</A>
   14. Security Considerations .....................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-73">73</A>
   15. IANA Considerations .........................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-73">73</A>
   16. Intellectual Property Rights Statement ......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-74">74</A>
   17. Acknowledgments .............................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-74">74</A>
   Appendix A.   Algorithms ........................................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-75">75</A>
   Appendix A.1  RTP Data Header Validity Checks ...................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-78">78</A>
   Appendix A.2  RTCP Header Validity Checks .......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-82">82</A>
   Appendix A.3  Determining Number of Packets Expected and Lost ...  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-83">83</A>
   Appendix A.4  Generating RTCP SDES Packets ......................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-84">84</A>
   Appendix A.5  Parsing RTCP SDES Packets .........................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-85">85</A>
   Appendix A.6  Generating a Random 32-bit Identifier .............  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-85">85</A>
   Appendix A.7  Computing the RTCP Transmission Interval ..........  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-87">87</A>
   Appendix A.8  Estimating the Interarrival Jitter ................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-94">94</A>
   Appendix B.   Changes from <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A> =
.............................  <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-95">95</A>
   References ...................................................... <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-100">100</A>
   Normative References ............................................ <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-100">100</A>
   Informative References .......................................... <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-100">100</A>
   Authors' Addresses .............................................. <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-103">103</A>
   Full Copyright Statement ........................................ <A =
href=3D"http://tools.ietf.org/html/rfc3550#page-104">104</A>
















<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 3]</SPAN>
<A id=3Dpage-4 href=3D"http://tools.ietf.org/html/rfc3550#page-4" =
name=3Dpage-4><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"2"><A name=3Dsection-1>1</A>. =
Introduction</SPAN>

   This memorandum specifies the real-time transport protocol (RTP),
   which provides end-to-end delivery services for data with real-time
   characteristics, such as interactive audio and video.  Those services
   include payload type identification, sequence numbering, timestamping
   and delivery monitoring.  Applications typically run RTP on top of
   UDP to make use of its multiplexing and checksum services; both
   protocols contribute parts of the transport protocol functionality.
   However, RTP may be used with other suitable underlying network or
   transport protocols (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-11">Section 11</A>).  =
RTP supports data transfer to
   multiple destinations using multicast distribution if provided by the
   underlying network.

   Note that RTP itself does not provide any mechanism to ensure timely
   delivery or provide other quality-of-service guarantees, but relies
   on lower-layer services to do so.  It does not guarantee delivery or
   prevent out-of-order delivery, nor does it assume that the underlying
   network is reliable and delivers packets in sequence.  The sequence
   numbers included in RTP allow the receiver to reconstruct the
   sender's packet sequence, but sequence numbers might also be used to
   determine the proper location of a packet, for example in video
   decoding, without necessarily decoding packets in sequence.

   While RTP is primarily designed to satisfy the needs of multi-
   participant multimedia conferences, it is not limited to that
   particular application.  Storage of continuous data, interactive
   distributed simulation, active badge, and control and measurement
   applications may also find RTP applicable.

   This document defines RTP, consisting of two closely-linked parts:

   o  the real-time transport protocol (RTP), to carry data that has
      real-time properties.

   o  the RTP control protocol (RTCP), to monitor the quality of service
      and to convey information about the participants in an on-going
      session.  The latter aspect of RTCP may be sufficient for "loosely
      controlled" sessions, i.e., where there is no explicit membership
      control and set-up, but it is not necessarily intended to support
      all of an application's control communication requirements.  This
      functionality may be fully or partially subsumed by a separate
      session control protocol, which is beyond the scope of this
      document.

   RTP represents a new style of protocol following the principles of
   application level framing and integrated layer processing proposed by
   Clark and Tennenhouse [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-10">10</A>].  That is, =
RTP is intended to be malleable



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 4]</SPAN>
<A id=3Dpage-5 href=3D"http://tools.ietf.org/html/rfc3550#page-5" =
name=3Dpage-5><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   to provide the information required by a particular application and
   will often be integrated into the application processing rather than
   being implemented as a separate layer.  RTP is a protocol framework
   that is deliberately not complete.  This document specifies those
   functions expected to be common across all the applications for which
   RTP would be appropriate.  Unlike conventional protocols in which
   additional functions might be accommodated by making the protocol
   more general or by adding an option mechanism that would require
   parsing, RTP is intended to be tailored through modifications and/or
   additions to the headers as needed.  Examples are given in Sections
   5.3 and 6.4.3.

   Therefore, in addition to this document, a complete specification of
   RTP for a particular application will require one or more companion
   documents (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-13">Section 13</A>):

   o  a profile specification document, which defines a set of payload
      type codes and their mapping to payload formats (e.g., media
      encodings).  A profile may also define extensions or modifications
      to RTP that are specific to a particular class of applications.
      Typically an application will operate under only one profile.  A
      profile for audio and video data may be found in the companion <A =
href=3D"http://tools.ietf.org/html/rfc3551">RFC</A>
      <A href=3D"http://tools.ietf.org/html/rfc3551">3551</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-1">1</A>].

   o  payload format specification documents, which define how a
      particular payload, such as an audio or video encoding, is to be
      carried in RTP.

   A discussion of real-time services and algorithms for their
   implementation as well as background discussion on some of the RTP
   design decisions can be found in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-11">11</A>].

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-1.1>1.1</A> =
Terminology</SPAN>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in <A =
href=3D"http://tools.ietf.org/html/bcp14">BCP 14</A>, <A =
href=3D"http://tools.ietf.org/html/rfc2119">RFC 2119</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-2">2</A>]
   and indicate requirement levels for compliant RTP implementations.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-2>2</A>. RTP Use =
Scenarios</SPAN>

   The following sections describe some aspects of the use of RTP.  The
   examples were chosen to illustrate the basic operation of
   applications using RTP, not to limit what RTP may be used for.  In
   these examples, RTP is carried on top of IP and UDP, and follows the
   conventions established by the profile for audio and video specified
   in the companion <A href=3D"http://tools.ietf.org/html/rfc3551">RFC =
3551</A>.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 5]</SPAN>
<A id=3Dpage-6 href=3D"http://tools.ietf.org/html/rfc3550#page-6" =
name=3Dpage-6><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"3"><A name=3Dsection-2.1>2.1</A> Simple =
Multicast Audio Conference</SPAN>

   A working group of the IETF meets to discuss the latest protocol
   document, using the IP multicast services of the Internet for voice
   communications.  Through some allocation mechanism the working group
   chair obtains a multicast group address and pair of ports.  One port
   is used for audio data, and the other is used for control (RTCP)
   packets.  This address and port information is distributed to the
   intended participants.  If privacy is desired, the data and control
   packets may be encrypted as specified in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>, =
in which case
   an encryption key must also be generated and distributed.  The exact
   details of these allocation and distribution mechanisms are beyond
   the scope of RTP.

   The audio conferencing application used by each conference
   participant sends audio data in small chunks of, say, 20 ms duration.
   Each chunk of audio data is preceded by an RTP header; RTP header and
   data are in turn contained in a UDP packet.  The RTP header indicates
   what type of audio encoding (such as PCM, ADPCM or LPC) is contained
   in each packet so that senders can change the encoding during a
   conference, for example, to accommodate a new participant that is
   connected through a low-bandwidth link or react to indications of
   network congestion.

   The Internet, like other packet networks, occasionally loses and
   reorders packets and delays them by variable amounts of time.  To
   cope with these impairments, the RTP header contains timing
   information and a sequence number that allow the receivers to
   reconstruct the timing produced by the source, so that in this
   example, chunks of audio are contiguously played out the speaker
   every 20 ms.  This timing reconstruction is performed separately for
   each source of RTP packets in the conference.  The sequence number
   can also be used by the receiver to estimate how many packets are
   being lost.

   Since members of the working group join and leave during the
   conference, it is useful to know who is participating at any moment
   and how well they are receiving the audio data.  For that purpose,
   each instance of the audio application in the conference periodically
   multicasts a reception report plus the name of its user on the RTCP
   (control) port.  The reception report indicates how well the current
   speaker is being received and may be used to control adaptive
   encodings.  In addition to the user name, other identifying
   information may also be included subject to control bandwidth limits.
   A site sends the RTCP BYE packet (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.6">Section 6.6</A>) =
when it leaves the
   conference.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 6]</SPAN>
<A id=3Dpage-7 href=3D"http://tools.ietf.org/html/rfc3550#page-7" =
name=3Dpage-7><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"3"><A name=3Dsection-2.2>2.2</A> Audio and =
Video Conference</SPAN>

   If both audio and video media are used in a conference, they are
   transmitted as separate RTP sessions.  That is, separate RTP and RTCP
   packets are transmitted for each medium using two different UDP port
   pairs and/or multicast addresses.  There is no direct coupling at the
   RTP level between the audio and video sessions, except that a user
   participating in both sessions should use the same distinguished
   (canonical) name in the RTCP packets for both so that the sessions
   can be associated.

   One motivation for this separation is to allow some participants in
   the conference to receive only one medium if they choose.  Further
   explanation is given in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.2">Section 5.2</A>. =
 Despite the separation,
   synchronized playback of a source's audio and video can be achieved
   using timing information carried in the RTCP packets for both
   sessions.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-2.3>2.3</A> Mixers =
and Translators</SPAN>

   So far, we have assumed that all sites want to receive media data in
   the same format.  However, this may not always be appropriate.
   Consider the case where participants in one area are connected
   through a low-speed link to the majority of the conference
   participants who enjoy high-speed network access.  Instead of forcing
   everyone to use a lower-bandwidth, reduced-quality audio encoding, an
   RTP-level relay called a mixer may be placed near the low-bandwidth
   area.  This mixer resynchronizes incoming audio packets to
   reconstruct the constant 20 ms spacing generated by the sender, mixes
   these reconstructed audio streams into a single stream, translates
   the audio encoding to a lower-bandwidth one and forwards the lower-
   bandwidth packet stream across the low-speed link.  These packets
   might be unicast to a single recipient or multicast on a different
   address to multiple recipients.  The RTP header includes a means for
   mixers to identify the sources that contributed to a mixed packet so
   that correct talker indication can be provided at the receivers.

   Some of the intended participants in the audio conference may be
   connected with high bandwidth links but might not be directly
   reachable via IP multicast.  For example, they might be behind an
   application-level firewall that will not let any IP packets pass.
   For these sites, mixing may not be necessary, in which case another
   type of RTP-level relay called a translator may be used.  Two
   translators are installed, one on either side of the firewall, with
   the outside one funneling all multicast packets received through a
   secure connection to the translator inside the firewall.  The
   translator inside the firewall sends them again as multicast packets
   to a multicast group restricted to the site's internal network.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 7]</SPAN>
<A id=3Dpage-8 href=3D"http://tools.ietf.org/html/rfc3550#page-8" =
name=3Dpage-8><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Mixers and translators may be designed for a variety of purposes.  An
   example is a video mixer that scales the images of individual people
   in separate video streams and composites them into one video stream
   to simulate a group scene.  Other examples of translation include the
   connection of a group of hosts speaking only IP/UDP to a group of
   hosts that understand only ST-II, or the packet-by-packet encoding
   translation of video streams from individual sources without
   resynchronization or mixing.  Details of the operation of mixers and
   translators are given in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-7">Section 7</A>.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-2.4>2.4</A> Layered =
Encodings</SPAN>

   Multimedia applications should be able to adjust the transmission
   rate to match the capacity of the receiver or to adapt to network
   congestion.  Many implementations place the responsibility of rate-
   adaptivity at the source.  This does not work well with multicast
   transmission because of the conflicting bandwidth requirements of
   heterogeneous receivers.  The result is often a least-common
   denominator scenario, where the smallest pipe in the network mesh
   dictates the quality and fidelity of the overall live multimedia
   "broadcast".

   Instead, responsibility for rate-adaptation can be placed at the
   receivers by combining a layered encoding with a layered transmission
   system.  In the context of RTP over IP multicast, the source can
   stripe the progressive layers of a hierarchically represented signal
   across multiple RTP sessions each carried on its own multicast group.
   Receivers can then adapt to network heterogeneity and control their
   reception bandwidth by joining only the appropriate subset of the
   multicast groups.

   Details of the use of RTP with layered encodings are given in
   Sections 6.3.9, 8.3 and 11.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-3>3</A>. =
Definitions</SPAN>

   RTP payload: The data transported by RTP in a packet, for
      example audio samples or compressed video data.  The payload
      format and interpretation are beyond the scope of this document.

   RTP packet: A data packet consisting of the fixed RTP header, a
      possibly empty list of contributing sources (see below), and the
      payload data.  Some underlying protocols may require an
      encapsulation of the RTP packet to be defined.  Typically one
      packet of the underlying protocol contains a single RTP packet,
      but several RTP packets MAY be contained if permitted by the
      encapsulation method (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-11">Section 11</A>).




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 8]</SPAN>
<A id=3Dpage-9 href=3D"http://tools.ietf.org/html/rfc3550#page-9" =
name=3Dpage-9><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   RTCP packet: A control packet consisting of a fixed header part
      similar to that of RTP data packets, followed by structured
      elements that vary depending upon the RTCP packet type.  The
      formats are defined in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6">Section 6</A>.  =
Typically, multiple RTCP
      packets are sent together as a compound RTCP packet in a single
      packet of the underlying protocol; this is enabled by the length
      field in the fixed header of each RTCP packet.

   Port: The "abstraction that transport protocols use to
      distinguish among multiple destinations within a given host
      computer.  TCP/IP protocols identify ports using small positive
      integers." [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-12">12</A>] The transport =
selectors (TSEL) used by the OSI
      transport layer are equivalent to ports.  RTP depends upon the
      lower-layer protocol to provide some mechanism such as ports to
      multiplex the RTP and RTCP packets of a session.

   Transport address: The combination of a network address and port
      that identifies a transport-level endpoint, for example an IP
      address and a UDP port.  Packets are transmitted from a source
      transport address to a destination transport address.

   RTP media type: An RTP media type is the collection of payload
      types which can be carried within a single RTP session.  The RTP
      Profile assigns RTP media types to RTP payload types.

   Multimedia session: A set of concurrent RTP sessions among a
      common group of participants.  For example, a videoconference
      (which is a multimedia session) may contain an audio RTP session
      and a video RTP session.

   RTP session: An association among a set of participants
      communicating with RTP.  A participant may be involved in multiple
      RTP sessions at the same time.  In a multimedia session, each
      medium is typically carried in a separate RTP session with its own
      RTCP packets unless the the encoding itself multiplexes multiple
      media into a single data stream.  A participant distinguishes
      multiple RTP sessions by reception of different sessions using
      different pairs of destination transport addresses, where a pair
      of transport addresses comprises one network address plus a pair
      of ports for RTP and RTCP.  All participants in an RTP session may
      share a common destination transport address pair, as in the case
      of IP multicast, or the pairs may be different for each
      participant, as in the case of individual unicast network
      addresses and port pairs.  In the unicast case, a participant may
      receive from all other participants in the session using the same
      pair of ports, or may use a distinct pair of ports for each.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
          [Page 9]</SPAN>
<A id=3Dpage-10 href=3D"http://tools.ietf.org/html/rfc3550#page-10" =
name=3Dpage-10><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      The distinguishing feature of an RTP session is that each
      maintains a full, separate space of SSRC identifiers (defined
      next).  The set of participants included in one RTP session
      consists of those that can receive an SSRC identifier transmitted
      by any one of the participants either in RTP as the SSRC or a CSRC
      (also defined below) or in RTCP.  For example, consider a three-
      party conference implemented using unicast UDP with each
      participant receiving from the other two on separate port pairs.
      If each participant sends RTCP feedback about data received from
      one other participant only back to that participant, then the
      conference is composed of three separate point-to-point RTP
      sessions.  If each participant provides RTCP feedback about its
      reception of one other participant to both of the other
      participants, then the conference is composed of one multi-party
      RTP session.  The latter case simulates the behavior that would
      occur with IP multicast communication among the three
      participants.

      The RTP framework allows the variations defined here, but a
      particular control protocol or application design will usually
      impose constraints on these variations.

   Synchronization source (SSRC): The source of a stream of RTP
      packets, identified by a 32-bit numeric SSRC identifier carried in
      the RTP header so as not to be dependent upon the network address.
      All packets from a synchronization source form part of the same
      timing and sequence number space, so a receiver groups packets by
      synchronization source for playback.  Examples of synchronization
      sources include the sender of a stream of packets derived from a
      signal source such as a microphone or a camera, or an RTP mixer
      (see below).  A synchronization source may change its data format,
      e.g., audio encoding, over time.  The SSRC identifier is a
      randomly chosen value meant to be globally unique within a
      particular RTP session (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8">Section 8</A>).  A =
participant need not
      use the same SSRC identifier for all the RTP sessions in a
      multimedia session; the binding of the SSRC identifiers is
      provided through RTCP (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.1">Section =
6.5.1</A>).  If a participant
      generates multiple streams in one RTP session, for example from
      separate video cameras, each MUST be identified as a different
      SSRC.

   Contributing source (CSRC): A source of a stream of RTP packets
      that has contributed to the combined stream produced by an RTP
      mixer (see below).  The mixer inserts a list of the SSRC
      identifiers of the sources that contributed to the generation of a
      particular packet into the RTP header of that packet.  This list
      is called the CSRC list.  An example application is audio
      conferencing where a mixer indicates all the talkers whose speech



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 10]</SPAN>
<A id=3Dpage-11 href=3D"http://tools.ietf.org/html/rfc3550#page-11" =
name=3Dpage-11><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      was combined to produce the outgoing packet, allowing the receiver
      to indicate the current talker, even though all the audio packets
      contain the same SSRC identifier (that of the mixer).

   End system: An application that generates the content to be sent
      in RTP packets and/or consumes the content of received RTP
      packets.  An end system can act as one or more synchronization
      sources in a particular RTP session, but typically only one.

   Mixer: An intermediate system that receives RTP packets from one
      or more sources, possibly changes the data format, combines the
      packets in some manner and then forwards a new RTP packet.  Since
      the timing among multiple input sources will not generally be
      synchronized, the mixer will make timing adjustments among the
      streams and generate its own timing for the combined stream.
      Thus, all data packets originating from a mixer will be identified
      as having the mixer as their synchronization source.

   Translator: An intermediate system that forwards RTP packets
      with their synchronization source identifier intact.  Examples of
      translators include devices that convert encodings without mixing,
      replicators from multicast to unicast, and application-level
      filters in firewalls.

   Monitor: An application that receives RTCP packets sent by
      participants in an RTP session, in particular the reception
      reports, and estimates the current quality of service for
      distribution monitoring, fault diagnosis and long-term statistics.
      The monitor function is likely to be built into the application(s)
      participating in the session, but may also be a separate
      application that does not otherwise participate and does not send
      or receive the RTP data packets (since they are on a separate
      port).  These are called third-party monitors.  It is also
      acceptable for a third-party monitor to receive the RTP data
      packets but not send RTCP packets or otherwise be counted in the
      session.

   Non-RTP means: Protocols and mechanisms that may be needed in
      addition to RTP to provide a usable service.  In particular, for
      multimedia conferences, a control protocol may distribute
      multicast addresses and keys for encryption, negotiate the
      encryption algorithm to be used, and define dynamic mappings
      between RTP payload type values and the payload formats they
      represent for formats that do not have a predefined payload type
      value.  Examples of such protocols include the Session Initiation
      Protocol (SIP) (<A href=3D"http://tools.ietf.org/html/rfc3261">RFC =
3261</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-13">13</A>]), ITU =
Recommendation H.323 [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-14">14</A>] and
      applications using SDP (<A =
href=3D"http://tools.ietf.org/html/rfc2327">RFC 2327</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-15">15</A>]), such as =
RTSP (<A href=3D"http://tools.ietf.org/html/rfc2326">RFC 2326</A>
      [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-16">16</A>]).  =
For simple



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 11]</SPAN>
<A id=3Dpage-12 href=3D"http://tools.ietf.org/html/rfc3550#page-12" =
name=3Dpage-12><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      applications, electronic mail or a conference database may also be
      used.  The specification of such protocols and mechanisms is
      outside the scope of this document.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-4>4</A>. Byte Order, =
Alignment, and Time Format</SPAN>

   All integer fields are carried in network byte order, that is, most
   significant byte (octet) first.  This byte order is commonly known as
   big-endian.  The transmission order is described in detail in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-3">3</A>].
   Unless otherwise noted, numeric constants are in decimal (base 10).

   All header data is aligned to its natural length, i.e., 16-bit fields
   are aligned on even offsets, 32-bit fields are aligned at offsets
   divisible by four, etc.  Octets designated as padding have the value
   zero.

   Wallclock time (absolute date and time) is represented using the
   timestamp format of the Network Time Protocol (NTP), which is in
   seconds relative to 0h UTC on 1 January 1900 [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-4">4</A>].  The full
   resolution NTP timestamp is a 64-bit unsigned fixed-point number with
   the integer part in the first 32 bits and the fractional part in the
   last 32 bits.  In some fields where a more compact representation is
   appropriate, only the middle 32 bits are used; that is, the low 16
   bits of the integer part and the high 16 bits of the fractional part.
   The high 16 bits of the integer part must be determined
   independently.

   An implementation is not required to run the Network Time Protocol in
   order to use RTP.  Other time sources, or none at all, may be used
   (see the description of the NTP timestamp field in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.1">Section =
6.4.1</A>).
   However, running NTP may be useful for synchronizing streams
   transmitted from separate hosts.

   The NTP timestamp will wrap around to zero some time in the year
   2036, but for RTP purposes, only differences between pairs of NTP
   timestamps are used.  So long as the pairs of timestamps can be
   assumed to be within 68 years of each other, using modular arithmetic
   for subtractions and comparisons makes the wraparound irrelevant.













<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 12]</SPAN>
<A id=3Dpage-13 href=3D"http://tools.ietf.org/html/rfc3550#page-13" =
name=3Dpage-13><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"2"><A name=3Dsection-5>5</A>. RTP Data =
Transfer Protocol</SPAN>

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-5.1>5.1</A> RTP Fixed =
Header Fields</SPAN>

   The RTP header has the following format:

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=3D2|P|X|  CC   |M|     PT      |       sequence number         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           timestamp                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           synchronization source (SSRC) identifier            |
   =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
   |            contributing source (CSRC) identifiers             |
   |                             ....                              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The first twelve octets are present in every RTP packet, while the
   list of CSRC identifiers is present only when inserted by a mixer.
   The fields have the following meaning:

   version (V): 2 bits
      This field identifies the version of RTP.  The version defined by
      this specification is two (2).  (The value 1 is used by the first
      draft version of RTP and the value 0 is used by the protocol
      initially implemented in the "vat" audio tool.)

   padding (P): 1 bit
      If the padding bit is set, the packet contains one or more
      additional padding octets at the end which are not part of the
      payload.  The last octet of the padding contains a count of how
      many padding octets should be ignored, including itself.  Padding
      may be needed by some encryption algorithms with fixed block sizes
      or for carrying several RTP packets in a lower-layer protocol data
      unit.

   extension (X): 1 bit
      If the extension bit is set, the fixed header MUST be followed by
      exactly one header extension, with a format defined in Section
      5.3.1.

   CSRC count (CC): 4 bits
      The CSRC count contains the number of CSRC identifiers that follow
      the fixed header.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 13]</SPAN>
<A id=3Dpage-14 href=3D"http://tools.ietf.org/html/rfc3550#page-14" =
name=3Dpage-14><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   marker (M): 1 bit
      The interpretation of the marker is defined by a profile.  It is
      intended to allow significant events such as frame boundaries to
      be marked in the packet stream.  A profile MAY define additional
      marker bits or specify that there is no marker bit by changing the
      number of bits in the payload type field (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.3">Section =
5.3</A>).

   payload type (PT): 7 bits
      This field identifies the format of the RTP payload and determines
      its interpretation by the application.  A profile MAY specify a
      default static mapping of payload type codes to payload formats.
      Additional payload type codes MAY be defined dynamically through
      non-RTP means (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-3">Section 3</A>).  A =
set of default mappings for
      audio and video is specified in the companion <A =
href=3D"http://tools.ietf.org/html/rfc3551">RFC 3551</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-1">1</A>].  An
      RTP source MAY change the payload type during a session, but this
      field SHOULD NOT be used for multiplexing separate media streams
      (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.2">Section =
5.2</A>).

      A receiver MUST ignore packets with payload types that it does not
      understand.

   sequence number: 16 bits
      The sequence number increments by one for each RTP data packet
      sent, and may be used by the receiver to detect packet loss and to
      restore packet sequence.  The initial value of the sequence number
      SHOULD be random (unpredictable) to make known-plaintext attacks
      on encryption more difficult, even if the source itself does not
      encrypt according to the method in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>, =
because the
      packets may flow through a translator that does.  Techniques for
      choosing unpredictable numbers are discussed in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-17">17</A>].

   timestamp: 32 bits
      The timestamp reflects the sampling instant of the first octet in
      the RTP data packet.  The sampling instant MUST be derived from a
      clock that increments monotonically and linearly in time to allow
      synchronization and jitter calculations (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.1">Section =
6.4.1</A>).  The
      resolution of the clock MUST be sufficient for the desired
      synchronization accuracy and for measuring packet arrival jitter
      (one tick per video frame is typically not sufficient).  The clock
      frequency is dependent on the format of data carried as payload
      and is specified statically in the profile or payload format
      specification that defines the format, or MAY be specified
      dynamically for payload formats defined through non-RTP means.  If
      RTP packets are generated periodically, the nominal sampling
      instant as determined from the sampling clock is to be used, not a
      reading of the system clock.  As an example, for fixed-rate audio
      the timestamp clock would likely increment by one for each
      sampling period.  If an audio application reads blocks covering



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 14]</SPAN>
<A id=3Dpage-15 href=3D"http://tools.ietf.org/html/rfc3550#page-15" =
name=3Dpage-15><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      160 sampling periods from the input device, the timestamp would be
      increased by 160 for each such block, regardless of whether the
      block is transmitted in a packet or dropped as silent.

      The initial value of the timestamp SHOULD be random, as for the
      sequence number.  Several consecutive RTP packets will have equal
      timestamps if they are (logically) generated at once, e.g., belong
      to the same video frame.  Consecutive RTP packets MAY contain
      timestamps that are not monotonic if the data is not transmitted
      in the order it was sampled, as in the case of MPEG interpolated
      video frames.  (The sequence numbers of the packets as transmitted
      will still be monotonic.)

      RTP timestamps from different media streams may advance at
      different rates and usually have independent, random offsets.
      Therefore, although these timestamps are sufficient to reconstruct
      the timing of a single stream, directly comparing RTP timestamps
      from different media is not effective for synchronization.
      Instead, for each medium the RTP timestamp is related to the
      sampling instant by pairing it with a timestamp from a reference
      clock (wallclock) that represents the time when the data
      corresponding to the RTP timestamp was sampled.  The reference
      clock is shared by all media to be synchronized.  The timestamp
      pairs are not transmitted in every data packet, but at a lower
      rate in RTCP SR packets as described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4">Section 6.4</A>.

      The sampling instant is chosen as the point of reference for the
      RTP timestamp because it is known to the transmitting endpoint and
      has a common definition for all media, independent of encoding
      delays or other processing.  The purpose is to allow synchronized
      presentation of all media sampled at the same time.

      Applications transmitting stored data rather than data sampled in
      real time typically use a virtual presentation timeline derived
      from wallclock time to determine when the next frame or other unit
      of each medium in the stored data should be presented.  In this
      case, the RTP timestamp would reflect the presentation time for
      each unit.  That is, the RTP timestamp for each unit would be
      related to the wallclock time at which the unit becomes current on
      the virtual presentation timeline.  Actual presentation occurs
      some time later as determined by the receiver.

      An example describing live audio narration of prerecorded video
      illustrates the significance of choosing the sampling instant as
      the reference point.  In this scenario, the video would be
      presented locally for the narrator to view and would be
      simultaneously transmitted using RTP.  The "sampling instant" of a
      video frame transmitted in RTP would be established by referencing



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 15]</SPAN>
<A id=3Dpage-16 href=3D"http://tools.ietf.org/html/rfc3550#page-16" =
name=3Dpage-16><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      its timestamp to the wallclock time when that video frame was
      presented to the narrator.  The sampling instant for the audio RTP
      packets containing the narrator's speech would be established by
      referencing the same wallclock time when the audio was sampled.
      The audio and video may even be transmitted by different hosts if
      the reference clocks on the two hosts are synchronized by some
      means such as NTP.  A receiver can then synchronize presentation
      of the audio and video packets by relating their RTP timestamps
      using the timestamp pairs in RTCP SR packets.

   SSRC: 32 bits
      The SSRC field identifies the synchronization source.  This
      identifier SHOULD be chosen randomly, with the intent that no two
      synchronization sources within the same RTP session will have the
      same SSRC identifier.  An example algorithm for generating a
      random identifier is presented in Appendix A.6.  Although the
      probability of multiple sources choosing the same identifier is
      low, all RTP implementations must be prepared to detect and
      resolve collisions.  <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8">Section 8</A> =
describes the probability of
      collision along with a mechanism for resolving collisions and
      detecting RTP-level forwarding loops based on the uniqueness of
      the SSRC identifier.  If a source changes its source transport
      address, it must also choose a new SSRC identifier to avoid being
      interpreted as a looped source (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section =
8.2</A>).

   CSRC list: 0 to 15 items, 32 bits each
      The CSRC list identifies the contributing sources for the payload
      contained in this packet.  The number of identifiers is given by
      the CC field.  If there are more than 15 contributing sources,
      only 15 can be identified.  CSRC identifiers are inserted by
      mixers (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-7.1">Section =
7.1</A>), using the SSRC identifiers of
      contributing sources.  For example, for audio packets the SSRC
      identifiers of all sources that were mixed together to create a
      packet are listed, allowing correct talker indication at the
      receiver.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-5.2>5.2</A> =
Multiplexing RTP Sessions</SPAN>

   For efficient protocol processing, the number of multiplexing points
   should be minimized, as described in the integrated layer processing
   design principle [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-10">10</A>].  In RTP, =
multiplexing is provided by the
   destination transport address (network address and port number) which
   is different for each RTP session.  For example, in a teleconference
   composed of audio and video media encoded separately, each medium
   SHOULD be carried in a separate RTP session with its own destination
   transport address.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 16]</SPAN>
<A id=3Dpage-17 href=3D"http://tools.ietf.org/html/rfc3550#page-17" =
name=3Dpage-17><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Separate audio and video streams SHOULD NOT be carried in a single
   RTP session and demultiplexed based on the payload type or SSRC
   fields.  Interleaving packets with different RTP media types but
   using the same SSRC would introduce several problems:

   1. If, say, two audio streams shared the same RTP session and the
      same SSRC value, and one were to change encodings and thus acquire
      a different RTP payload type, there would be no general way of
      identifying which stream had changed encodings.

   2. An SSRC is defined to identify a single timing and sequence number
      space.  Interleaving multiple payload types would require
      different timing spaces if the media clock rates differ and would
      require different sequence number spaces to tell which payload
      type suffered packet loss.

   3. The RTCP sender and receiver reports (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4">Section 6.4</A>) =
can only
      describe one timing and sequence number space per SSRC and do not
      carry a payload type field.

   4. An RTP mixer would not be able to combine interleaved streams of
      incompatible media into one stream.

   5. Carrying multiple media in one RTP session precludes: the use of
      different network paths or network resource allocations if
      appropriate; reception of a subset of the media if desired, for
      example just audio if video would exceed the available bandwidth;
      and receiver implementations that use separate processes for the
      different media, whereas using separate RTP sessions permits
      either single- or multiple-process implementations.

   Using a different SSRC for each medium but sending them in the same
   RTP session would avoid the first three problems but not the last
   two.

   On the other hand, multiplexing multiple related sources of the same
   medium in one RTP session using different SSRC values is the norm for
   multicast sessions.  The problems listed above don't apply: an RTP
   mixer can combine multiple audio sources, for example, and the same
   treatment is applicable for all of them.  It may also be appropriate
   to multiplex streams of the same medium using different SSRC values
   in other scenarios where the last two problems do not apply.









<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 17]</SPAN>
<A id=3Dpage-18 href=3D"http://tools.ietf.org/html/rfc3550#page-18" =
name=3Dpage-18><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"3"><A name=3Dsection-5.3>5.3</A> =
Profile-Specific Modifications to the RTP Header</SPAN>

   The existing RTP data packet header is believed to be complete for
   the set of functions required in common across all the application
   classes that RTP might support.  However, in keeping with the ALF
   design principle, the header MAY be tailored through modifications or
   additions defined in a profile specification while still allowing
   profile-independent monitoring and recording tools to function.

   o  The marker bit and payload type field carry profile-specific
      information, but they are allocated in the fixed header since many
      applications are expected to need them and might otherwise have to
      add another 32-bit word just to hold them.  The octet containing
      these fields MAY be redefined by a profile to suit different
      requirements, for example with more or fewer marker bits.  If
      there are any marker bits, one SHOULD be located in the most
      significant bit of the octet since profile-independent monitors
      may be able to observe a correlation between packet loss patterns
      and the marker bit.

   o  Additional information that is required for a particular payload
      format, such as a video encoding, SHOULD be carried in the payload
      section of the packet.  This might be in a header that is always
      present at the start of the payload section, or might be indicated
      by a reserved value in the data pattern.

   o  If a particular class of applications needs additional
      functionality independent of payload format, the profile under
      which those applications operate SHOULD define additional fixed
      fields to follow immediately after the SSRC field of the existing
      fixed header.  Those applications will be able to quickly and
      directly access the additional fields while profile-independent
      monitors or recorders can still process the RTP packets by
      interpreting only the first twelve octets.

   If it turns out that additional functionality is needed in common
   across all profiles, then a new version of RTP should be defined to
   make a permanent change to the fixed header.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-5.3.1>5.3.1</A> RTP =
Header Extension</SPAN>

   An extension mechanism is provided to allow individual
   implementations to experiment with new payload-format-independent
   functions that require additional information to be carried in the
   RTP data packet header.  This mechanism is designed so that the
   header extension may be ignored by other interoperating
   implementations that have not been extended.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 18]</SPAN>
<A id=3Dpage-19 href=3D"http://tools.ietf.org/html/rfc3550#page-19" =
name=3Dpage-19><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Note that this header extension is intended only for limited use.
   Most potential uses of this mechanism would be better done another
   way, using the methods described in the previous section.  For
   example, a profile-specific extension to the fixed header is less
   expensive to process because it is not conditional nor in a variable
   location.  Additional information required for a particular payload
   format SHOULD NOT use this header extension, but SHOULD be carried in
   the payload section of the packet.

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      defined by profile       |           length              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        header extension                       |
   |                             ....                              |

   If the X bit in the RTP header is one, a variable-length header
   extension MUST be appended to the RTP header, following the CSRC list
   if present.  The header extension contains a 16-bit length field that
   counts the number of 32-bit words in the extension, excluding the
   four-octet extension header (therefore zero is a valid length).  Only
   a single extension can be appended to the RTP data header.  To allow
   multiple interoperating implementations to each experiment
   independently with different header extensions, or to allow a
   particular implementation to experiment with more than one type of
   header extension, the first 16 bits of the header extension are left
   open for distinguishing identifiers or parameters.  The format of
   these 16 bits is to be defined by the profile specification under
   which the implementations are operating.  This RTP specification does
   not define any header extensions itself.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-6>6</A>. RTP Control =
Protocol -- RTCP</SPAN>

   The RTP control protocol (RTCP) is based on the periodic transmission
   of control packets to all participants in the session, using the same
   distribution mechanism as the data packets.  The underlying protocol
   MUST provide multiplexing of the data and control packets, for
   example using separate port numbers with UDP.  RTCP performs four
   functions:

   1. The primary function is to provide feedback on the quality of the
      data distribution.  This is an integral part of the RTP's role as
      a transport protocol and is related to the flow and congestion
      control functions of other transport protocols (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-10">Section 10</A> on
      the requirement for congestion control).  The feedback may be
      directly useful for control of adaptive encodings [18,19], but
      experiments with IP multicasting have shown that it is also



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 19]</SPAN>
<A id=3Dpage-20 href=3D"http://tools.ietf.org/html/rfc3550#page-20" =
name=3Dpage-20><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      critical to get feedback from the receivers to diagnose faults in
      the distribution.  Sending reception feedback reports to all
      participants allows one who is observing problems to evaluate
      whether those problems are local or global.  With a distribution
      mechanism like IP multicast, it is also possible for an entity
      such as a network service provider who is not otherwise involved
      in the session to receive the feedback information and act as a
      third-party monitor to diagnose network problems.  This feedback
      function is performed by the RTCP sender and receiver reports,
      described below in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4">Section 6.4</A>.

   2. RTCP carries a persistent transport-level identifier for an RTP
      source called the canonical name or CNAME, <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.1">Section =
6.5.1</A>.  Since
      the SSRC identifier may change if a conflict is discovered or a
      program is restarted, receivers require the CNAME to keep track of
      each participant.  Receivers may also require the CNAME to
      associate multiple data streams from a given participant in a set
      of related RTP sessions, for example to synchronize audio and
      video.  Inter-media synchronization also requires the NTP and RTP
      timestamps included in RTCP packets by data senders.

   3. The first two functions require that all participants send RTCP
      packets, therefore the rate must be controlled in order for RTP to
      scale up to a large number of participants.  By having each
      participant send its control packets to all the others, each can
      independently observe the number of participants.  This number is
      used to calculate the rate at which the packets are sent, as
      explained in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>.

   4. A fourth, OPTIONAL function is to convey minimal session control
      information, for example participant identification to be
      displayed in the user interface.  This is most likely to be useful
      in "loosely controlled" sessions where participants enter and
      leave without membership control or parameter negotiation.  RTCP
      serves as a convenient channel to reach all the participants, but
      it is not necessarily expected to support all the control
      communication requirements of an application.  A higher-level
      session control protocol, which is beyond the scope of this
      document, may be needed.

   Functions 1-3 SHOULD be used in all environments, but particularly in
   the IP multicast environment.  RTP application designers SHOULD avoid
   mechanisms that can only work in unicast mode and will not scale to
   larger numbers.  Transmission of RTCP MAY be controlled separately
   for senders and receivers, as described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>, =
for cases
   such as unidirectional links where feedback from receivers is not
   possible.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 20]</SPAN>
<A id=3Dpage-21 href=3D"http://tools.ietf.org/html/rfc3550#page-21" =
name=3Dpage-21><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Non-normative note:  In the multicast routing approach
      called Source-Specific Multicast (SSM), there is only one sender
      per "channel" (a source address, group address pair), and
      receivers (except for the channel source) cannot use multicast to
      communicate directly with other channel members.  The
      recommendations here accommodate SSM only through <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section =
6.2</A>'s
      option of turning off receivers' RTCP entirely.  Future work will
      specify adaptation of RTCP for SSM so that feedback from receivers
      can be maintained.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.1>6.1</A> RTCP =
Packet Format</SPAN>

   This specification defines several RTCP packet types to carry a
   variety of control information:

   SR:   Sender report, for transmission and reception statistics from
         participants that are active senders

   RR:   Receiver report, for reception statistics from participants
         that are not active senders and in combination with SR for
         active senders reporting on more than 31 sources

   SDES: Source description items, including CNAME

   BYE:  Indicates end of participation

   APP:  Application-specific functions

   Each RTCP packet begins with a fixed part similar to that of RTP data
   packets, followed by structured elements that MAY be of variable
   length according to the packet type but MUST end on a 32-bit
   boundary.  The alignment requirement and a length field in the fixed
   part of each packet are included to make RTCP packets "stackable".
   Multiple RTCP packets can be concatenated without any intervening
   separators to form a compound RTCP packet that is sent in a single
   packet of the lower layer protocol, for example UDP.  There is no
   explicit count of individual RTCP packets in the compound packet
   since the lower layer protocols are expected to provide an overall
   length to determine the end of the compound packet.

   Each individual RTCP packet in the compound packet may be processed
   independently with no requirements upon the order or combination of
   packets.  However, in order to perform the functions of the protocol,
   the following constraints are imposed:







<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 21]</SPAN>
<A id=3Dpage-22 href=3D"http://tools.ietf.org/html/rfc3550#page-22" =
name=3Dpage-22><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  Reception statistics (in SR or RR) should be sent as often as
      bandwidth constraints will allow to maximize the resolution of the
      statistics, therefore each periodically transmitted compound RTCP
      packet MUST include a report packet.

   o  New receivers need to receive the CNAME for a source as soon as
      possible to identify the source and to begin associating media for
      purposes such as lip-sync, so each compound RTCP packet MUST also
      include the SDES CNAME except when the compound RTCP packet is
      split for partial encryption as described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>.

   o  The number of packet types that may appear first in the compound
      packet needs to be limited to increase the number of constant bits
      in the first word and the probability of successfully validating
      RTCP packets against misaddressed RTP data packets or other
      unrelated packets.

   Thus, all RTCP packets MUST be sent in a compound packet of at least
   two individual packets, with the following format:

   Encryption prefix:  If and only if the compound packet is to be
      encrypted according to the method in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>, =
it MUST be
      prefixed by a random 32-bit quantity redrawn for every compound
      packet transmitted.  If padding is required for the encryption, it
      MUST be added to the last packet of the compound packet.

   SR or RR:  The first RTCP packet in the compound packet MUST
      always be a report packet to facilitate header validation as
      described in Appendix A.2.  This is true even if no data has been
      sent or received, in which case an empty RR MUST be sent, and even
      if the only other RTCP packet in the compound packet is a BYE.

   Additional RRs:  If the number of sources for which reception
      statistics are being reported exceeds 31, the number that will fit
      into one SR or RR packet, then additional RR packets SHOULD follow
      the initial report packet.

   SDES:  An SDES packet containing a CNAME item MUST be included
      in each compound RTCP packet, except as noted in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>.
      Other source description items MAY optionally be included if
      required by a particular application, subject to bandwidth
      constraints (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.9">Section =
6.3.9</A>).

   BYE or APP:  Other RTCP packet types, including those yet to be
      defined, MAY follow in any order, except that BYE SHOULD be the
      last packet sent with a given SSRC/CSRC.  Packet types MAY appear
      more than once.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 22]</SPAN>
<A id=3Dpage-23 href=3D"http://tools.ietf.org/html/rfc3550#page-23" =
name=3Dpage-23><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   An individual RTP participant SHOULD send only one compound RTCP
   packet per report interval in order for the RTCP bandwidth per
   participant to be estimated correctly (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section =
6.2</A>), except when
   the compound RTCP packet is split for partial encryption as described
   in <A href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section =
9.1</A>.  If there are too many sources to fit all the
   necessary RR packets into one compound RTCP packet without exceeding
   the maximum transmission unit (MTU) of the network path, then only
   the subset that will fit into one MTU SHOULD be included in each
   interval.  The subsets SHOULD be selected round-robin across multiple
   intervals so that all sources are reported.

   It is RECOMMENDED that translators and mixers combine individual RTCP
   packets from the multiple sources they are forwarding into one
   compound packet whenever feasible in order to amortize the packet
   overhead (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-7">Section 7</A>).  =
An example RTCP compound packet as might
   be produced by a mixer is shown in Fig. 1.  If the overall length of
   a compound packet would exceed the MTU of the network path, it SHOULD
   be segmented into multiple shorter compound packets to be transmitted
   in separate packets of the underlying protocol.  This does not impair
   the RTCP bandwidth estimation because each compound packet represents
   at least one distinct participant.  Note that each of the compound
   packets MUST begin with an SR or RR packet.

   An implementation SHOULD ignore incoming RTCP packets with types
   unknown to it.  Additional RTCP packet types may be registered with
   the Internet Assigned Numbers Authority (IANA) as described in
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-15">Section =
15</A>.

   if encrypted: random 32-bit integer
   |
   |[--------- packet --------][---------- packet ----------][<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref--packet-">-packet-</A>]
   |
   |                receiver            chunk        chunk
   V                reports           item  item   item  item
   --------------------------------------------------------------------
   R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
   --------------------------------------------------------------------
   |                                                                  |
   |&lt;-----------------------  compound packet =
-----------------------&gt;|
   |&lt;--------------------------  UDP packet =
-------------------------&gt;|

   #: SSRC/CSRC identifier

              Figure 1: Example of an RTCP compound packet







<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 23]</SPAN>
<A id=3Dpage-24 href=3D"http://tools.ietf.org/html/rfc3550#page-24" =
name=3Dpage-24><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.2>6.2</A> RTCP =
Transmission Interval</SPAN>

   RTP is designed to allow an application to scale automatically over
   session sizes ranging from a few participants to thousands.  For
   example, in an audio conference the data traffic is inherently self-
   limiting because only one or two people will speak at a time, so with
   multicast distribution the data rate on any given link remains
   relatively constant independent of the number of participants.
   However, the control traffic is not self-limiting.  If the reception
   reports from each participant were sent at a constant rate, the
   control traffic would grow linearly with the number of participants.
   Therefore, the rate must be scaled down by dynamically calculating
   the interval between RTCP packet transmissions.

   For each session, it is assumed that the data traffic is subject to
   an aggregate limit called the "session bandwidth" to be divided among
   the participants.  This bandwidth might be reserved and the limit
   enforced by the network.  If there is no reservation, there may be
   other constraints, depending on the environment, that establish the
   "reasonable" maximum for the session to use, and that would be the
   session bandwidth.  The session bandwidth may be chosen based on some
   cost or a priori knowledge of the available network bandwidth for the
   session.  It is somewhat independent of the media encoding, but the
   encoding choice may be limited by the session bandwidth.  Often, the
   session bandwidth is the sum of the nominal bandwidths of the senders
   expected to be concurrently active.  For teleconference audio, this
   number would typically be one sender's bandwidth.  For layered
   encodings, each layer is a separate RTP session with its own session
   bandwidth parameter.

   The session bandwidth parameter is expected to be supplied by a
   session management application when it invokes a media application,
   but media applications MAY set a default based on the single-sender
   data bandwidth for the encoding selected for the session.  The
   application MAY also enforce bandwidth limits based on multicast
   scope rules or other criteria.  All participants MUST use the same
   value for the session bandwidth so that the same RTCP interval will
   be calculated.

   Bandwidth calculations for control and data traffic include lower-
   layer transport and network protocols (e.g., UDP and IP) since that
   is what the resource reservation system would need to know.  The
   application can also be expected to know which of these protocols are
   in use.  Link level headers are not included in the calculation since
   the packet will be encapsulated with different link level headers as
   it travels.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 24]</SPAN>
<A id=3Dpage-25 href=3D"http://tools.ietf.org/html/rfc3550#page-25" =
name=3Dpage-25><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   The control traffic should be limited to a small and known fraction
   of the session bandwidth: small so that the primary function of the
   transport protocol to carry data is not impaired; known so that the
   control traffic can be included in the bandwidth specification given
   to a resource reservation protocol, and so that each participant can
   independently calculate its share.  The control traffic bandwidth is
   in addition to the session bandwidth for the data traffic.  It is
   RECOMMENDED that the fraction of the session bandwidth added for RTCP
   be fixed at 5%.  It is also RECOMMENDED that 1/4 of the RTCP
   bandwidth be dedicated to participants that are sending data so that
   in sessions with a large number of receivers but a small number of
   senders, newly joining participants will more quickly receive the
   CNAME for the sending sites.  When the proportion of senders is
   greater than 1/4 of the participants, the senders get their
   proportion of the full RTCP bandwidth.  While the values of these and
   other constants in the interval calculation are not critical, all
   participants in the session MUST use the same values so the same
   interval will be calculated.  Therefore, these constants SHOULD be
   fixed for a particular profile.

   A profile MAY specify that the control traffic bandwidth may be a
   separate parameter of the session rather than a strict percentage of
   the session bandwidth.  Using a separate parameter allows rate-
   adaptive applications to set an RTCP bandwidth consistent with a
   "typical" data bandwidth that is lower than the maximum bandwidth
   specified by the session bandwidth parameter.

   The profile MAY further specify that the control traffic bandwidth
   may be divided into two separate session parameters for those
   participants which are active data senders and those which are not;
   let us call the parameters S and R.  Following the recommendation
   that 1/4 of the RTCP bandwidth be dedicated to data senders, the
   RECOMMENDED default values for these two parameters would be 1.25%
   and 3.75%, respectively.  When the proportion of senders is greater
   than S/(S+R) of the participants, the senders get their proportion of
   the sum of these parameters.  Using two parameters allows RTCP
   reception reports to be turned off entirely for a particular session
   by setting the RTCP bandwidth for non-data-senders to zero while
   keeping the RTCP bandwidth for data senders non-zero so that sender
   reports can still be sent for inter-media synchronization.  Turning
   off RTCP reception reports is NOT RECOMMENDED because they are needed
   for the functions listed at the beginning of <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6">Section 6</A>, =
particularly
   reception quality feedback and congestion control.  However, doing so
   may be appropriate for systems operating on unidirectional links or
   for sessions that don't require feedback on the quality of reception
   or liveness of receivers and that have other means to avoid
   congestion.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 25]</SPAN>
<A id=3Dpage-26 href=3D"http://tools.ietf.org/html/rfc3550#page-26" =
name=3Dpage-26><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   The calculated interval between transmissions of compound RTCP
   packets SHOULD also have a lower bound to avoid having bursts of
   packets exceed the allowed bandwidth when the number of participants
   is small and the traffic isn't smoothed according to the law of large
   numbers.  It also keeps the report interval from becoming too small
   during transient outages like a network partition such that
   adaptation is delayed when the partition heals.  At application
   startup, a delay SHOULD be imposed before the first compound RTCP
   packet is sent to allow time for RTCP packets to be received from
   other participants so the report interval will converge to the
   correct value more quickly.  This delay MAY be set to half the
   minimum interval to allow quicker notification that the new
   participant is present.  The RECOMMENDED value for a fixed minimum
   interval is 5 seconds.

   An implementation MAY scale the minimum RTCP interval to a smaller
   value inversely proportional to the session bandwidth parameter with
   the following limitations:

   o  For multicast sessions, only active data senders MAY use the
      reduced minimum value to calculate the interval for transmission
      of compound RTCP packets.

   o  For unicast sessions, the reduced value MAY be used by
      participants that are not active data senders as well, and the
      delay before sending the initial compound RTCP packet MAY be zero.

   o  For all sessions, the fixed minimum SHOULD be used when
      calculating the participant timeout interval (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.5">Section =
6.3.5</A>)
      so that implementations which do not use the reduced value for
      transmitting RTCP packets are not timed out by other participants
      prematurely.

   o  The RECOMMENDED value for the reduced minimum in seconds is 360
      divided by the session bandwidth in kilobits/second.  This minimum
      is smaller than 5 seconds for bandwidths greater than 72 kb/s.

   The algorithm described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3">Section 6.3</A> =
and Appendix A.7 was designed
   to meet the goals outlined in this section.  It calculates the
   interval between sending compound RTCP packets to divide the allowed
   control traffic bandwidth among the participants.  This allows an
   application to provide fast response for small sessions where, for
   example, identification of all participants is important, yet
   automatically adapt to large sessions.  The algorithm incorporates
   the following characteristics:






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 26]</SPAN>
<A id=3Dpage-27 href=3D"http://tools.ietf.org/html/rfc3550#page-27" =
name=3Dpage-27><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  The calculated interval between RTCP packets scales linearly with
      the number of members in the group.  It is this linear factor
      which allows for a constant amount of control traffic when summed
      across all members.

   o  The interval between RTCP packets is varied randomly over the
      range [0.5,1.5] times the calculated interval to avoid unintended
      synchronization of all participants [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-20">20</A>].  The first =
RTCP packet
      sent after joining a session is also delayed by a random variation
      of half the minimum RTCP interval.

   o  A dynamic estimate of the average compound RTCP packet size is
      calculated, including all those packets received and sent, to
      automatically adapt to changes in the amount of control
      information carried.

   o  Since the calculated interval is dependent on the number of
      observed group members, there may be undesirable startup effects
      when a new user joins an existing session, or many users
      simultaneously join a new session.  These new users will initially
      have incorrect estimates of the group membership, and thus their
      RTCP transmission interval will be too short.  This problem can be
      significant if many users join the session simultaneously.  To
      deal with this, an algorithm called "timer reconsideration" is
      employed.  This algorithm implements a simple back-off mechanism
      which causes users to hold back RTCP packet transmission if the
      group sizes are increasing.

   o  When users leave a session, either with a BYE or by timeout, the
      group membership decreases, and thus the calculated interval
      should decrease.  A "reverse reconsideration" algorithm is used to
      allow members to more quickly reduce their intervals in response
      to group membership decreases.

   o  BYE packets are given different treatment than other RTCP packets.
      When a user leaves a group, and wishes to send a BYE packet, it
      may do so before its next scheduled RTCP packet.  However,
      transmission of BYEs follows a back-off algorithm which avoids
      floods of BYE packets should a large number of members
      simultaneously leave the session.

   This algorithm may be used for sessions in which all participants are
   allowed to send.  In that case, the session bandwidth parameter is
   the product of the individual sender's bandwidth times the number of
   participants, and the RTCP bandwidth is 5% of that.

   Details of the algorithm's operation are given in the sections that
   follow.  Appendix A.7 gives an example implementation.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 27]</SPAN>
<A id=3Dpage-28 href=3D"http://tools.ietf.org/html/rfc3550#page-28" =
name=3Dpage-28><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.2.1>6.2.1</A> =
Maintaining the Number of Session Members</SPAN>

   Calculation of the RTCP packet interval depends upon an estimate of
   the number of sites participating in the session.  New sites are
   added to the count when they are heard, and an entry for each SHOULD
   be created in a table indexed by the SSRC or CSRC identifier (see
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section =
8.2</A>) to keep track of them.  New entries MAY be considered
   not valid until multiple packets carrying the new SSRC have been
   received (see Appendix A.1), or until an SDES RTCP packet containing
   a CNAME for that SSRC has been received.  Entries MAY be deleted from
   the table when an RTCP BYE packet with the corresponding SSRC
   identifier is received, except that some straggler data packets might
   arrive after the BYE and cause the entry to be recreated.  Instead,
   the entry SHOULD be marked as having received a BYE and then deleted
   after an appropriate delay.

   A participant MAY mark another site inactive, or delete it if not yet
   valid, if no RTP or RTCP packet has been received for a small number
   of RTCP report intervals (5 is RECOMMENDED).  This provides some
   robustness against packet loss.  All sites must have the same value
   for this multiplier and must calculate roughly the same value for the
   RTCP report interval in order for this timeout to work properly.
   Therefore, this multiplier SHOULD be fixed for a particular profile.

   For sessions with a very large number of participants, it may be
   impractical to maintain a table to store the SSRC identifier and
   state information for all of them.  An implementation MAY use SSRC
   sampling, as described in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-21">21</A>], to reduce =
the storage requirements.
   An implementation MAY use any other algorithm with similar
   performance.  A key requirement is that any algorithm considered
   SHOULD NOT substantially underestimate the group size, although it
   MAY overestimate.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.3>6.3</A> RTCP =
Packet Send and Receive Rules</SPAN>

   The rules for how to send, and what to do when receiving an RTCP
   packet are outlined here.  An implementation that allows operation in
   a multicast environment or a multipoint unicast environment MUST meet
   the requirements in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>. =
 Such an implementation MAY use the
   algorithm defined in this section to meet those requirements, or MAY
   use some other algorithm so long as it provides equivalent or better
   performance.  An implementation which is constrained to two-party
   unicast operation SHOULD still use randomization of the RTCP
   transmission interval to avoid unintended synchronization of multiple
   instances operating in the same environment, but MAY omit the "timer
   reconsideration" and "reverse reconsideration" algorithms in Sections
   6.3.3, 6.3.6 and 6.3.7.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 28]</SPAN>
<A id=3Dpage-29 href=3D"http://tools.ietf.org/html/rfc3550#page-29" =
name=3Dpage-29><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   To execute these rules, a session participant must maintain several
   pieces of state:

   tp: the last time an RTCP packet was transmitted;

   tc: the current time;

   tn: the next scheduled transmission time of an RTCP packet;

   pmembers: the estimated number of session members at the time tn
      was last recomputed;

   members: the most current estimate for the number of session
      members;

   senders: the most current estimate for the number of senders in
      the session;

   rtcp_bw: The target RTCP bandwidth, i.e., the total bandwidth
      that will be used for RTCP packets by all members of this session,
      in octets per second.  This will be a specified fraction of the
      "session bandwidth" parameter supplied to the application at
      startup.

   we_sent: Flag that is true if the application has sent data
      since the 2nd previous RTCP report was transmitted.

   avg_rtcp_size: The average compound RTCP packet size, in octets,
      over all RTCP packets sent and received by this participant.  The
      size includes lower-layer transport and network protocol headers
      (e.g., UDP and IP) as explained in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>.

   initial: Flag that is true if the application has not yet sent
      an RTCP packet.

   Many of these rules make use of the "calculated interval" between
   packet transmissions.  This interval is described in the following
   section.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.1>6.3.1</A> =
Computing the RTCP Transmission Interval</SPAN>

   To maintain scalability, the average interval between packets from a
   session participant should scale with the group size.  This interval
   is called the calculated interval.  It is obtained by combining a
   number of the pieces of state described above.  The calculated
   interval T is then determined as follows:





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 29]</SPAN>
<A id=3Dpage-30 href=3D"http://tools.ietf.org/html/rfc3550#page-30" =
name=3Dpage-30><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   1. If the number of senders is less than or equal to 25% of the
      membership (members), the interval depends on whether the
      participant is a sender or not (based on the value of we_sent).
      If the participant is a sender (we_sent true), the constant C is
      set to the average RTCP packet size (avg_rtcp_size) divided by 25%
      of the RTCP bandwidth (rtcp_bw), and the constant n is set to the
      number of senders.  If we_sent is not true, the constant C is set
      to the average RTCP packet size divided by 75% of the RTCP
      bandwidth.  The constant n is set to the number of receivers
      (members - senders).  If the number of senders is greater than
      25%, senders and receivers are treated together.  The constant C
      is set to the average RTCP packet size divided by the total RTCP
      bandwidth and n is set to the total number of members.  As stated
      in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>, =
an RTP profile MAY specify that the RTCP bandwidth
      may be explicitly defined by two separate parameters (call them S
      and R) for those participants which are senders and those which
      are not.  In that case, the 25% fraction becomes S/(S+R) and the
      75% fraction becomes R/(S+R).  Note that if R is zero, the
      percentage of senders is never greater than S/(S+R), and the
      implementation must avoid division by zero.

   2. If the participant has not yet sent an RTCP packet (the variable
      initial is true), the constant Tmin is set to 2.5 seconds, else it
      is set to 5 seconds.

   3. The deterministic calculated interval Td is set to max(Tmin, n*C).

   4. The calculated interval T is set to a number uniformly distributed
      between 0.5 and 1.5 times the deterministic calculated interval.

   5. The resulting value of T is divided by e-3/2=3D1.21828 to =
compensate
      for the fact that the timer reconsideration algorithm converges to
      a value of the RTCP bandwidth below the intended average.

   This procedure results in an interval which is random, but which, on
   average, gives at least 25% of the RTCP bandwidth to senders and the
   rest to receivers.  If the senders constitute more than one quarter
   of the membership, this procedure splits the bandwidth equally among
   all participants, on average.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.2>6.3.2</A> =
Initialization</SPAN>

   Upon joining the session, the participant initializes tp to 0, tc to
   0, senders to 0, pmembers to 1, members to 1, we_sent to false,
   rtcp_bw to the specified fraction of the session bandwidth, initial
   to true, and avg_rtcp_size to the probable size of the first RTCP
   packet that the application will later construct.  The calculated
   interval T is then computed, and the first packet is scheduled for



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 30]</SPAN>
<A id=3Dpage-31 href=3D"http://tools.ietf.org/html/rfc3550#page-31" =
name=3Dpage-31><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   time tn =3D T.  This means that a transmission timer is set which
   expires at time T.  Note that an application MAY use any desired
   approach for implementing this timer.

   The participant adds its own SSRC to the member table.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.3>6.3.3</A> =
Receiving an RTP or Non-BYE RTCP Packet</SPAN>

   When an RTP or RTCP packet is received from a participant whose SSRC
   is not in the member table, the SSRC is added to the table, and the
   value for members is updated once the participant has been validated
   as described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2.1">Section =
6.2.1</A>.  The same processing occurs for each
   CSRC in a validated RTP packet.

   When an RTP packet is received from a participant whose SSRC is not
   in the sender table, the SSRC is added to the table, and the value
   for senders is updated.

   For each compound RTCP packet received, the value of avg_rtcp_size is
   updated:

      avg_rtcp_size =3D (1/16) * packet_size + (15/16) * avg_rtcp_size

   where packet_size is the size of the RTCP packet just received.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.4>6.3.4</A> =
Receiving an RTCP BYE Packet</SPAN>

   Except as described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.7">Section =
6.3.7</A> for the case when an RTCP BYE is
   to be transmitted, if the received packet is an RTCP BYE packet, the
   SSRC is checked against the member table.  If present, the entry is
   removed from the table, and the value for members is updated.  The
   SSRC is then checked against the sender table.  If present, the entry
   is removed from the table, and the value for senders is updated.

   Furthermore, to make the transmission rate of RTCP packets more
   adaptive to changes in group membership, the following "reverse
   reconsideration" algorithm SHOULD be executed when a BYE packet is
   received that reduces members to a value less than pmembers:

   o  The value for tn is updated according to the following formula:

         tn =3D tc + (members/pmembers) * (tn - tc)

   o  The value for tp is updated according the following formula:

         tp =3D tc - (members/pmembers) * (tc - tp).





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 31]</SPAN>
<A id=3Dpage-32 href=3D"http://tools.ietf.org/html/rfc3550#page-32" =
name=3Dpage-32><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  The next RTCP packet is rescheduled for transmission at time tn,
      which is now earlier.

   o  The value of pmembers is set equal to members.

   This algorithm does not prevent the group size estimate from
   incorrectly dropping to zero for a short time due to premature
   timeouts when most participants of a large session leave at once but
   some remain.  The algorithm does make the estimate return to the
   correct value more rapidly.  This situation is unusual enough and the
   consequences are sufficiently harmless that this problem is deemed
   only a secondary concern.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.5>6.3.5</A> =
Timing Out an SSRC</SPAN>

   At occasional intervals, the participant MUST check to see if any of
   the other participants time out.  To do this, the participant
   computes the deterministic (without the randomization factor)
   calculated interval Td for a receiver, that is, with we_sent false.
   Any other session member who has not sent an RTP or RTCP packet since
   time tc - MTd (M is the timeout multiplier, and defaults to 5) is
   timed out.  This means that its SSRC is removed from the member list,
   and members is updated.  A similar check is performed on the sender
   list.  Any member on the sender list who has not sent an RTP packet
   since time tc - 2T (within the last two RTCP report intervals) is
   removed from the sender list, and senders is updated.

   If any members time out, the reverse reconsideration algorithm
   described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.4">Section =
6.3.4</A> SHOULD be performed.

   The participant MUST perform this check at least once per RTCP
   transmission interval.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.6>6.3.6</A> =
Expiration of Transmission Timer</SPAN>

   When the packet transmission timer expires, the participant performs
   the following operations:

   o  The transmission interval T is computed as described in Section
      6.3.1, including the randomization factor.

   o  If tp + T is less than or equal to tc, an RTCP packet is
      transmitted.  tp is set to tc, then another value for T is
      calculated as in the previous step and tn is set to tc + T.  The
      transmission timer is set to expire again at time tn.  If tp + T
      is greater than tc, tn is set to tp + T.  No RTCP packet is
      transmitted.  The transmission timer is set to expire at time tn.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 32]</SPAN>
<A id=3Dpage-33 href=3D"http://tools.ietf.org/html/rfc3550#page-33" =
name=3Dpage-33><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  pmembers is set to members.

   If an RTCP packet is transmitted, the value of initial is set to
   FALSE.  Furthermore, the value of avg_rtcp_size is updated:

      avg_rtcp_size =3D (1/16) * packet_size + (15/16) * avg_rtcp_size

   where packet_size is the size of the RTCP packet just transmitted.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.7>6.3.7</A> =
Transmitting a BYE Packet</SPAN>

   When a participant wishes to leave a session, a BYE packet is
   transmitted to inform the other participants of the event.  In order
   to avoid a flood of BYE packets when many participants leave the
   system, a participant MUST execute the following algorithm if the
   number of members is more than 50 when the participant chooses to
   leave.  This algorithm usurps the normal role of the members variable
   to count BYE packets instead:

   o  When the participant decides to leave the system, tp is reset to
      tc, the current time, members and pmembers are initialized to 1,
      initial is set to 1, we_sent is set to false, senders is set to 0,
      and avg_rtcp_size is set to the size of the compound BYE packet.
      The calculated interval T is computed.  The BYE packet is then
      scheduled for time tn =3D tc + T.

   o  Every time a BYE packet from another participant is received,
      members is incremented by 1 regardless of whether that participant
      exists in the member table or not, and when SSRC sampling is in
      use, regardless of whether or not the BYE SSRC would be included
      in the sample.  members is NOT incremented when other RTCP packets
      or RTP packets are received, but only for BYE packets.  Similarly,
      avg_rtcp_size is updated only for received BYE packets.  senders
      is NOT updated when RTP packets arrive; it remains 0.

   o  Transmission of the BYE packet then follows the rules for
      transmitting a regular RTCP packet, as above.

   This allows BYE packets to be sent right away, yet controls their
   total bandwidth usage.  In the worst case, this could cause RTCP
   control packets to use twice the bandwidth as normal (10%) -- 5% for
   non-BYE RTCP packets and 5% for BYE.

   A participant that does not want to wait for the above mechanism to
   allow transmission of a BYE packet MAY leave the group without
   sending a BYE at all.  That participant will eventually be timed out
   by the other group members.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 33]</SPAN>
<A id=3Dpage-34 href=3D"http://tools.ietf.org/html/rfc3550#page-34" =
name=3Dpage-34><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   If the group size estimate members is less than 50 when the
   participant decides to leave, the participant MAY send a BYE packet
   immediately.  Alternatively, the participant MAY choose to execute
   the above BYE backoff algorithm.

   In either case, a participant which never sent an RTP or RTCP packet
   MUST NOT send a BYE packet when they leave the group.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.8>6.3.8</A> =
Updating we_sent</SPAN>

   The variable we_sent contains true if the participant has sent an RTP
   packet recently, false otherwise.  This determination is made by
   using the same mechanisms as for managing the set of other
   participants listed in the senders table.  If the participant sends
   an RTP packet when we_sent is false, it adds itself to the sender
   table and sets we_sent to true.  The reverse reconsideration
   algorithm described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.4">Section =
6.3.4</A> SHOULD be performed to possibly
   reduce the delay before sending an SR packet.  Every time another RTP
   packet is sent, the time of transmission of that packet is maintained
   in the table.  The normal sender timeout algorithm is then applied to
   the participant -- if an RTP packet has not been transmitted since
   time tc - 2T, the participant removes itself from the sender table,
   decrements the sender count, and sets we_sent to false.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.3.9>6.3.9</A> =
Allocation of Source Description Bandwidth</SPAN>

   This specification defines several source description (SDES) items in
   addition to the mandatory CNAME item, such as NAME (personal name)
   and EMAIL (email address).  It also provides a means to define new
   application-specific RTCP packet types.  Applications should exercise
   caution in allocating control bandwidth to this additional
   information because it will slow down the rate at which reception
   reports and CNAME are sent, thus impairing the performance of the
   protocol.  It is RECOMMENDED that no more than 20% of the RTCP
   bandwidth allocated to a single participant be used to carry the
   additional information.  Furthermore, it is not intended that all
   SDES items will be included in every application.  Those that are
   included SHOULD be assigned a fraction of the bandwidth according to
   their utility.  Rather than estimate these fractions dynamically, it
   is recommended that the percentages be translated statically into
   report interval counts based on the typical length of an item.

   For example, an application may be designed to send only CNAME, NAME
   and EMAIL and not any others.  NAME might be given much higher
   priority than EMAIL because the NAME would be displayed continuously
   in the application's user interface, whereas EMAIL would be displayed
   only when requested.  At every RTCP interval, an RR packet and an
   SDES packet with the CNAME item would be sent.  For a small session



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 34]</SPAN>
<A id=3Dpage-35 href=3D"http://tools.ietf.org/html/rfc3550#page-35" =
name=3Dpage-35><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   operating at the minimum interval, that would be every 5 seconds on
   the average.  Every third interval (15 seconds), one extra item would
   be included in the SDES packet.  Seven out of eight times this would
   be the NAME item, and every eighth time (2 minutes) it would be the
   EMAIL item.

   When multiple applications operate in concert using cross-application
   binding through a common CNAME for each participant, for example in a
   multimedia conference composed of an RTP session for each medium, the
   additional SDES information MAY be sent in only one RTP session.  The
   other sessions would carry only the CNAME item.  In particular, this
   approach should be applied to the multiple sessions of a layered
   encoding scheme (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-2.4">Section =
2.4</A>).

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.4>6.4</A> Sender =
and Receiver Reports</SPAN>

   RTP receivers provide reception quality feedback using RTCP report
   packets which may take one of two forms depending upon whether or not
   the receiver is also a sender.  The only difference between the
   sender report (SR) and receiver report (RR) forms, besides the packet
   type code, is that the sender report includes a 20-byte sender
   information section for use by active senders.  The SR is issued if a
   site has sent any data packets during the interval since issuing the
   last report or the previous one, otherwise the RR is issued.

   Both the SR and RR forms include zero or more reception report
   blocks, one for each of the synchronization sources from which this
   receiver has received RTP data packets since the last report.
   Reports are not issued for contributing sources listed in the CSRC
   list.  Each reception report block provides statistics about the data
   received from the particular source indicated in that block.  Since a
   maximum of 31 reception report blocks will fit in an SR or RR packet,
   additional RR packets SHOULD be stacked after the initial SR or RR
   packet as needed to contain the reception reports for all sources
   heard during the interval since the last report.  If there are too
   many sources to fit all the necessary RR packets into one compound
   RTCP packet without exceeding the MTU of the network path, then only
   the subset that will fit into one MTU SHOULD be included in each
   interval.  The subsets SHOULD be selected round-robin across multiple
   intervals so that all sources are reported.

   The next sections define the formats of the two reports, how they may
   be extended in a profile-specific manner if an application requires
   additional feedback information, and how the reports may be used.
   Details of reception reporting by translators and mixers is given in
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-7">Section =
7</A>.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 35]</SPAN>
<A id=3Dpage-36 href=3D"http://tools.ietf.org/html/rfc3550#page-36" =
name=3Dpage-36><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.4.1>6.4.1</A> SR: =
Sender Report RTCP Packet</SPAN>

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=3D2|P|    RC   |   PT=3DSR=3D200   |             length        =
    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         SSRC of sender                        |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
sender |              NTP timestamp, most significant word             |
info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |             NTP timestamp, least significant word             |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         RTP timestamp                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     sender's packet count                     |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      sender's octet count                     |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The sender report packet consists of three sections, possibly
   followed by a fourth profile-specific extension section if defined.
   The first section, the header, is 8 octets long.  The fields have the
   following meaning:

   version (V): 2 bits
      Identifies the version of RTP, which is the same in RTCP packets
      as in RTP data packets.  The version defined by this specification
      is two (2).




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 36]</SPAN>
<A id=3Dpage-37 href=3D"http://tools.ietf.org/html/rfc3550#page-37" =
name=3Dpage-37><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   padding (P): 1 bit
      If the padding bit is set, this individual RTCP packet contains
      some additional padding octets at the end which are not part of
      the control information but are included in the length field.  The
      last octet of the padding is a count of how many padding octets
      should be ignored, including itself (it will be a multiple of
      four).  Padding may be needed by some encryption algorithms with
      fixed block sizes.  In a compound RTCP packet, padding is only
      required on one individual packet because the compound packet is
      encrypted as a whole for the method in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9.1">Section 9.1</A>. =
 Thus, padding
      MUST only be added to the last individual packet, and if padding
      is added to that packet, the padding bit MUST be set only on that
      packet.  This convention aids the header validity checks described
      in Appendix A.2 and allows detection of packets from some early
      implementations that incorrectly set the padding bit on the first
      individual packet and add padding to the last individual packet.

   reception report count (RC): 5 bits
      The number of reception report blocks contained in this packet.  A
      value of zero is valid.

   packet type (PT): 8 bits
      Contains the constant 200 to identify this as an RTCP SR packet.

   length: 16 bits
      The length of this RTCP packet in 32-bit words minus one,
      including the header and any padding.  (The offset of one makes
      zero a valid length and avoids a possible infinite loop in
      scanning a compound RTCP packet, while counting 32-bit words
      avoids a validity check for a multiple of 4.)

   SSRC: 32 bits
      The synchronization source identifier for the originator of this
      SR packet.

   The second section, the sender information, is 20 octets long and is
   present in every sender report packet.  It summarizes the data
   transmissions from this sender.  The fields have the following
   meaning:

   NTP timestamp: 64 bits
      Indicates the wallclock time (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-4">Section 4</A>) =
when this report was
      sent so that it may be used in combination with timestamps
      returned in reception reports from other receivers to measure
      round-trip propagation to those receivers.  Receivers should
      expect that the measurement accuracy of the timestamp may be
      limited to far less than the resolution of the NTP timestamp.  The
      measurement uncertainty of the timestamp is not indicated as it



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 37]</SPAN>
<A id=3Dpage-38 href=3D"http://tools.ietf.org/html/rfc3550#page-38" =
name=3Dpage-38><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      may not be known.  On a system that has no notion of wallclock
      time but does have some system-specific clock such as "system
      uptime", a sender MAY use that clock as a reference to calculate
      relative NTP timestamps.  It is important to choose a commonly
      used clock so that if separate implementations are used to produce
      the individual streams of a multimedia session, all
      implementations will use the same clock.  Until the year 2036,
      relative and absolute timestamps will differ in the high bit so
      (invalid) comparisons will show a large difference; by then one
      hopes relative timestamps will no longer be needed.  A sender that
      has no notion of wallclock or elapsed time MAY set the NTP
      timestamp to zero.

   RTP timestamp: 32 bits
      Corresponds to the same time as the NTP timestamp (above), but in
      the same units and with the same random offset as the RTP
      timestamps in data packets.  This correspondence may be used for
      intra- and inter-media synchronization for sources whose NTP
      timestamps are synchronized, and may be used by media-independent
      receivers to estimate the nominal RTP clock frequency.  Note that
      in most cases this timestamp will not be equal to the RTP
      timestamp in any adjacent data packet.  Rather, it MUST be
      calculated from the corresponding NTP timestamp using the
      relationship between the RTP timestamp counter and real time as
      maintained by periodically checking the wallclock time at a
      sampling instant.

   sender's packet count: 32 bits
      The total number of RTP data packets transmitted by the sender
      since starting transmission up until the time this SR packet was
      generated.  The count SHOULD be reset if the sender changes its
      SSRC identifier.

   sender's octet count: 32 bits
      The total number of payload octets (i.e., not including header or
      padding) transmitted in RTP data packets by the sender since
      starting transmission up until the time this SR packet was
      generated.  The count SHOULD be reset if the sender changes its
      SSRC identifier.  This field can be used to estimate the average
      payload data rate.

   The third section contains zero or more reception report blocks
   depending on the number of other sources heard by this sender since
   the last report.  Each reception report block conveys statistics on
   the reception of RTP packets from a single synchronization source.
   Receivers SHOULD NOT carry over statistics when a source changes its
   SSRC identifier due to a collision.  These statistics are:




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 38]</SPAN>
<A id=3Dpage-39 href=3D"http://tools.ietf.org/html/rfc3550#page-39" =
name=3Dpage-39><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   SSRC_n (source identifier): 32 bits
      The SSRC identifier of the source to which the information in this
      reception report block pertains.

   fraction lost: 8 bits
      The fraction of RTP data packets from source SSRC_n lost since the
      previous SR or RR packet was sent, expressed as a fixed point
      number with the binary point at the left edge of the field.  (That
      is equivalent to taking the integer part after multiplying the
      loss fraction by 256.)  This fraction is defined to be the number
      of packets lost divided by the number of packets expected, as
      defined in the next paragraph.  An implementation is shown in
      Appendix A.3.  If the loss is negative due to duplicates, the
      fraction lost is set to zero.  Note that a receiver cannot tell
      whether any packets were lost after the last one received, and
      that there will be no reception report block issued for a source
      if all packets from that source sent during the last reporting
      interval have been lost.

   cumulative number of packets lost: 24 bits
      The total number of RTP data packets from source SSRC_n that have
      been lost since the beginning of reception.  This number is
      defined to be the number of packets expected less the number of
      packets actually received, where the number of packets received
      includes any which are late or duplicates.  Thus, packets that
      arrive late are not counted as lost, and the loss may be negative
      if there are duplicates.  The number of packets expected is
      defined to be the extended last sequence number received, as
      defined next, less the initial sequence number received.  This may
      be calculated as shown in Appendix A.3.

   extended highest sequence number received: 32 bits
      The low 16 bits contain the highest sequence number received in an
      RTP data packet from source SSRC_n, and the most significant 16
      bits extend that sequence number with the corresponding count of
      sequence number cycles, which may be maintained according to the
      algorithm in Appendix A.1.  Note that different receivers within
      the same session will generate different extensions to the
      sequence number if their start times differ significantly.

   interarrival jitter: 32 bits
      An estimate of the statistical variance of the RTP data packet
      interarrival time, measured in timestamp units and expressed as an
      unsigned integer.  The interarrival jitter J is defined to be the
      mean deviation (smoothed absolute value) of the difference D in
      packet spacing at the receiver compared to the sender for a pair
      of packets.  As shown in the equation below, this is equivalent to
      the difference in the "relative transit time" for the two packets;



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 39]</SPAN>
<A id=3Dpage-40 href=3D"http://tools.ietf.org/html/rfc3550#page-40" =
name=3Dpage-40><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      the relative transit time is the difference between a packet's RTP
      timestamp and the receiver's clock at the time of arrival,
      measured in the same units.

      If Si is the RTP timestamp from packet i, and Ri is the time of
      arrival in RTP timestamp units for packet i, then for two packets
      i and j, D may be expressed as

         D(i,j) =3D (Rj - Ri) - (Sj - Si) =3D (Rj - Sj) - (Ri - Si)

      The interarrival jitter SHOULD be calculated continuously as each
      data packet i is received from source SSRC_n, using this
      difference D for that packet and the previous packet i-1 in order
      of arrival (not necessarily in sequence), according to the formula

         J(i) =3D J(i-1) + (|D(i-1,i)| - J(i-1))/16

      Whenever a reception report is issued, the current value of J is
      sampled.

      The jitter calculation MUST conform to the formula specified here
      in order to allow profile-independent monitors to make valid
      interpretations of reports coming from different implementations.
      This algorithm is the optimal first-order estimator and the gain
      parameter 1/16 gives a good noise reduction ratio while
      maintaining a reasonable rate of convergence [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-22">22</A>].  A sample
      implementation is shown in Appendix A.8.  See <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.4">Section =
6.4.4</A> for a
      discussion of the effects of varying packet duration and delay
      before transmission.

   last SR timestamp (LSR): 32 bits
      The middle 32 bits out of 64 in the NTP timestamp (as explained in
      <A href=3D"http://tools.ietf.org/html/rfc3550#section-4">Section =
4</A>) received as part of the most recent RTCP sender report
      (SR) packet from source SSRC_n.  If no SR has been received yet,
      the field is set to zero.

   delay since last SR (DLSR): 32 bits
      The delay, expressed in units of 1/65536 seconds, between
      receiving the last SR packet from source SSRC_n and sending this
      reception report block.  If no SR packet has been received yet
      from SSRC_n, the DLSR field is set to zero.

      Let SSRC_r denote the receiver issuing this receiver report.
      Source SSRC_n can compute the round-trip propagation delay to
      SSRC_r by recording the time A when this reception report block is
      received.  It calculates the total round-trip time A-LSR using the
      last SR timestamp (LSR) field, and then subtracting this field to
      leave the round-trip propagation delay as (A - LSR - DLSR).  This



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 40]</SPAN>
<A id=3Dpage-41 href=3D"http://tools.ietf.org/html/rfc3550#page-41" =
name=3Dpage-41><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      is illustrated in Fig. 2.  Times are shown in both a hexadecimal
      representation of the 32-bit fields and the equivalent floating-
      point decimal representation.  Colons indicate a 32-bit field
      divided into a 16-bit integer part and 16-bit fraction part.

      This may be used as an approximate measure of distance to cluster
      receivers, although some links have very asymmetric delays.

   [10 Nov 1995 11:33:25.125 UTC]       [10 Nov 1995 11:33:36.5 UTC]
   n                 SR(n)              A=3Db710:8000 (46864.500 s)
   ----------------------------------------------------------------&gt;
                      v                 ^
   ntp_sec =3D0xb44db705 v               ^ dlsr=3D0x0005:4000 (    =
5.250s)
   ntp_frac=3D0x20000000  v             ^  lsr =3D0xb705:2000 =
(46853.125s)
     (3024992005.125 s)  v           ^
   r                      v         ^ RR(n)
   ----------------------------------------------------------------&gt;
                          |&lt;-DLSR-&gt;|
                           (5.250 s)

   A     0xb710:8000 (46864.500 s)
   DLSR -0x0005:4000 (    5.250 s)
   LSR  -0xb705:2000 (46853.125 s)
   -------------------------------
   delay 0x0006:2000 (    6.125 s)

           Figure 2: Example for round-trip time computation
























<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 41]</SPAN>
<A id=3Dpage-42 href=3D"http://tools.ietf.org/html/rfc3550#page-42" =
name=3Dpage-42><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.4.2>6.4.2</A> RR: =
Receiver Report RTCP Packet</SPAN>

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=3D2|P|    RC   |   PT=3DRR=3D201   |             length        =
    |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                     SSRC of packet sender                     |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
report |                 SSRC_1 (SSRC of first source)                 |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  1    | fraction lost |       cumulative number of packets lost       |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |           extended highest sequence number received           |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                      interarrival jitter                      |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                         last SR (LSR)                         |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                   delay since last SR (DLSR)                  |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
report |                 SSRC_2 (SSRC of second source)                |
block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  2    :                               ...                             :
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
       |                  profile-specific extensions                  |
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The format of the receiver report (RR) packet is the same as that of
   the SR packet except that the packet type field contains the constant
   201 and the five words of sender information are omitted (these are
   the NTP and RTP timestamps and sender's packet and octet counts).
   The remaining fields have the same meaning as for the SR packet.

   An empty RR packet (RC =3D 0) MUST be put at the head of a compound
   RTCP packet when there is no data transmission or reception to
   report.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.4.3>6.4.3</A> =
Extending the Sender and Receiver Reports</SPAN>

   A profile SHOULD define profile-specific extensions to the sender
   report and receiver report if there is additional information that
   needs to be reported regularly about the sender or receivers.  This
   method SHOULD be used in preference to defining another RTCP packet
   type because it requires less overhead:

   o  fewer octets in the packet (no RTCP header or SSRC field);




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 42]</SPAN>
<A id=3Dpage-43 href=3D"http://tools.ietf.org/html/rfc3550#page-43" =
name=3Dpage-43><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  simpler and faster parsing because applications running under that
      profile would be programmed to always expect the extension fields
      in the directly accessible location after the reception reports.

   The extension is a fourth section in the sender- or receiver-report
   packet which comes at the end after the reception report blocks, if
   any.  If additional sender information is required, then for sender
   reports it would be included first in the extension section, but for
   receiver reports it would not be present.  If information about
   receivers is to be included, that data SHOULD be structured as an
   array of blocks parallel to the existing array of reception report
   blocks; that is, the number of blocks would be indicated by the RC
   field.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.4.4>6.4.4</A> =
Analyzing Sender and Receiver Reports</SPAN>

   It is expected that reception quality feedback will be useful not
   only for the sender but also for other receivers and third-party
   monitors.  The sender may modify its transmissions based on the
   feedback; receivers can determine whether problems are local,
   regional or global; network managers may use profile-independent
   monitors that receive only the RTCP packets and not the corresponding
   RTP data packets to evaluate the performance of their networks for
   multicast distribution.

   Cumulative counts are used in both the sender information and
   receiver report blocks so that differences may be calculated between
   any two reports to make measurements over both short and long time
   periods, and to provide resilience against the loss of a report.  The
   difference between the last two reports received can be used to
   estimate the recent quality of the distribution.  The NTP timestamp
   is included so that rates may be calculated from these differences
   over the interval between two reports.  Since that timestamp is
   independent of the clock rate for the data encoding, it is possible
   to implement encoding- and profile-independent quality monitors.

   An example calculation is the packet loss rate over the interval
   between two reception reports.  The difference in the cumulative
   number of packets lost gives the number lost during that interval.
   The difference in the extended last sequence numbers received gives
   the number of packets expected during the interval.  The ratio of
   these two is the packet loss fraction over the interval.  This ratio
   should equal the fraction lost field if the two reports are
   consecutive, but otherwise it may not.  The loss rate per second can
   be obtained by dividing the loss fraction by the difference in NTP
   timestamps, expressed in seconds.  The number of packets received is
   the number of packets expected minus the number lost.  The number of




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 43]</SPAN>
<A id=3Dpage-44 href=3D"http://tools.ietf.org/html/rfc3550#page-44" =
name=3Dpage-44><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   packets expected may also be used to judge the statistical validity
   of any loss estimates.  For example, 1 out of 5 packets lost has a
   lower significance than 200 out of 1000.

   From the sender information, a third-party monitor can calculate the
   average payload data rate and the average packet rate over an
   interval without receiving the data.  Taking the ratio of the two
   gives the average payload size.  If it can be assumed that packet
   loss is independent of packet size, then the number of packets
   received by a particular receiver times the average payload size (or
   the corresponding packet size) gives the apparent throughput
   available to that receiver.

   In addition to the cumulative counts which allow long-term packet
   loss measurements using differences between reports, the fraction
   lost field provides a short-term measurement from a single report.
   This becomes more important as the size of a session scales up enough
   that reception state information might not be kept for all receivers
   or the interval between reports becomes long enough that only one
   report might have been received from a particular receiver.

   The interarrival jitter field provides a second short-term measure of
   network congestion.  Packet loss tracks persistent congestion while
   the jitter measure tracks transient congestion.  The jitter measure
   may indicate congestion before it leads to packet loss.  The
   interarrival jitter field is only a snapshot of the jitter at the
   time of a report and is not intended to be taken quantitatively.
   Rather, it is intended for comparison across a number of reports from
   one receiver over time or from multiple receivers, e.g., within a
   single network, at the same time.  To allow comparison across
   receivers, it is important the the jitter be calculated according to
   the same formula by all receivers.

   Because the jitter calculation is based on the RTP timestamp which
   represents the instant when the first data in the packet was sampled,
   any variation in the delay between that sampling instant and the time
   the packet is transmitted will affect the resulting jitter that is
   calculated.  Such a variation in delay would occur for audio packets
   of varying duration.  It will also occur for video encodings because
   the timestamp is the same for all the packets of one frame but those
   packets are not all transmitted at the same time.  The variation in
   delay until transmission does reduce the accuracy of the jitter
   calculation as a measure of the behavior of the network by itself,
   but it is appropriate to include considering that the receiver buffer
   must accommodate it.  When the jitter calculation is used as a
   comparative measure, the (constant) component due to variation in
   delay until transmission subtracts out so that a change in the




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 44]</SPAN>
<A id=3Dpage-45 href=3D"http://tools.ietf.org/html/rfc3550#page-45" =
name=3Dpage-45><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   network jitter component can then be observed unless it is relatively
   small.  If the change is small, then it is likely to be
   inconsequential.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.5>6.5</A> SDES: =
Source Description RTCP Packet</SPAN>

        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
header |V=3D2|P|    SC   |  PT=3DSDES=3D202  |             length        =
    |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
chunk  |                          SSRC/CSRC_1                          |
  1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
chunk  |                          SSRC/CSRC_2                          |
  2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
       |                           SDES items                          |
       |                              ...                              |
       =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+

   The SDES packet is a three-level structure composed of a header and
   zero or more chunks, each of which is composed of items describing
   the source identified in that chunk.  The items are described
   individually in subsequent sections.

   version (V), padding (P), length:
      As described for the SR packet (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.1">Section =
6.4.1</A>).

   packet type (PT): 8 bits
      Contains the constant 202 to identify this as an RTCP SDES packet.

   source count (SC): 5 bits
      The number of SSRC/CSRC chunks contained in this SDES packet.  A
      value of zero is valid but useless.

   Each chunk consists of an SSRC/CSRC identifier followed by a list of
   zero or more items, which carry information about the SSRC/CSRC.
   Each chunk starts on a 32-bit boundary.  Each item consists of an 8-
   bit type field, an 8-bit octet count describing the length of the
   text (thus, not including this two-octet header), and the text
   itself.  Note that the text can be no longer than 255 octets, but
   this is consistent with the need to limit RTCP bandwidth consumption.







<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 45]</SPAN>
<A id=3Dpage-46 href=3D"http://tools.ietf.org/html/rfc3550#page-46" =
name=3Dpage-46><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   The text is encoded according to the UTF-8 encoding specified in <A =
href=3D"http://tools.ietf.org/html/rfc2279">RFC</A>
   <A href=3D"http://tools.ietf.org/html/rfc2279">2279</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-5">5</A>].  US-ASCII is a =
subset of this encoding and requires no
   additional encoding.  The presence of multi-octet encodings is
   indicated by setting the most significant bit of a character to a
   value of one.

   Items are contiguous, i.e., items are not individually padded to a
   32-bit boundary.  Text is not null terminated because some multi-
   octet encodings include null octets.  The list of items in each chunk
   MUST be terminated by one or more null octets, the first of which is
   interpreted as an item type of zero to denote the end of the list.
   No length octet follows the null item type octet, but additional null
   octets MUST be included if needed to pad until the next 32-bit
   boundary.  Note that this padding is separate from that indicated by
   the P bit in the RTCP header.  A chunk with zero items (four null
   octets) is valid but useless.

   End systems send one SDES packet containing their own source
   identifier (the same as the SSRC in the fixed RTP header).  A mixer
   sends one SDES packet containing a chunk for each contributing source
   from which it is receiving SDES information, or multiple complete
   SDES packets in the format above if there are more than 31 such
   sources (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-7">Section 7</A>).

   The SDES items currently defined are described in the next sections.
   Only the CNAME item is mandatory.  Some items shown here may be
   useful only for particular profiles, but the item types are all
   assigned from one common space to promote shared use and to simplify
   profile-independent applications.  Additional items may be defined in
   a profile by registering the type numbers with IANA as described in
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-15">Section =
15</A>.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.1>6.5.1</A> =
CNAME: Canonical End-Point Identifier SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    CNAME=3D1    |     length    | user and domain name        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The CNAME identifier has the following properties:

   o  Because the randomly allocated SSRC identifier may change if a
      conflict is discovered or if a program is restarted, the CNAME
      item MUST be included to provide the binding from the SSRC
      identifier to an identifier for the source (sender or receiver)
      that remains constant.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 46]</SPAN>
<A id=3Dpage-47 href=3D"http://tools.ietf.org/html/rfc3550#page-47" =
name=3Dpage-47><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  Like the SSRC identifier, the CNAME identifier SHOULD also be
      unique among all participants within one RTP session.

   o  To provide a binding across multiple media tools used by one
      participant in a set of related RTP sessions, the CNAME SHOULD be
      fixed for that participant.

   o  To facilitate third-party monitoring, the CNAME SHOULD be suitable
      for either a program or a person to locate the source.

   Therefore, the CNAME SHOULD be derived algorithmically and not
   entered manually, when possible.  To meet these requirements, the
   following format SHOULD be used unless a profile specifies an
   alternate syntax or semantics.  The CNAME item SHOULD have the format
   "user@host", or "host" if a user name is not available as on single-
   user systems.  For both formats, "host" is either the fully qualified
   domain name of the host from which the real-time data originates,
   formatted according to the rules specified in <A =
href=3D"http://tools.ietf.org/html/rfc1034">RFC 1034</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-6">6</A>], <A =
href=3D"http://tools.ietf.org/html/rfc1035">RFC 1035</A>
   [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-7">7</A>] and <A =
href=3D"http://tools.ietf.org/html/rfc1123#section-2.1">Section&nbsp;2.1 =
of RFC 1123</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-8">8</A>]; or the =
standard ASCII
   representation of the host's numeric address on the interface used
   for the RTP communication.  For example, the standard ASCII
   representation of an IP Version 4 address is "dotted decimal", also
   known as dotted quad, and for IP Version 6, addresses are textually
   represented as groups of hexadecimal digits separated by colons (with
   variations as detailed in <A =
href=3D"http://tools.ietf.org/html/rfc3513">RFC 3513</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-23">23</A>]).  Other =
address types are
   expected to have ASCII representations that are mutually unique.  The
   fully qualified domain name is more convenient for a human observer
   and may avoid the need to send a NAME item in addition, but it may be
   difficult or impossible to obtain reliably in some operating
   environments.  Applications that may be run in such environments
   SHOULD use the ASCII representation of the address instead.

   Examples are "doe@sleepy.example.com", "doe@192.0.2.89" or
   "doe@2201:056D::112E:144A:1E24" for a multi-user system.  On a system
   with no user name, examples would be "sleepy.example.com",
   "192.0.2.89" or "2201:056D::112E:144A:1E24".

   The user name SHOULD be in a form that a program such as "finger" or
   "talk" could use, i.e., it typically is the login name rather than
   the personal name.  The host name is not necessarily identical to the
   one in the participant's electronic mail address.

   This syntax will not provide unique identifiers for each source if an
   application permits a user to generate multiple sources from one
   host.  Such an application would have to rely on the SSRC to further
   identify the source, or the profile for that application would have
   to specify additional syntax for the CNAME identifier.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 47]</SPAN>
<A id=3Dpage-48 href=3D"http://tools.ietf.org/html/rfc3550#page-48" =
name=3Dpage-48><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   If each application creates its CNAME independently, the resulting
   CNAMEs may not be identical as would be required to provide a binding
   across multiple media tools belonging to one participant in a set of
   related RTP sessions.  If cross-media binding is required, it may be
   necessary for the CNAME of each tool to be externally configured with
   the same value by a coordination tool.

   Application writers should be aware that private network address
   assignments such as the Net-10 assignment proposed in <A =
href=3D"http://tools.ietf.org/html/rfc1918">RFC 1918</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-24">24</A>]
   may create network addresses that are not globally unique.  This
   would lead to non-unique CNAMEs if hosts with private addresses and
   no direct IP connectivity to the public Internet have their RTP
   packets forwarded to the public Internet through an RTP-level
   translator.  (See also <A =
href=3D"http://tools.ietf.org/html/rfc1627">RFC 1627</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-25">25</A>].)  To handle =
this case,
   applications MAY provide a means to configure a unique CNAME, but the
   burden is on the translator to translate CNAMEs from private
   addresses to public addresses if necessary to keep private addresses
   from being exposed.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.2>6.5.2</A> NAME: =
User Name SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NAME=3D2    |     length    | common name of source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   This is the real name used to describe the source, e.g., "John Doe,
   Bit Recycler".  It may be in any form desired by the user.  For
   applications such as conferencing, this form of name may be the most
   desirable for display in participant lists, and therefore might be
   sent most frequently of those items other than CNAME.  Profiles MAY
   establish such priorities.  The NAME value is expected to remain
   constant at least for the duration of a session.  It SHOULD NOT be
   relied upon to be unique among all participants in the session.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.3>6.5.3</A> =
EMAIL: Electronic Mail Address SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    EMAIL=3D3    |     length    | email address of source     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The email address is formatted according to <A =
href=3D"http://tools.ietf.org/html/rfc2822">RFC 2822</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-9">9</A>], for
   example, "John.Doe@example.com".  The EMAIL value is expected to
   remain constant for the duration of a session.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 48]</SPAN>
<A id=3Dpage-49 href=3D"http://tools.ietf.org/html/rfc3550#page-49" =
name=3Dpage-49><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.4>6.5.4</A> =
PHONE: Phone Number SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    PHONE=3D4    |     length    | phone number of source      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The phone number SHOULD be formatted with the plus sign replacing the
   international access code.  For example, "+1 908 555 1212" for a
   number in the United States.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.5>6.5.5</A> LOC: =
Geographic User Location SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     LOC=3D5     |     length    | geographic location of site ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   Depending on the application, different degrees of detail are
   appropriate for this item.  For conference applications, a string
   like "Murray Hill, New Jersey" may be sufficient, while, for an
   active badge system, strings like "Room 2A244, AT&amp;T BL MH" might =
be
   appropriate.  The degree of detail is left to the implementation
   and/or user, but format and content MAY be prescribed by a profile.
   The LOC value is expected to remain constant for the duration of a
   session, except for mobile hosts.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.6>6.5.6</A> TOOL: =
Application or Tool Name SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     TOOL=3D6    |     length    |name/version of source appl. ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   A string giving the name and possibly version of the application
   generating the stream, e.g., "videotool 1.2".  This information may
   be useful for debugging purposes and is similar to the Mailer or
   Mail-System-Version SMTP headers.  The TOOL value is expected to
   remain constant for the duration of the session.









<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 49]</SPAN>
<A id=3Dpage-50 href=3D"http://tools.ietf.org/html/rfc3550#page-50" =
name=3Dpage-50><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.7>6.5.7</A> NOTE: =
Notice/Status SDES Item</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     NOTE=3D7    |     length    | note about the source       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The following semantics are suggested for this item, but these or
   other semantics MAY be explicitly defined by a profile.  The NOTE
   item is intended for transient messages describing the current state
   of the source, e.g., "on the phone, can't talk".  Or, during a
   seminar, this item might be used to convey the title of the talk.  It
   should be used only to carry exceptional information and SHOULD NOT
   be included routinely by all participants because this would slow
   down the rate at which reception reports and CNAME are sent, thus
   impairing the performance of the protocol.  In particular, it SHOULD
   NOT be included as an item in a user's configuration file nor
   automatically generated as in a quote-of-the-day.

   Since the NOTE item may be important to display while it is active,
   the rate at which other non-CNAME items such as NAME are transmitted
   might be reduced so that the NOTE item can take that part of the RTCP
   bandwidth.  When the transient message becomes inactive, the NOTE
   item SHOULD continue to be transmitted a few times at the same
   repetition rate but with a string of length zero to signal the
   receivers.  However, receivers SHOULD also consider the NOTE item
   inactive if it is not received for a small multiple of the repetition
   rate, or perhaps 20-30 RTCP intervals.

<SPAN class=3Dheader level=3D"4"><A name=3Dsection-6.5.8>6.5.8</A> PRIV: =
Private Extensions SDES Item</SPAN>

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |     PRIV=3D8    |     length    | prefix length |prefix string...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...             |                  value string               ...
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   This item is used to define experimental or application-specific SDES
   extensions.  The item contains a prefix consisting of a length-string
   pair, followed by the value string filling the remainder of the item
   and carrying the desired information.  The prefix length field is 8
   bits long.  The prefix string is a name chosen by the person defining
   the PRIV item to be unique with respect to other PRIV items this
   application might receive.  The application creator might choose to
   use the application name plus an additional subtype identification if



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 50]</SPAN>
<A id=3Dpage-51 href=3D"http://tools.ietf.org/html/rfc3550#page-51" =
name=3Dpage-51><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   needed.  Alternatively, it is RECOMMENDED that others choose a name
   based on the entity they represent, then coordinate the use of the
   name within that entity.

   Note that the prefix consumes some space within the item's total
   length of 255 octets, so the prefix should be kept as short as
   possible.  This facility and the constrained RTCP bandwidth SHOULD
   NOT be overloaded; it is not intended to satisfy all the control
   communication requirements of all applications.

   SDES PRIV prefixes will not be registered by IANA.  If some form of
   the PRIV item proves to be of general utility, it SHOULD instead be
   assigned a regular SDES item type registered with IANA so that no
   prefix is required.  This simplifies use and increases transmission
   efficiency.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.6>6.6</A> BYE: =
Goodbye RTCP Packet</SPAN>

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |V=3D2|P|    SC   |   PT=3DBYE=3D203  |             length         =
   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                           SSRC/CSRC                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                              ...                              :
      =
+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=
=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+=3D+
(opt) |     length    |               reason for leaving            ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The BYE packet indicates that one or more sources are no longer
   active.

   version (V), padding (P), length:
      As described for the SR packet (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.1">Section =
6.4.1</A>).

   packet type (PT): 8 bits
      Contains the constant 203 to identify this as an RTCP BYE packet.

   source count (SC): 5 bits
      The number of SSRC/CSRC identifiers included in this BYE packet.
      A count value of zero is valid, but useless.

   The rules for when a BYE packet should be sent are specified in
   Sections 6.3.7 and 8.2.






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 51]</SPAN>
<A id=3Dpage-52 href=3D"http://tools.ietf.org/html/rfc3550#page-52" =
name=3Dpage-52><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   If a BYE packet is received by a mixer, the mixer SHOULD forward the
   BYE packet with the SSRC/CSRC identifier(s) unchanged.  If a mixer
   shuts down, it SHOULD send a BYE packet listing all contributing
   sources it handles, as well as its own SSRC identifier.  Optionally,
   the BYE packet MAY include an 8-bit octet count followed by that many
   octets of text indicating the reason for leaving, e.g., "camera
   malfunction" or "RTP loop detected".  The string has the same
   encoding as that described for SDES.  If the string fills the packet
   to the next 32-bit boundary, the string is not null terminated.  If
   not, the BYE packet MUST be padded with null octets to the next 32-
   bit boundary.  This padding is separate from that indicated by the P
   bit in the RTCP header.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-6.7>6.7</A> APP: =
Application-Defined RTCP Packet</SPAN>

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |V=3D2|P| subtype |   PT=3DAPP=3D204  |             length            =
|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           SSRC/CSRC                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          name (ASCII)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   application-dependent data                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   The APP packet is intended for experimental use as new applications
   and new features are developed, without requiring packet type value
   registration.  APP packets with unrecognized names SHOULD be ignored.
   After testing and if wider use is justified, it is RECOMMENDED that
   each APP packet be redefined without the subtype and name fields and
   registered with IANA using an RTCP packet type.

   version (V), padding (P), length:
      As described for the SR packet (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.1">Section =
6.4.1</A>).

   subtype: 5 bits
      May be used as a subtype to allow a set of APP packets to be
      defined under one unique name, or for any application-dependent
      data.

   packet type (PT): 8 bits
      Contains the constant 204 to identify this as an RTCP APP packet.







<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 52]</SPAN>
<A id=3Dpage-53 href=3D"http://tools.ietf.org/html/rfc3550#page-53" =
name=3Dpage-53><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   name: 4 octets
      A name chosen by the person defining the set of APP packets to be
      unique with respect to other APP packets this application might
      receive.  The application creator might choose to use the
      application name, and then coordinate the allocation of subtype
      values to others who want to define new packet types for the
      application.  Alternatively, it is RECOMMENDED that others choose
      a name based on the entity they represent, then coordinate the use
      of the name within that entity.  The name is interpreted as a
      sequence of four ASCII characters, with uppercase and lowercase
      characters treated as distinct.

   application-dependent data: variable length
      Application-dependent data may or may not appear in an APP packet.
      It is interpreted by the application and not RTP itself.  It MUST
      be a multiple of 32 bits long.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-7>7</A>. RTP =
Translators and Mixers</SPAN>

   In addition to end systems, RTP supports the notion of "translators"
   and "mixers", which could be considered as "intermediate systems" at
   the RTP level.  Although this support adds some complexity to the
   protocol, the need for these functions has been clearly established
   by experiments with multicast audio and video applications in the
   Internet.  Example uses of translators and mixers given in Section
   2.3 stem from the presence of firewalls and low bandwidth
   connections, both of which are likely to remain.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-7.1>7.1</A> General =
Description</SPAN>

   An RTP translator/mixer connects two or more transport-level
   "clouds".  Typically, each cloud is defined by a common network and
   transport protocol (e.g., IP/UDP) plus a multicast address and
   transport level destination port or a pair of unicast addresses and
   ports.  (Network-level protocol translators, such as IP version 4 to
   IP version 6, may be present within a cloud invisibly to RTP.)  One
   system may serve as a translator or mixer for a number of RTP
   sessions, but each is considered a logically separate entity.

   In order to avoid creating a loop when a translator or mixer is
   installed, the following rules MUST be observed:

   o  Each of the clouds connected by translators and mixers
      participating in one RTP session either MUST be distinct from all
      the others in at least one of these parameters (protocol, address,
      port), or MUST be isolated at the network level from the others.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 53]</SPAN>
<A id=3Dpage-54 href=3D"http://tools.ietf.org/html/rfc3550#page-54" =
name=3Dpage-54><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  A derivative of the first rule is that there MUST NOT be multiple
      translators or mixers connected in parallel unless by some
      arrangement they partition the set of sources to be forwarded.

   Similarly, all RTP end systems that can communicate through one or
   more RTP translators or mixers share the same SSRC space, that is,
   the SSRC identifiers MUST be unique among all these end systems.
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section =
8.2</A> describes the collision resolution algorithm by which
   SSRC identifiers are kept unique and loops are detected.

   There may be many varieties of translators and mixers designed for
   different purposes and applications.  Some examples are to add or
   remove encryption, change the encoding of the data or the underlying
   protocols, or replicate between a multicast address and one or more
   unicast addresses.  The distinction between translators and mixers is
   that a translator passes through the data streams from different
   sources separately, whereas a mixer combines them to form one new
   stream:

   Translator: Forwards RTP packets with their SSRC identifier
      intact; this makes it possible for receivers to identify
      individual sources even though packets from all the sources pass
      through the same translator and carry the translator's network
      source address.  Some kinds of translators will pass through the
      data untouched, but others MAY change the encoding of the data and
      thus the RTP data payload type and timestamp.  If multiple data
      packets are re-encoded into one, or vice versa, a translator MUST
      assign new sequence numbers to the outgoing packets.  Losses in
      the incoming packet stream may induce corresponding gaps in the
      outgoing sequence numbers.  Receivers cannot detect the presence
      of a translator unless they know by some other means what payload
      type or transport address was used by the original source.

   Mixer: Receives streams of RTP data packets from one or more
      sources, possibly changes the data format, combines the streams in
      some manner and then forwards the combined stream.  Since the
      timing among multiple input sources will not generally be
      synchronized, the mixer will make timing adjustments among the
      streams and generate its own timing for the combined stream, so it
      is the synchronization source.  Thus, all data packets forwarded
      by a mixer MUST be marked with the mixer's own SSRC identifier.
      In order to preserve the identity of the original sources
      contributing to the mixed packet, the mixer SHOULD insert their
      SSRC identifiers into the CSRC identifier list following the fixed
      RTP header of the packet.  A mixer that is also itself a
      contributing source for some packet SHOULD explicitly include its
      own SSRC identifier in the CSRC list for that packet.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 54]</SPAN>
<A id=3Dpage-55 href=3D"http://tools.ietf.org/html/rfc3550#page-55" =
name=3Dpage-55><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      For some applications, it MAY be acceptable for a mixer not to
      identify sources in the CSRC list.  However, this introduces the
      danger that loops involving those sources could not be detected.

   The advantage of a mixer over a translator for applications like
   audio is that the output bandwidth is limited to that of one source
   even when multiple sources are active on the input side.  This may be
   important for low-bandwidth links.  The disadvantage is that
   receivers on the output side don't have any control over which
   sources are passed through or muted, unless some mechanism is
   implemented for remote control of the mixer.  The regeneration of
   synchronization information by mixers also means that receivers can't
   do inter-media synchronization of the original streams.  A multi-
   media mixer could do it.

         [<A id=3Dref-E1 name=3Dref-E1>E1</A>]                           =
         [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-E6">E6</A>]
          |                                       |
    E1:17 |                                 E6:15 |
          |                                       |   E6:15
          V  M1:48 (1,17)         M1:48 (1,17)    V   M1:48 (1,17)
         =
(M1)-------------&gt;&lt;T1&gt;-----------------&gt;&lt;T2&gt;-----------=
---&gt;[<A href=3D"http://tools.ietf.org/html/rfc3550#ref-E7">E7</A>]
          ^                 ^     E4:47           ^   E4:47
     E2:1 |           E4:47 |                     |   M3:89 (64,45)
          |                 |                     |
         [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-E2">E2</A>]  =
            [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-E4">E4</A>]     M3:89 =
(64,45) |
                                                  |        legend:
   [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-E3">E3</A>] =
---------&gt;(M2)-----------&gt;(M3)------------|        [End system]
          E3:64        M2:12 (64)  ^                       (Mixer)
                                   | E5:45                 =
&lt;Translator&gt;
                                   |
                                  [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-E5">E5</A>]          =
source: SSRC (CSRCs)
                                                -------------------&gt;

   Figure 3: Sample RTP network with end systems, mixers and translators

   A collection of mixers and translators is shown in Fig. 3 to
   illustrate their effect on SSRC and CSRC identifiers.  In the figure,
   end systems are shown as rectangles (named E), translators as
   triangles (named T) and mixers as ovals (named M).  The notation "M1:
   48(1,17)" designates a packet originating a mixer M1, identified by
   M1's (random) SSRC value of 48 and two CSRC identifiers, 1 and 17,
   copied from the SSRC identifiers of packets from E1 and E2.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-7.2>7.2</A> RTCP =
Processing in Translators</SPAN>

   In addition to forwarding data packets, perhaps modified, translators
   and mixers MUST also process RTCP packets.  In many cases, they will
   take apart the compound RTCP packets received from end systems to



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 55]</SPAN>
<A id=3Dpage-56 href=3D"http://tools.ietf.org/html/rfc3550#page-56" =
name=3Dpage-56><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   aggregate SDES information and to modify the SR or RR packets.
   Retransmission of this information may be triggered by the packet
   arrival or by the RTCP interval timer of the translator or mixer
   itself.

   A translator that does not modify the data packets, for example one
   that just replicates between a multicast address and a unicast
   address, MAY simply forward RTCP packets unmodified as well.  A
   translator that transforms the payload in some way MUST make
   corresponding transformations in the SR and RR information so that it
   still reflects the characteristics of the data and the reception
   quality.  These translators MUST NOT simply forward RTCP packets.  In
   general, a translator SHOULD NOT aggregate SR and RR packets from
   different sources into one packet since that would reduce the
   accuracy of the propagation delay measurements based on the LSR and
   DLSR fields.

   SR sender information:  A translator does not generate its own
      sender information, but forwards the SR packets received from one
      cloud to the others.  The SSRC is left intact but the sender
      information MUST be modified if required by the translation.  If a
      translator changes the data encoding, it MUST change the "sender's
      byte count" field.  If it also combines several data packets into
      one output packet, it MUST change the "sender's packet count"
      field.  If it changes the timestamp frequency, it MUST change the
      "RTP timestamp" field in the SR packet.

   SR/RR reception report blocks:  A translator forwards reception
      reports received from one cloud to the others.  Note that these
      flow in the direction opposite to the data.  The SSRC is left
      intact.  If a translator combines several data packets into one
      output packet, and therefore changes the sequence numbers, it MUST
      make the inverse manipulation for the packet loss fields and the
      "extended last sequence number" field.  This may be complex.  In
      the extreme case, there may be no meaningful way to translate the
      reception reports, so the translator MAY pass on no reception
      report at all or a synthetic report based on its own reception.
      The general rule is to do what makes sense for a particular
      translation.

      A translator does not require an SSRC identifier of its own, but
      MAY choose to allocate one for the purpose of sending reports
      about what it has received.  These would be sent to all the
      connected clouds, each corresponding to the translation of the
      data stream as sent to that cloud, since reception reports are
      normally multicast to all participants.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 56]</SPAN>
<A id=3Dpage-57 href=3D"http://tools.ietf.org/html/rfc3550#page-57" =
name=3Dpage-57><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   SDES:  Translators typically forward without change the SDES
      information they receive from one cloud to the others, but MAY,
      for example, decide to filter non-CNAME SDES information if
      bandwidth is limited.  The CNAMEs MUST be forwarded to allow SSRC
      identifier collision detection to work.  A translator that
      generates its own RR packets MUST send SDES CNAME information
      about itself to the same clouds that it sends those RR packets.

   BYE:  Translators forward BYE packets unchanged.  A translator
      that is about to cease forwarding packets SHOULD send a BYE packet
      to each connected cloud containing all the SSRC identifiers that
      were previously being forwarded to that cloud, including the
      translator's own SSRC identifier if it sent reports of its own.

   APP:  Translators forward APP packets unchanged.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-7.3>7.3</A> RTCP =
Processing in Mixers</SPAN>

   Since a mixer generates a new data stream of its own, it does not
   pass through SR or RR packets at all and instead generates new
   information for both sides.

   SR sender information:  A mixer does not pass through sender
      information from the sources it mixes because the characteristics
      of the source streams are lost in the mix.  As a synchronization
      source, the mixer SHOULD generate its own SR packets with sender
      information about the mixed data stream and send them in the same
      direction as the mixed stream.

   SR/RR reception report blocks:  A mixer generates its own
      reception reports for sources in each cloud and sends them out
      only to the same cloud.  It MUST NOT send these reception reports
      to the other clouds and MUST NOT forward reception reports from
      one cloud to the others because the sources would not be SSRCs
      there (only CSRCs).

   SDES:  Mixers typically forward without change the SDES
      information they receive from one cloud to the others, but MAY,
      for example, decide to filter non-CNAME SDES information if
      bandwidth is limited.  The CNAMEs MUST be forwarded to allow SSRC
      identifier collision detection to work.  (An identifier in a CSRC
      list generated by a mixer might collide with an SSRC identifier
      generated by an end system.)  A mixer MUST send SDES CNAME
      information about itself to the same clouds that it sends SR or RR
      packets.






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 57]</SPAN>
<A id=3Dpage-58 href=3D"http://tools.ietf.org/html/rfc3550#page-58" =
name=3Dpage-58><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      Since mixers do not forward SR or RR packets, they will typically
      be extracting SDES packets from a compound RTCP packet.  To
      minimize overhead, chunks from the SDES packets MAY be aggregated
      into a single SDES packet which is then stacked on an SR or RR
      packet originating from the mixer.  A mixer which aggregates SDES
      packets will use more RTCP bandwidth than an individual source
      because the compound packets will be longer, but that is
      appropriate since the mixer represents multiple sources.
      Similarly, a mixer which passes through SDES packets as they are
      received will be transmitting RTCP packets at higher than the
      single source rate, but again that is correct since the packets
      come from multiple sources.  The RTCP packet rate may be different
      on each side of the mixer.

      A mixer that does not insert CSRC identifiers MAY also refrain
      from forwarding SDES CNAMEs.  In this case, the SSRC identifier
      spaces in the two clouds are independent.  As mentioned earlier,
      this mode of operation creates a danger that loops can't be
      detected.

   BYE:  Mixers MUST forward BYE packets.  A mixer that is about to
      cease forwarding packets SHOULD send a BYE packet to each
      connected cloud containing all the SSRC identifiers that were
      previously being forwarded to that cloud, including the mixer's
      own SSRC identifier if it sent reports of its own.

   APP:  The treatment of APP packets by mixers is application-specific.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-7.4>7.4</A> Cascaded =
Mixers</SPAN>

   An RTP session may involve a collection of mixers and translators as
   shown in Fig. 3.  If two mixers are cascaded, such as M2 and M3 in
   the figure, packets received by a mixer may already have been mixed
   and may include a CSRC list with multiple identifiers.  The second
   mixer SHOULD build the CSRC list for the outgoing packet using the
   CSRC identifiers from already-mixed input packets and the SSRC
   identifiers from unmixed input packets.  This is shown in the output
   arc from mixer M3 labeled M3:89(64,45) in the figure.  As in the case
   of mixers that are not cascaded, if the resulting CSRC list has more
   than 15 identifiers, the remainder cannot be included.











<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 58]</SPAN>
<A id=3Dpage-59 href=3D"http://tools.ietf.org/html/rfc3550#page-59" =
name=3Dpage-59><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"2"><A name=3Dsection-8>8</A>.  SSRC =
Identifier Allocation and Use</SPAN>

   The SSRC identifier carried in the RTP header and in various fields
   of RTCP packets is a random 32-bit number that is required to be
   globally unique within an RTP session.  It is crucial that the number
   be chosen with care in order that participants on the same network or
   starting at the same time are not likely to choose the same number.

   It is not sufficient to use the local network address (such as an
   IPv4 address) for the identifier because the address may not be
   unique.  Since RTP translators and mixers enable interoperation among
   multiple networks with different address spaces, the allocation
   patterns for addresses within two spaces might result in a much
   higher rate of collision than would occur with random allocation.

   Multiple sources running on one host would also conflict.

   It is also not sufficient to obtain an SSRC identifier simply by
   calling random() without carefully initializing the state.  An
   example of how to generate a random identifier is presented in
   Appendix A.6.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-8.1>8.1</A> =
Probability of Collision</SPAN>

   Since the identifiers are chosen randomly, it is possible that two or
   more sources will choose the same number.  Collision occurs with the
   highest probability when all sources are started simultaneously, for
   example when triggered automatically by some session management
   event.  If N is the number of sources and L the length of the
   identifier (here, 32 bits), the probability that two sources
   independently pick the same value can be approximated for large N
   [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-26">26</A>] as 1 - =
exp(-N**2 / 2**(L+1)).  For N=3D1000, the probability is
   roughly 10**-4.

   The typical collision probability is much lower than the worst-case
   above.  When one new source joins an RTP session in which all the
   other sources already have unique identifiers, the probability of
   collision is just the fraction of numbers used out of the space.
   Again, if N is the number of sources and L the length of the
   identifier, the probability of collision is N / 2**L.  For N=3D1000,
   the probability is roughly 2*10**-7.

   The probability of collision is further reduced by the opportunity
   for a new source to receive packets from other participants before
   sending its first packet (either data or control).  If the new source
   keeps track of the other participants (by SSRC identifier), then





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 59]</SPAN>
<A id=3Dpage-60 href=3D"http://tools.ietf.org/html/rfc3550#page-60" =
name=3Dpage-60><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   before transmitting its first packet the new source can verify that
   its identifier does not conflict with any that have been received, or
   else choose again.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-8.2>8.2</A> Collision =
Resolution and Loop Detection</SPAN>

   Although the probability of SSRC identifier collision is low, all RTP
   implementations MUST be prepared to detect collisions and take the
   appropriate actions to resolve them.  If a source discovers at any
   time that another source is using the same SSRC identifier as its
   own, it MUST send an RTCP BYE packet for the old identifier and
   choose another random one.  (As explained below, this step is taken
   only once in case of a loop.)  If a receiver discovers that two other
   sources are colliding, it MAY keep the packets from one and discard
   the packets from the other when this can be detected by different
   source transport addresses or CNAMEs.  The two sources are expected
   to resolve the collision so that the situation doesn't last.

   Because the random SSRC identifiers are kept globally unique for each
   RTP session, they can also be used to detect loops that may be
   introduced by mixers or translators.  A loop causes duplication of
   data and control information, either unmodified or possibly mixed, as
   in the following examples:

   o  A translator may incorrectly forward a packet to the same
      multicast group from which it has received the packet, either
      directly or through a chain of translators.  In that case, the
      same packet appears several times, originating from different
      network sources.

   o  Two translators incorrectly set up in parallel, i.e., with the
      same multicast groups on both sides, would both forward packets
      from one multicast group to the other.  Unidirectional translators
      would produce two copies; bidirectional translators would form a
      loop.

   o  A mixer can close a loop by sending to the same transport
      destination upon which it receives packets, either directly or
      through another mixer or translator.  In this case a source might
      show up both as an SSRC on a data packet and a CSRC in a mixed
      data packet.

   A source may discover that its own packets are being looped, or that
   packets from another source are being looped (a third-party loop).
   Both loops and collisions in the random selection of a source
   identifier result in packets arriving with the same SSRC identifier
   but a different source transport address, which may be that of the
   end system originating the packet or an intermediate system.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 60]</SPAN>
<A id=3Dpage-61 href=3D"http://tools.ietf.org/html/rfc3550#page-61" =
name=3Dpage-61><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Therefore, if a source changes its source transport address, it MAY
   also choose a new SSRC identifier to avoid being interpreted as a
   looped source.  (This is not MUST because in some applications of RTP
   sources may be expected to change addresses during a session.)  Note
   that if a translator restarts and consequently changes the source
   transport address (e.g., changes the UDP source port number) on which
   it forwards packets, then all those packets will appear to receivers
   to be looped because the SSRC identifiers are applied by the original
   source and will not change.  This problem can be avoided by keeping
   the source transport address fixed across restarts, but in any case
   will be resolved after a timeout at the receivers.

   Loops or collisions occurring on the far side of a translator or
   mixer cannot be detected using the source transport address if all
   copies of the packets go through the translator or mixer, however,
   collisions may still be detected when chunks from two RTCP SDES
   packets contain the same SSRC identifier but different CNAMEs.

   To detect and resolve these conflicts, an RTP implementation MUST
   include an algorithm similar to the one described below, though the
   implementation MAY choose a different policy for which packets from
   colliding third-party sources are kept.  The algorithm described
   below ignores packets from a new source or loop that collide with an
   established source.  It resolves collisions with the participant's
   own SSRC identifier by sending an RTCP BYE for the old identifier and
   choosing a new one.  However, when the collision was induced by a
   loop of the participant's own packets, the algorithm will choose a
   new identifier only once and thereafter ignore packets from the
   looping source transport address.  This is required to avoid a flood
   of BYE packets.

   This algorithm requires keeping a table indexed by the source
   identifier and containing the source transport addresses from the
   first RTP packet and first RTCP packet received with that identifier,
   along with other state for that source.  Two source transport
   addresses are required since, for example, the UDP source port
   numbers may be different on RTP and RTCP packets.  However, it may be
   assumed that the network address is the same in both source transport
   addresses.

   Each SSRC or CSRC identifier received in an RTP or RTCP packet is
   looked up in the source identifier table in order to process that
   data or control information.  The source transport address from the
   packet is compared to the corresponding source transport address in
   the table to detect a loop or collision if they don't match.  For
   control packets, each element with its own SSRC identifier, for
   example an SDES chunk, requires a separate lookup.  (The SSRC
   identifier in a reception report block is an exception because it



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 61]</SPAN>
<A id=3Dpage-62 href=3D"http://tools.ietf.org/html/rfc3550#page-62" =
name=3Dpage-62><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   identifies a source heard by the reporter, and that SSRC identifier
   is unrelated to the source transport address of the RTCP packet sent
   by the reporter.)  If the SSRC or CSRC is not found, a new entry is
   created.  These table entries are removed when an RTCP BYE packet is
   received with the corresponding SSRC identifier and validated by a
   matching source transport address, or after no packets have arrived
   for a relatively long time (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2.1">Section =
6.2.1</A>).

   Note that if two sources on the same host are transmitting with the
   same source identifier at the time a receiver begins operation, it
   would be possible that the first RTP packet received came from one of
   the sources while the first RTCP packet received came from the other.
   This would cause the wrong RTCP information to be associated with the
   RTP data, but this situation should be sufficiently rare and harmless
   that it may be disregarded.

   In order to track loops of the participant's own data packets, the
   implementation MUST also keep a separate list of source transport
   addresses (not identifiers) that have been found to be conflicting.
   As in the source identifier table, two source transport addresses
   MUST be kept to separately track conflicting RTP and RTCP packets.
   Note that the conflicting address list should be short, usually
   empty.  Each element in this list stores the source addresses plus
   the time when the most recent conflicting packet was received.  An
   element MAY be removed from the list when no conflicting packet has
   arrived from that source for a time on the order of 10 RTCP report
   intervals (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section =
6.2</A>).

   For the algorithm as shown, it is assumed that the participant's own
   source identifier and state are included in the source identifier
   table.  The algorithm could be restructured to first make a separate
   comparison against the participant's own source identifier.

      if (SSRC or CSRC identifier is not found in the source
          identifier table) {
          create a new entry storing the data or control source
              transport address, the SSRC or CSRC and other state;
      }

      /* Identifier is found in the table */

      else if (table entry was created on receipt of a control packet
               and this is the first data packet or vice versa) {
          store the source transport address from this packet;
      }
      else if (source transport address from the packet does not match
               the one saved in the table entry for this identifier) {




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 62]</SPAN>
<A id=3Dpage-63 href=3D"http://tools.ietf.org/html/rfc3550#page-63" =
name=3Dpage-63><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


          /* An identifier collision or a loop is indicated */

          if (source identifier is not the participant's own) {
              /* OPTIONAL error counter step */
              if (source identifier is from an RTCP SDES chunk
                  containing a CNAME item that differs from the CNAME
                  in the table entry) {
                  count a third-party collision;
              } else {
                  count a third-party loop;
              }
              abort processing of data packet or control element;
              /* MAY choose a different policy to keep new source */
          }

          /* A collision or loop of the participant's own packets */

          else if (source transport address is found in the list of
                   conflicting data or control source transport
                   addresses) {
              /* OPTIONAL error counter step */
              if (source identifier is not from an RTCP SDES chunk
                  containing a CNAME item or CNAME is the
                  participant's own) {
                  count occurrence of own traffic looped;
              }
              mark current time in conflicting address list entry;
              abort processing of data packet or control element;
          }

          /* New collision, change SSRC identifier */

          else {
              log occurrence of a collision;
              create a new entry in the conflicting data or control
                  source transport address list and mark current time;
              send an RTCP BYE packet with the old SSRC identifier;
              choose a new SSRC identifier;
              create a new entry in the source identifier table with
                  the old SSRC plus the source transport address from
                  the data or control packet being processed;
          }
      }

   In this algorithm, packets from a newly conflicting source address
   will be ignored and packets from the original source address will be
   kept.  If no packets arrive from the original source for an extended
   period, the table entry will be timed out and the new source will be



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 63]</SPAN>
<A id=3Dpage-64 href=3D"http://tools.ietf.org/html/rfc3550#page-64" =
name=3Dpage-64><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   able to take over.  This might occur if the original source detects
   the collision and moves to a new source identifier, but in the usual
   case an RTCP BYE packet will be received from the original source to
   delete the state without having to wait for a timeout.

   If the original source address was received through a mixer (i.e.,
   learned as a CSRC) and later the same source is received directly,
   the receiver may be well advised to switch to the new source address
   unless other sources in the mix would be lost.  Furthermore, for
   applications such as telephony in which some sources such as mobile
   entities may change addresses during the course of an RTP session,
   the RTP implementation SHOULD modify the collision detection
   algorithm to accept packets from the new source transport address.
   To guard against flip-flopping between addresses if a genuine
   collision does occur, the algorithm SHOULD include some means to
   detect this case and avoid switching.

   When a new SSRC identifier is chosen due to a collision, the
   candidate identifier SHOULD first be looked up in the source
   identifier table to see if it was already in use by some other
   source.  If so, another candidate MUST be generated and the process
   repeated.

   A loop of data packets to a multicast destination can cause severe
   network flooding.  All mixers and translators MUST implement a loop
   detection algorithm like the one here so that they can break loops.
   This should limit the excess traffic to no more than one duplicate
   copy of the original traffic, which may allow the session to continue
   so that the cause of the loop can be found and fixed.  However, in
   extreme cases where a mixer or translator does not properly break the
   loop and high traffic levels result, it may be necessary for end
   systems to cease transmitting data or control packets entirely.  This
   decision may depend upon the application.  An error condition SHOULD
   be indicated as appropriate.  Transmission MAY be attempted again
   periodically after a long, random time (on the order of minutes).

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-8.3>8.3</A> Use with =
Layered Encodings</SPAN>

   For layered encodings transmitted on separate RTP sessions (see
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-2.4">Section =
2.4</A>), a single SSRC identifier space SHOULD be used across
   the sessions of all layers and the core (base) layer SHOULD be used
   for SSRC identifier allocation and collision resolution.  When a
   source discovers that it has collided, it transmits an RTCP BYE
   packet on only the base layer but changes the SSRC identifier to the
   new value in all layers.






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 64]</SPAN>
<A id=3Dpage-65 href=3D"http://tools.ietf.org/html/rfc3550#page-65" =
name=3Dpage-65><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"2"><A name=3Dsection-9>9</A>. =
Security</SPAN>

   Lower layer protocols may eventually provide all the security
   services that may be desired for applications of RTP, including
   authentication, integrity, and confidentiality.  These services have
   been specified for IP in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-27">27</A>].  Since the =
initial audio and video
   applications using RTP needed a confidentiality service before such
   services were available for the IP layer, the confidentiality service
   described in the next section was defined for use with RTP and RTCP.
   That description is included here to codify existing practice.  New
   applications of RTP MAY implement this RTP-specific confidentiality
   service for backward compatibility, and/or they MAY implement
   alternative security services.  The overhead on the RTP protocol for
   this confidentiality service is low, so the penalty will be minimal
   if this service is obsoleted by other services in the future.

   Alternatively, other services, other implementations of services and
   other algorithms may be defined for RTP in the future.  In
   particular, an RTP profile called Secure Real-time Transport Protocol
   (SRTP) [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-28">28</A>] =
is being developed to provide confidentiality of the RTP
   payload while leaving the RTP header in the clear so that link-level
   header compression algorithms can still operate.  It is expected that
   SRTP will be the correct choice for many applications.  SRTP is based
   on the Advanced Encryption Standard (AES) and provides stronger
   security than the service described here.  No claim is made that the
   methods presented here are appropriate for a particular security
   need.  A profile may specify which services and algorithms should be
   offered by applications, and may provide guidance as to their
   appropriate use.

   Key distribution and certificates are outside the scope of this
   document.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-9.1>9.1</A> =
Confidentiality</SPAN>

   Confidentiality means that only the intended receiver(s) can decode
   the received packets; for others, the packet contains no useful
   information.  Confidentiality of the content is achieved by
   encryption.

   When it is desired to encrypt RTP or RTCP according to the method
   specified in this section, all the octets that will be encapsulated
   for transmission in a single lower-layer packet are encrypted as a
   unit.  For RTCP, a 32-bit random number redrawn for each unit MUST be
   prepended to the unit before encryption.  For RTP, no prefix is
   prepended; instead, the sequence number and timestamp fields are
   initialized with random offsets.  This is considered to be a weak




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 65]</SPAN>
<A id=3Dpage-66 href=3D"http://tools.ietf.org/html/rfc3550#page-66" =
name=3Dpage-66><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   initialization vector (IV) because of poor randomness properties.  In
   addition, if the subsequent field, the SSRC, can be manipulated by an
   enemy, there is further weakness of the encryption method.

   For RTCP, an implementation MAY segregate the individual RTCP packets
   in a compound RTCP packet into two separate compound RTCP packets,
   one to be encrypted and one to be sent in the clear.  For example,
   SDES information might be encrypted while reception reports were sent
   in the clear to accommodate third-party monitors that are not privy
   to the encryption key.  In this example, depicted in Fig. 4, the SDES
   information MUST be appended to an RR packet with no reports (and the
   random number) to satisfy the requirement that all compound RTCP
   packets begin with an SR or RR packet.  The SDES CNAME item is
   required in either the encrypted or unencrypted packet, but not both.
   The same SDES information SHOULD NOT be carried in both packets as
   this may compromise the encryption.

             UDP packet                     UDP packet
   -----------------------------  ------------------------------
   [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-random">random</A>][RR][SD=
ES #CNAME ...]  [SR #senderinfo #site1 #site2]
   -----------------------------  ------------------------------
             encrypted                     not encrypted

   #: SSRC identifier

       Figure 4: Encrypted and non-encrypted RTCP packets

   The presence of encryption and the use of the correct key are
   confirmed by the receiver through header or payload validity checks.
   Examples of such validity checks for RTP and RTCP headers are given
   in Appendices A.1 and A.2.

   To be consistent with existing implementations of the initial
   specification of RTP in <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>, the default =
encryption algorithm is
   the Data Encryption Standard (DES) algorithm in cipher block chaining
   (CBC) mode, as described in <A =
href=3D"http://tools.ietf.org/html/rfc1423#section-1.1">Section&nbsp;1.1 =
of RFC 1423</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-29">29</A>], except that
   padding to a multiple of 8 octets is indicated as described for the P
   bit in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.1">Section 5.1</A>. =
 The initialization vector is zero because random
   values are supplied in the RTP header or by the random prefix for
   compound RTCP packets.  For details on the use of CBC initialization
   vectors, see [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-30">30</A>].

   Implementations that support the encryption method specified here
   SHOULD always support the DES algorithm in CBC mode as the default
   cipher for this method to maximize interoperability.  This method was
   chosen because it has been demonstrated to be easy and practical to
   use in experimental audio and video tools in operation on the
   Internet.  However, DES has since been found to be too easily broken.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 66]</SPAN>
<A id=3Dpage-67 href=3D"http://tools.ietf.org/html/rfc3550#page-67" =
name=3Dpage-67><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   It is RECOMMENDED that stronger encryption algorithms such as
   Triple-DES be used in place of the default algorithm.  Furthermore,
   secure CBC mode requires that the first block of each packet be XORed
   with a random, independent IV of the same size as the cipher's block
   size.  For RTCP, this is (partially) achieved by prepending each
   packet with a 32-bit random number, independently chosen for each
   packet.  For RTP, the timestamp and sequence number start from random
   values, but consecutive packets will not be independently randomized.
   It should be noted that the randomness in both cases (RTP and RTCP)
   is limited.  High-security applications SHOULD consider other, more
   conventional, protection means.  Other encryption algorithms MAY be
   specified dynamically for a session by non-RTP means.  In particular,
   the SRTP profile [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-28">28</A>] based on AES =
is being developed to take into
   account known plaintext and CBC plaintext manipulation concerns, and
   will be the correct choice in the future.

   As an alternative to encryption at the IP level or at the RTP level
   as described above, profiles MAY define additional payload types for
   encrypted encodings.  Those encodings MUST specify how padding and
   other aspects of the encryption are to be handled.  This method
   allows encrypting only the data while leaving the headers in the
   clear for applications where that is desired.  It may be particularly
   useful for hardware devices that will handle both decryption and
   decoding.  It is also valuable for applications where link-level
   compression of RTP and lower-layer headers is desired and
   confidentiality of the payload (but not addresses) is sufficient
   since encryption of the headers precludes compression.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-9.2>9.2</A> =
Authentication and Message Integrity</SPAN>

   Authentication and message integrity services are not defined at the
   RTP level since these services would not be directly feasible without
   a key management infrastructure.  It is expected that authentication
   and integrity services will be provided by lower layer protocols.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-10>10</A>. Congestion =
Control</SPAN>

   All transport protocols used on the Internet need to address
   congestion control in some way [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-31">31</A>].  RTP is not =
an exception, but
   because the data transported over RTP is often inelastic (generated
   at a fixed or controlled rate), the means to control congestion in
   RTP may be quite different from those for other transport protocols
   such as TCP.  In one sense, inelasticity reduces the risk of
   congestion because the RTP stream will not expand to consume all
   available bandwidth as a TCP stream can.  However, inelasticity also
   means that the RTP stream cannot arbitrarily reduce its load on the
   network to eliminate congestion when it occurs.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 67]</SPAN>
<A id=3Dpage-68 href=3D"http://tools.ietf.org/html/rfc3550#page-68" =
name=3Dpage-68><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Since RTP may be used for a wide variety of applications in many
   different contexts, there is no single congestion control mechanism
   that will work for all.  Therefore, congestion control SHOULD be
   defined in each RTP profile as appropriate.  For some profiles, it
   may be sufficient to include an applicability statement restricting
   the use of that profile to environments where congestion is avoided
   by engineering.  For other profiles, specific methods such as data
   rate adaptation based on RTCP feedback may be required.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-11>11</A>. RTP over =
Network and Transport Protocols</SPAN>

   This section describes issues specific to carrying RTP packets within
   particular network and transport protocols.  The following rules
   apply unless superseded by protocol-specific definitions outside this
   specification.

   RTP relies on the underlying protocol(s) to provide demultiplexing of
   RTP data and RTCP control streams.  For UDP and similar protocols,
   RTP SHOULD use an even destination port number and the corresponding
   RTCP stream SHOULD use the next higher (odd) destination port number.
   For applications that take a single port number as a parameter and
   derive the RTP and RTCP port pair from that number, if an odd number
   is supplied then the application SHOULD replace that number with the
   next lower (even) number to use as the base of the port pair.  For
   applications in which the RTP and RTCP destination port numbers are
   specified via explicit, separate parameters (using a signaling
   protocol or other means), the application MAY disregard the
   restrictions that the port numbers be even/odd and consecutive
   although the use of an even/odd port pair is still encouraged.  The
   RTP and RTCP port numbers MUST NOT be the same since RTP relies on
   the port numbers to demultiplex the RTP data and RTCP control
   streams.

   In a unicast session, both participants need to identify a port pair
   for receiving RTP and RTCP packets.  Both participants MAY use the
   same port pair.  A participant MUST NOT assume that the source port
   of the incoming RTP or RTCP packet can be used as the destination
   port for outgoing RTP or RTCP packets.  When RTP data packets are
   being sent in both directions, each participant's RTCP SR packets
   MUST be sent to the port that the other participant has specified for
   reception of RTCP.  The RTCP SR packets combine sender information
   for the outgoing data plus reception report information for the
   incoming data.  If a side is not actively sending data (see Section
   6.4), an RTCP RR packet is sent instead.

   It is RECOMMENDED that layered encoding applications (see Section
   2.4) use a set of contiguous port numbers.  The port numbers MUST be
   distinct because of a widespread deficiency in existing operating



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 68]</SPAN>
<A id=3Dpage-69 href=3D"http://tools.ietf.org/html/rfc3550#page-69" =
name=3Dpage-69><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   systems that prevents use of the same port with multiple multicast
   addresses, and for unicast, there is only one permissible address.
   Thus for layer n, the data port is P + 2n, and the control port is P
   + 2n + 1.  When IP multicast is used, the addresses MUST also be
   distinct because multicast routing and group membership are managed
   on an address granularity.  However, allocation of contiguous IP
   multicast addresses cannot be assumed because some groups may require
   different scopes and may therefore be allocated from different
   address ranges.

   The previous paragraph conflicts with the SDP specification, <A =
href=3D"http://tools.ietf.org/html/rfc2327">RFC 2327</A>
   [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-15">15</A>], which =
says that it is illegal for both multiple addresses and
   multiple ports to be specified in the same session description
   because the association of addresses with ports could be ambiguous.
   It is intended that this restriction will be relaxed in a revision of
   <A href=3D"http://tools.ietf.org/html/rfc2327">RFC 2327</A> to allow =
an equal number of addresses and ports to be
   specified with a one-to-one mapping implied.

   RTP data packets contain no length field or other delineation,
   therefore RTP relies on the underlying protocol(s) to provide a
   length indication.  The maximum length of RTP packets is limited only
   by the underlying protocols.

   If RTP packets are to be carried in an underlying protocol that
   provides the abstraction of a continuous octet stream rather than
   messages (packets), an encapsulation of the RTP packets MUST be
   defined to provide a framing mechanism.  Framing is also needed if
   the underlying protocol may contain padding so that the extent of the
   RTP payload cannot be determined.  The framing mechanism is not
   defined here.

   A profile MAY specify a framing method to be used even when RTP is
   carried in protocols that do provide framing in order to allow
   carrying several RTP packets in one lower-layer protocol data unit,
   such as a UDP packet.  Carrying several RTP packets in one network or
   transport packet reduces header overhead and may simplify
   synchronization between different streams.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-12>12</A>. Summary of =
Protocol Constants</SPAN>

   This section contains a summary listing of the constants defined in
   this specification.

   The RTP payload type (PT) constants are defined in profiles rather
   than this document.  However, the octet of the RTP header which
   contains the marker bit(s) and payload type MUST avoid the reserved
   values 200 and 201 (decimal) to distinguish RTP packets from the RTCP
   SR and RR packet types for the header validation procedure described



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 69]</SPAN>
<A id=3Dpage-70 href=3D"http://tools.ietf.org/html/rfc3550#page-70" =
name=3Dpage-70><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   in Appendix A.1.  For the standard definition of one marker bit and a
   7-bit payload type field as shown in this specification, this
   restriction means that payload types 72 and 73 are reserved.

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-12.1>12.1</A> RTCP =
Packet Types</SPAN>

   abbrev.  name                 value
   SR       sender report          200
   RR       receiver report        201
   SDES     source description     202
   BYE      goodbye                203
   APP      application-defined    204

   These type values were chosen in the range 200-204 for improved
   header validity checking of RTCP packets compared to RTP packets or
   other unrelated packets.  When the RTCP packet type field is compared
   to the corresponding octet of the RTP header, this range corresponds
   to the marker bit being 1 (which it usually is not in data packets)
   and to the high bit of the standard payload type field being 1 (since
   the static payload types are typically defined in the low half).
   This range was also chosen to be some distance numerically from 0 and
   255 since all-zeros and all-ones are common data patterns.

   Since all compound RTCP packets MUST begin with SR or RR, these codes
   were chosen as an even/odd pair to allow the RTCP validity check to
   test the maximum number of bits with mask and value.

   Additional RTCP packet types may be registered through IANA (see
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-15">Section =
15</A>).

<SPAN class=3Dheader level=3D"3"><A name=3Dsection-12.2>12.2</A> SDES =
Types</SPAN>

   abbrev.  name                            value
   END      end of SDES list                    0
   CNAME    canonical name                      1
   NAME     user name                           2
   EMAIL    user's electronic mail address      3
   PHONE    user's phone number                 4
   LOC      geographic user location            5
   TOOL     name of application or tool         6
   NOTE     notice about the source             7
   PRIV     private extensions                  8

   Additional SDES types may be registered through IANA (see Section
   15).






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 70]</SPAN>
<A id=3Dpage-71 href=3D"http://tools.ietf.org/html/rfc3550#page-71" =
name=3Dpage-71><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


<SPAN class=3Dheader level=3D"2"><A name=3Dsection-13>13</A>.  RTP =
Profiles and Payload Format Specifications</SPAN>

   A complete specification of RTP for a particular application will
   require one or more companion documents of two types described here:
   profiles, and payload format specifications.

   RTP may be used for a variety of applications with somewhat differing
   requirements.  The flexibility to adapt to those requirements is
   provided by allowing multiple choices in the main protocol
   specification, then selecting the appropriate choices or defining
   extensions for a particular environment and class of applications in
   a separate profile document.  Typically an application will operate
   under only one profile in a particular RTP session, so there is no
   explicit indication within the RTP protocol itself as to which
   profile is in use.  A profile for audio and video applications may be
   found in the companion <A =
href=3D"http://tools.ietf.org/html/rfc3551">RFC 3551</A>.  Profiles are =
typically titled "RTP
   Profile for ...".

   The second type of companion document is a payload format
   specification, which defines how a particular kind of payload data,
   such as H.261 encoded video, should be carried in RTP.  These
   documents are typically titled "RTP Payload Format for XYZ
   Audio/Video Encoding".  Payload formats may be useful under multiple
   profiles and may therefore be defined independently of any particular
   profile.  The profile documents are then responsible for assigning a
   default mapping of that format to a payload type value if needed.

   Within this specification, the following items have been identified
   for possible definition within a profile, but this list is not meant
   to be exhaustive:

   RTP data header: The octet in the RTP data header that contains
      the marker bit and payload type field MAY be redefined by a
      profile to suit different requirements, for example with more or
      fewer marker bits (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.3">Section 5.3</A>, =
p. 18).

   Payload types: Assuming that a payload type field is included,
      the profile will usually define a set of payload formats (e.g.,
      media encodings) and a default static mapping of those formats to
      payload type values.  Some of the payload formats may be defined
      by reference to separate payload format specifications.  For each
      payload type defined, the profile MUST specify the RTP timestamp
      clock rate to be used (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.1">Section 5.1</A>, =
p. 14).

   RTP data header additions: Additional fields MAY be appended to
      the fixed RTP data header if some additional functionality is
      required across the profile's class of applications independent of
      payload type (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.3">Section 5.3</A>, =
p. 18).



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 71]</SPAN>
<A id=3Dpage-72 href=3D"http://tools.ietf.org/html/rfc3550#page-72" =
name=3Dpage-72><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   RTP data header extensions: The contents of the first 16 bits of
      the RTP data header extension structure MUST be defined if use of
      that mechanism is to be allowed under the profile for
      implementation-specific extensions (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-5.3.1">Section =
5.3.1</A>, p. 18).

   RTCP packet types: New application-class-specific RTCP packet
      types MAY be defined and registered with IANA.

   RTCP report interval: A profile SHOULD specify that the values
      suggested in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A> =
for the constants employed in the
      calculation of the RTCP report interval will be used.  Those are
      the RTCP fraction of session bandwidth, the minimum report
      interval, and the bandwidth split between senders and receivers.
      A profile MAY specify alternate values if they have been
      demonstrated to work in a scalable manner.

   SR/RR extension: An extension section MAY be defined for the
      RTCP SR and RR packets if there is additional information that
      should be reported regularly about the sender or receivers
      (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.3">Section =
6.4.3</A>, p. 42 and 43).

   SDES use: The profile MAY specify the relative priorities for
      RTCP SDES items to be transmitted or excluded entirely (Section
      6.3.9); an alternate syntax or semantics for the CNAME item
      (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.1">Section =
6.5.1</A>); the format of the LOC item (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.5">Section =
6.5.5</A>); the
      semantics and use of the NOTE item (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.7">Section =
6.5.7</A>); or new SDES
      item types to be registered with IANA.

   Security: A profile MAY specify which security services and
      algorithms should be offered by applications, and MAY provide
      guidance as to their appropriate use (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9">Section 9</A>, p. =
65).

   String-to-key mapping: A profile MAY specify how a user-provided
      password or pass phrase is mapped into an encryption key.

   Congestion: A profile SHOULD specify the congestion control
      behavior appropriate for that profile.

   Underlying protocol: Use of a particular underlying network or
      transport layer protocol to carry RTP packets MAY be required.

   Transport mapping: A mapping of RTP and RTCP to transport-level
      addresses, e.g., UDP ports, other than the standard mapping
      defined in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-11">Section 11</A>, =
p. 68 may be specified.







<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 72]</SPAN>
<A id=3Dpage-73 href=3D"http://tools.ietf.org/html/rfc3550#page-73" =
name=3Dpage-73><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Encapsulation: An encapsulation of RTP packets may be defined to
      allow multiple RTP data packets to be carried in one lower-layer
      packet or to provide framing over underlying protocols that do not
      already do so (<A =
href=3D"http://tools.ietf.org/html/rfc3550#section-11">Section 11</A>, =
p. 69).

   It is not expected that a new profile will be required for every
   application.  Within one application class, it would be better to
   extend an existing profile rather than make a new one in order to
   facilitate interoperation among the applications since each will
   typically run under only one profile.  Simple extensions such as the
   definition of additional payload type values or RTCP packet types may
   be accomplished by registering them through IANA and publishing their
   descriptions in an addendum to the profile or in a payload format
   specification.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-14>14</A>. Security =
Considerations</SPAN>

   RTP suffers from the same security liabilities as the underlying
   protocols.  For example, an impostor can fake source or destination
   network addresses, or change the header or payload.  Within RTCP, the
   CNAME and NAME information may be used to impersonate another
   participant.  In addition, RTP may be sent via IP multicast, which
   provides no direct means for a sender to know all the receivers of
   the data sent and therefore no measure of privacy.  Rightly or not,
   users may be more sensitive to privacy concerns with audio and video
   communication than they have been with more traditional forms of
   network communication [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-33">33</A>].  Therefore, =
the use of security
   mechanisms with RTP is important.  These mechanisms are discussed in
   <A href=3D"http://tools.ietf.org/html/rfc3550#section-9">Section =
9</A>.

   RTP-level translators or mixers may be used to allow RTP traffic to
   reach hosts behind firewalls.  Appropriate firewall security
   principles and practices, which are beyond the scope of this
   document, should be followed in the design and installation of these
   devices and in the admission of RTP applications for use behind the
   firewall.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-15>15</A>. IANA =
Considerations</SPAN>

   Additional RTCP packet types and SDES item types may be registered
   through the Internet Assigned Numbers Authority (IANA).  Since these
   number spaces are small, allowing unconstrained registration of new
   values would not be prudent.  To facilitate review of requests and to
   promote shared use of new types among multiple applications, requests
   for registration of new values must be documented in an RFC or other
   permanent and readily available reference such as the product of
   another cooperative standards body (e.g., ITU-T).  Other requests may
   also be accepted, under the advice of a "designated expert."



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 73]</SPAN>
<A id=3Dpage-74 href=3D"http://tools.ietf.org/html/rfc3550#page-74" =
name=3Dpage-74><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   (Contact the IANA for the contact information of the current expert.)

   RTP profile specifications SHOULD register with IANA a name for the
   profile in the form "RTP/xxx", where xxx is a short abbreviation of
   the profile title.  These names are for use by higher-level control
   protocols, such as the Session Description Protocol (SDP), <A =
href=3D"http://tools.ietf.org/html/rfc2327">RFC 2327</A>
   [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-15">15</A>], to =
refer to transport methods.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-16>16</A>. =
Intellectual Property Rights Statement</SPAN>

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; neither does it represent that it
   has made any effort to identify any such rights.  Information on the
   IETF's procedures with respect to rights in standards-track and
   standards-related documentation can be found in <A =
href=3D"http://tools.ietf.org/html/bcp11">BCP-11</A>.  Copies of
   claims of rights made available for publication and any assurances of
   licenses to be made available, or the result of an attempt made to
   obtain a general license or permission for the use of such
   proprietary rights by implementors or users of this specification can
   be obtained from the IETF Secretariat.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights which may cover technology that may be required to practice
   this standard.  Please address the information to the IETF Executive
   Director.

<SPAN class=3Dheader level=3D"2"><A name=3Dsection-17>17</A>.  =
Acknowledgments</SPAN>

   This memorandum is based on discussions within the IETF Audio/Video
   Transport working group chaired by Stephen Casner and Colin Perkins.
   The current protocol has its origins in the Network Voice Protocol
   and the Packet Video Protocol (Danny Cohen and Randy Cole) and the
   protocol implemented by the vat application (Van Jacobson and Steve
   McCanne).  Christian Huitema provided ideas for the random identifier
   generator.  Extensive analysis and simulation of the timer
   reconsideration algorithm was done by Jonathan Rosenberg.  The
   additions for layered encodings were specified by Michael Speer and
   Steve McCanne.









<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 74]</SPAN>
<A id=3Dpage-75 href=3D"http://tools.ietf.org/html/rfc3550#page-75" =
name=3Dpage-75><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


Appendix A - Algorithms

   We provide examples of C code for aspects of RTP sender and receiver
   algorithms.  There may be other implementation methods that are
   faster in particular operating environments or have other advantages.
   These implementation notes are for informational purposes only and
   are meant to clarify the RTP specification.

   The following definitions are used for all examples; for clarity and
   brevity, the structure definitions are only valid for 32-bit big-
   endian (most significant octet first) architectures.  Bit fields are
   assumed to be packed tightly in big-endian bit order, with no
   additional padding.  Modifications would be required to construct a
   portable implementation.

   /*
    * rtp.h  --  RTP header file
    */
   #include &lt;sys/types.h&gt;

   /*
    * The type definitions below are valid for 32-bit architectures and
    * may have to be adjusted for 16- or 64-bit architectures.
    */
   typedef unsigned char  u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int   u_int32;
   typedef          short int16;

   /*
    * Current protocol version.
    */
   #define RTP_VERSION    2

   #define RTP_SEQ_MOD (1&lt;&lt;16)
   #define RTP_MAX_SDES 255      /* maximum text length for SDES */

   typedef enum {
       RTCP_SR   =3D 200,
       RTCP_RR   =3D 201,
       RTCP_SDES =3D 202,
       RTCP_BYE  =3D 203,
       RTCP_APP  =3D 204
   } rtcp_type_t;

   typedef enum {
       RTCP_SDES_END   =3D 0,
       RTCP_SDES_CNAME =3D 1,



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 75]</SPAN>
<A id=3Dpage-76 href=3D"http://tools.ietf.org/html/rfc3550#page-76" =
name=3Dpage-76><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


       RTCP_SDES_NAME  =3D 2,
       RTCP_SDES_EMAIL =3D 3,
       RTCP_SDES_PHONE =3D 4,
       RTCP_SDES_LOC   =3D 5,
       RTCP_SDES_TOOL  =3D 6,
       RTCP_SDES_NOTE  =3D 7,
       RTCP_SDES_PRIV  =3D 8
   } rtcp_sdes_type_t;

   /*
    * RTP data header
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int x:1;         /* header extension flag */
       unsigned int cc:4;        /* CSRC count */
       unsigned int m:1;         /* marker bit */
       unsigned int pt:7;        /* payload type */
       unsigned int seq:16;      /* sequence number */
       u_int32 ts;               /* timestamp */
       u_int32 ssrc;             /* synchronization source */
       u_int32 csrc[1];          /* optional CSRC list */
   } rtp_hdr_t;

   /*
    * RTCP common header word
    */
   typedef struct {
       unsigned int version:2;   /* protocol version */
       unsigned int p:1;         /* padding flag */
       unsigned int count:5;     /* varies by packet type */
       unsigned int pt:8;        /* RTCP packet type */
       u_int16 length;           /* pkt len in words, w/o this word */
   } rtcp_common_t;

   /*
    * Big-endian mask for version, padding bit and packet type pair
    */
   #define RTCP_VALID_MASK (0xc000 | 0x2000 | 0xfe)
   #define RTCP_VALID_VALUE ((RTP_VERSION &lt;&lt; 14) | RTCP_SR)

   /*
    * Reception report block
    */
   typedef struct {
       u_int32 ssrc;             /* data source being reported */
       unsigned int fraction:8;  /* fraction lost since last SR/RR */



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 76]</SPAN>
<A id=3Dpage-77 href=3D"http://tools.ietf.org/html/rfc3550#page-77" =
name=3Dpage-77><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


       int lost:24;              /* cumul. no. pkts lost (signed!) */
       u_int32 last_seq;         /* extended last seq. no. received */
       u_int32 jitter;           /* interarrival jitter */
       u_int32 lsr;              /* last SR packet from this source */
       u_int32 dlsr;             /* delay since last SR packet */
   } rtcp_rr_t;

   /*
    * SDES item
    */
   typedef struct {
       u_int8 type;              /* type of item (rtcp_sdes_type_t) */
       u_int8 length;            /* length of item (in octets) */
       char data[1];             /* text, not null-terminated */
   } rtcp_sdes_item_t;

   /*
    * One RTCP packet
    */
   typedef struct {
       rtcp_common_t common;     /* common header */
       union {
           /* sender report (SR) */
           struct {
               u_int32 ssrc;     /* sender generating this report */
               u_int32 ntp_sec;  /* NTP timestamp */
               u_int32 ntp_frac;
               u_int32 rtp_ts;   /* RTP timestamp */
               u_int32 psent;    /* packets sent */
               u_int32 osent;    /* octets sent */
               rtcp_rr_t rr[1];  /* variable-length list */
           } sr;

           /* reception report (RR) */
           struct {
               u_int32 ssrc;     /* receiver generating this report */
               rtcp_rr_t rr[1];  /* variable-length list */
           } rr;

           /* source description (SDES) */
           struct rtcp_sdes {
               u_int32 src;      /* first SSRC/CSRC */
               rtcp_sdes_item_t item[1]; /* list of SDES items */
           } sdes;

           /* BYE */
           struct {
               u_int32 src[1];   /* list of sources */



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 77]</SPAN>
<A id=3Dpage-78 href=3D"http://tools.ietf.org/html/rfc3550#page-78" =
name=3Dpage-78><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


               /* can't express trailing text for reason */
           } bye;
       } r;
   } rtcp_t;

   typedef struct rtcp_sdes rtcp_sdes_t;

   /*
    * Per-source state information
    */
   typedef struct {
       u_int16 max_seq;        /* highest seq. number seen */
       u_int32 cycles;         /* shifted count of seq. number cycles */
       u_int32 base_seq;       /* base seq number */
       u_int32 bad_seq;        /* last 'bad' seq number + 1 */
       u_int32 probation;      /* sequ. packets till source is valid */
       u_int32 received;       /* packets received */
       u_int32 expected_prior; /* packet expected at last interval */
       u_int32 received_prior; /* packet received at last interval */
       u_int32 transit;        /* relative trans time for prev pkt */
       u_int32 jitter;         /* estimated jitter */
       /* ... */
   } source;

A.1 RTP Data Header Validity Checks

   An RTP receiver should check the validity of the RTP header on
   incoming packets since they might be encrypted or might be from a
   different application that happens to be misaddressed.  Similarly, if
   encryption according to the method described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-9">Section 9</A> is =
enabled,
   the header validity check is needed to verify that incoming packets
   have been correctly decrypted, although a failure of the header
   validity check (e.g., unknown payload type) may not necessarily
   indicate decryption failure.

   Only weak validity checks are possible on an RTP data packet from a
   source that has not been heard before:

   o  RTP version field must equal 2.

   o  The payload type must be known, and in particular it must not be
      equal to SR or RR.

   o  If the P bit is set, then the last octet of the packet must
      contain a valid octet count, in particular, less than the total
      packet length minus the header size.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 78]</SPAN>
<A id=3Dpage-79 href=3D"http://tools.ietf.org/html/rfc3550#page-79" =
name=3Dpage-79><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  The X bit must be zero if the profile does not specify that the
      header extension mechanism may be used.  Otherwise, the extension
      length field must be less than the total packet size minus the
      fixed header length and padding.

   o  The length of the packet must be consistent with CC and payload
      type (if payloads have a known length).

   The last three checks are somewhat complex and not always possible,
   leaving only the first two which total just a few bits.  If the SSRC
   identifier in the packet is one that has been received before, then
   the packet is probably valid and checking if the sequence number is
   in the expected range provides further validation.  If the SSRC
   identifier has not been seen before, then data packets carrying that
   identifier may be considered invalid until a small number of them
   arrive with consecutive sequence numbers.  Those invalid packets MAY
   be discarded or they MAY be stored and delivered once validation has
   been achieved if the resulting delay is acceptable.

   The routine update_seq shown below ensures that a source is declared
   valid only after MIN_SEQUENTIAL packets have been received in
   sequence.  It also validates the sequence number seq of a newly
   received packet and updates the sequence state for the packet's
   source in the structure to which s points.

   When a new source is heard for the first time, that is, its SSRC
   identifier is not in the table (see <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section =
8.2</A>), and the per-source
   state is allocated for it, s-&gt;probation is set to the number of
   sequential packets required before declaring a source valid
   (parameter MIN_SEQUENTIAL) and other variables are initialized:

      init_seq(s, seq);
      s-&gt;max_seq =3D seq - 1;
      s-&gt;probation =3D MIN_SEQUENTIAL;

   A non-zero s-&gt;probation marks the source as not yet valid so the
   state may be discarded after a short timeout rather than a long one,
   as discussed in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2.1">Section =
6.2.1</A>.

   After a source is considered valid, the sequence number is considered
   valid if it is no more than MAX_DROPOUT ahead of s-&gt;max_seq nor =
more
   than MAX_MISORDER behind.  If the new sequence number is ahead of
   max_seq modulo the RTP sequence number range (16 bits), but is
   smaller than max_seq, it has wrapped around and the (shifted) count
   of sequence number cycles is incremented.  A value of one is returned
   to indicate a valid sequence number.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 79]</SPAN>
<A id=3Dpage-80 href=3D"http://tools.ietf.org/html/rfc3550#page-80" =
name=3Dpage-80><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Otherwise, the value zero is returned to indicate that the validation
   failed, and the bad sequence number plus 1 is stored.  If the next
   packet received carries the next higher sequence number, it is
   considered the valid start of a new packet sequence presumably caused
   by an extended dropout or a source restart.  Since multiple complete
   sequence number cycles may have been missed, the packet loss
   statistics are reset.

   Typical values for the parameters are shown, based on a maximum
   misordering time of 2 seconds at 50 packets/second and a maximum
   dropout of 1 minute.  The dropout parameter MAX_DROPOUT should be a
   small fraction of the 16-bit sequence number space to give a
   reasonable probability that new sequence numbers after a restart will
   not fall in the acceptable range for sequence numbers from before the
   restart.

   void init_seq(source *s, u_int16 seq)
   {
       s-&gt;base_seq =3D seq;
       s-&gt;max_seq =3D seq;
       s-&gt;bad_seq =3D RTP_SEQ_MOD + 1;   /* so seq =3D=3D bad_seq is =
false */
       s-&gt;cycles =3D 0;
       s-&gt;received =3D 0;
       s-&gt;received_prior =3D 0;
       s-&gt;expected_prior =3D 0;
       /* other initialization */
   }

   int update_seq(source *s, u_int16 seq)
   {
       u_int16 udelta =3D seq - s-&gt;max_seq;
       const int MAX_DROPOUT =3D 3000;
       const int MAX_MISORDER =3D 100;
       const int MIN_SEQUENTIAL =3D 2;

       /*
        * Source is not valid until MIN_SEQUENTIAL packets with
        * sequential sequence numbers have been received.
        */
       if (s-&gt;probation) {
           /* packet is in sequence */
           if (seq =3D=3D s-&gt;max_seq + 1) {
               s-&gt;probation--;
               s-&gt;max_seq =3D seq;
               if (s-&gt;probation =3D=3D 0) {
                   init_seq(s, seq);
                   s-&gt;received++;
                   return 1;



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 80]</SPAN>
<A id=3Dpage-81 href=3D"http://tools.ietf.org/html/rfc3550#page-81" =
name=3Dpage-81><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


               }
           } else {
               s-&gt;probation =3D MIN_SEQUENTIAL - 1;
               s-&gt;max_seq =3D seq;
           }
           return 0;
       } else if (udelta &lt; MAX_DROPOUT) {
           /* in order, with permissible gap */
           if (seq &lt; s-&gt;max_seq) {
               /*
                * Sequence number wrapped - count another 64K cycle.
                */
               s-&gt;cycles +=3D RTP_SEQ_MOD;
           }
           s-&gt;max_seq =3D seq;
       } else if (udelta &lt;=3D RTP_SEQ_MOD - MAX_MISORDER) {
           /* the sequence number made a very large jump */
           if (seq =3D=3D s-&gt;bad_seq) {
               /*
                * Two sequential packets -- assume that the other side
                * restarted without telling us so just re-sync
                * (i.e., pretend this was the first packet).
                */
               init_seq(s, seq);
           }
           else {
               s-&gt;bad_seq =3D (seq + 1) &amp; (RTP_SEQ_MOD-1);
               return 0;
           }
       } else {
           /* duplicate or reordered packet */
       }
       s-&gt;received++;
       return 1;
   }

   The validity check can be made stronger requiring more than two
   packets in sequence.  The disadvantages are that a larger number of
   initial packets will be discarded (or delayed in a queue) and that
   high packet loss rates could prevent validation.  However, because
   the RTCP header validation is relatively strong, if an RTCP packet is
   received from a source before the data packets, the count could be
   adjusted so that only two packets are required in sequence.  If
   initial data loss for a few seconds can be tolerated, an application
   MAY choose to discard all data packets from a source until a valid
   RTCP packet has been received from that source.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 81]</SPAN>
<A id=3Dpage-82 href=3D"http://tools.ietf.org/html/rfc3550#page-82" =
name=3Dpage-82><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   Depending on the application and encoding, algorithms may exploit
   additional knowledge about the payload format for further validation.
   For payload types where the timestamp increment is the same for all
   packets, the timestamp values can be predicted from the previous
   packet received from the same source using the sequence number
   difference (assuming no change in payload type).

   A strong "fast-path" check is possible since with high probability
   the first four octets in the header of a newly received RTP data
   packet will be just the same as that of the previous packet from the
   same SSRC except that the sequence number will have increased by one.
   Similarly, a single-entry cache may be used for faster SSRC lookups
   in applications where data is typically received from one source at a
   time.

A.2 RTCP Header Validity Checks

   The following checks should be applied to RTCP packets.

   o  RTP version field must equal 2.

   o  The payload type field of the first RTCP packet in a compound
      packet must be equal to SR or RR.

   o  The padding bit (P) should be zero for the first packet of a
      compound RTCP packet because padding should only be applied, if it
      is needed, to the last packet.

   o  The length fields of the individual RTCP packets must add up to
      the overall length of the compound RTCP packet as received.  This
      is a fairly strong check.

   The code fragment below performs all of these checks.  The packet
   type is not checked for subsequent packets since unknown packet types
   may be present and should be ignored.

      u_int32 len;        /* length of compound RTCP packet in words */
      rtcp_t *r;          /* RTCP header */
      rtcp_t *end;        /* end of compound RTCP packet */

      if ((*(u_int16 *)r &amp; RTCP_VALID_MASK) !=3D RTCP_VALID_VALUE) {
          /* something wrong with packet format */
      }
      end =3D (rtcp_t *)((u_int32 *)r + len);

      do r =3D (rtcp_t *)((u_int32 *)r + r-&gt;common.length + 1);
      while (r &lt; end &amp;&amp; r-&gt;common.version =3D=3D 2);




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 82]</SPAN>
<A id=3Dpage-83 href=3D"http://tools.ietf.org/html/rfc3550#page-83" =
name=3Dpage-83><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      if (r !=3D end) {
          /* something wrong with packet format */
      }

A.3 Determining Number of Packets Expected and Lost

   In order to compute packet loss rates, the number of RTP packets
   expected and actually received from each source needs to be known,
   using per-source state information defined in struct source
   referenced via pointer s in the code below.  The number of packets
   received is simply the count of packets as they arrive, including any
   late or duplicate packets.  The number of packets expected can be
   computed by the receiver as the difference between the highest
   sequence number received (s-&gt;max_seq) and the first sequence =
number
   received (s-&gt;base_seq).  Since the sequence number is only 16 bits
   and will wrap around, it is necessary to extend the highest sequence
   number with the (shifted) count of sequence number wraparounds
   (s-&gt;cycles).  Both the received packet count and the count of =
cycles
   are maintained the RTP header validity check routine in Appendix A.1.

      extended_max =3D s-&gt;cycles + s-&gt;max_seq;
      expected =3D extended_max - s-&gt;base_seq + 1;

   The number of packets lost is defined to be the number of packets
   expected less the number of packets actually received:

      lost =3D expected - s-&gt;received;

   Since this signed number is carried in 24 bits, it should be clamped
   at 0x7fffff for positive loss or 0x800000 for negative loss rather
   than wrapping around.

   The fraction of packets lost during the last reporting interval
   (since the previous SR or RR packet was sent) is calculated from
   differences in the expected and received packet counts across the
   interval, where expected_prior and received_prior are the values
   saved when the previous reception report was generated:

      expected_interval =3D expected - s-&gt;expected_prior;
      s-&gt;expected_prior =3D expected;
      received_interval =3D s-&gt;received - s-&gt;received_prior;
      s-&gt;received_prior =3D s-&gt;received;
      lost_interval =3D expected_interval - received_interval;
      if (expected_interval =3D=3D 0 || lost_interval &lt;=3D 0) =
fraction =3D 0;
      else fraction =3D (lost_interval &lt;&lt; 8) / expected_interval;

   The resulting fraction is an 8-bit fixed point number with the binary
   point at the left edge.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 83]</SPAN>
<A id=3Dpage-84 href=3D"http://tools.ietf.org/html/rfc3550#page-84" =
name=3Dpage-84><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


A.4 Generating RTCP SDES Packets

   This function builds one SDES chunk into buffer b composed of argc
   items supplied in arrays type, value and length.  It returns a
   pointer to the next available location within b.

   char *rtp_write_sdes(char *b, u_int32 src, int argc,
                        rtcp_sdes_type_t type[], char *value[],
                        int length[])
   {
       rtcp_sdes_t *s =3D (rtcp_sdes_t *)b;
       rtcp_sdes_item_t *rsp;
       int i;
       int len;
       int pad;

       /* SSRC header */
       s-&gt;src =3D src;
       rsp =3D &amp;s-&gt;item[0];

       /* SDES items */
       for (i =3D 0; i &lt; argc; i++) {
           rsp-&gt;type =3D type[i];
           len =3D length[i];
           if (len &gt; RTP_MAX_SDES) {
               /* invalid length, may want to take other action */
               len =3D RTP_MAX_SDES;
           }
           rsp-&gt;length =3D len;
           memcpy(rsp-&gt;data, value[i], len);
           rsp =3D (rtcp_sdes_item_t *)&amp;rsp-&gt;data[len];
       }

       /* terminate with end marker and pad to next 4-octet boundary */
       len =3D ((char *) rsp) - b;
       pad =3D 4 - (len &amp; 0x3);
       b =3D (char *) rsp;
       while (pad--) *b++ =3D RTCP_SDES_END;

       return b;
   }










<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 84]</SPAN>
<A id=3Dpage-85 href=3D"http://tools.ietf.org/html/rfc3550#page-85" =
name=3Dpage-85><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


A.5 Parsing RTCP SDES Packets

   This function parses an SDES packet, calling functions find_member()
   to find a pointer to the information for a session member given the
   SSRC identifier and member_sdes() to store the new SDES information
   for that member.  This function expects a pointer to the header of
   the RTCP packet.

   void rtp_read_sdes(rtcp_t *r)
   {
       int count =3D r-&gt;common.count;
       rtcp_sdes_t *sd =3D &amp;r-&gt;r.sdes;
       rtcp_sdes_item_t *rsp, *rspn;
       rtcp_sdes_item_t *end =3D (rtcp_sdes_item_t *)
                               ((u_int32 *)r + r-&gt;common.length + 1);
       source *s;

       while (--count &gt;=3D 0) {
           rsp =3D &amp;sd-&gt;item[0];
           if (rsp &gt;=3D end) break;
           s =3D find_member(sd-&gt;src);

           for (; rsp-&gt;type; rsp =3D rspn ) {
               rspn =3D (rtcp_sdes_item_t =
*)((char*)rsp+rsp-&gt;length+2);
               if (rspn &gt;=3D end) {
                   rsp =3D rspn;
                   break;
               }
               member_sdes(s, rsp-&gt;type, rsp-&gt;data, =
rsp-&gt;length);
           }
           sd =3D (rtcp_sdes_t *)
                ((u_int32 *)sd + (((char *)rsp - (char *)sd) &gt;&gt; =
2)+1);
       }
       if (count &gt;=3D 0) {
           /* invalid packet format */
       }
   }

A.6 Generating a Random 32-bit Identifier

   The following subroutine generates a random 32-bit identifier using
   the MD5 routines published in <A =
href=3D"http://tools.ietf.org/html/rfc1321">RFC 1321</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-32">32</A>].  The system =
routines may
   not be present on all operating systems, but they should serve as
   hints as to what kinds of information may be used.  Other system
   calls that may be appropriate include






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 85]</SPAN>
<A id=3Dpage-86 href=3D"http://tools.ietf.org/html/rfc3550#page-86" =
name=3Dpage-86><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  getdomainname(),

   o  getwd(), or

   o  getrusage().

   "Live" video or audio samples are also a good source of random
   numbers, but care must be taken to avoid using a turned-off
   microphone or blinded camera as a source [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-17">17</A>].

   Use of this or a similar routine is recommended to generate the
   initial seed for the random number generator producing the RTCP
   period (as shown in Appendix A.7), to generate the initial values for
   the sequence number and timestamp, and to generate SSRC values.
   Since this routine is likely to be CPU-intensive, its direct use to
   generate RTCP periods is inappropriate because predictability is not
   an issue.  Note that this routine produces the same result on
   repeated calls until the value of the system clock changes unless
   different values are supplied for the type argument.

   /*
    * Generate a random 32-bit quantity.
    */
   #include &lt;sys/types.h&gt;   /* u_long */
   #include &lt;sys/time.h&gt;    /* gettimeofday() */
   #include &lt;unistd.h&gt;      /* get..() */
   #include &lt;stdio.h&gt;       /* printf() */
   #include &lt;time.h&gt;        /* clock() */
   #include &lt;sys/utsname.h&gt; /* uname() */
   #include "global.h"      /* from <A =
href=3D"http://tools.ietf.org/html/rfc1321">RFC 1321</A> */
   #include "md5.h"         /* from <A =
href=3D"http://tools.ietf.org/html/rfc1321">RFC 1321</A> */

   #define MD_CTX MD5_CTX
   #define MDInit MD5Init
   #define MDUpdate MD5Update
   #define MDFinal MD5Final

   static u_long md_32(char *string, int length)
   {
       MD_CTX context;
       union {
           char   c[16];
           u_long x[4];
       } digest;
       u_long r;
       int i;

       MDInit (&amp;context);



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 86]</SPAN>
<A id=3Dpage-87 href=3D"http://tools.ietf.org/html/rfc3550#page-87" =
name=3Dpage-87><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


       MDUpdate (&amp;context, string, length);
       MDFinal ((unsigned char *)&amp;digest, &amp;context);
       r =3D 0;
       for (i =3D 0; i &lt; 3; i++) {
           r ^=3D digest.x[i];
       }
       return r;
   }                               /* md_32 */

   /*
    * Return random unsigned 32-bit quantity.  Use 'type' argument if
    * you need to generate several different values in close succession.
    */
   u_int32 random32(int type)
   {
       struct {
           int     type;
           struct  timeval tv;
           clock_t cpu;
           pid_t   pid;
           u_long  hid;
           uid_t   uid;
           gid_t   gid;
           struct  utsname name;
       } s;

       gettimeofday(&amp;s.tv, 0);
       uname(&amp;s.name);
       s.type =3D type;
       s.cpu  =3D clock();
       s.pid  =3D getpid();
       s.hid  =3D gethostid();
       s.uid  =3D getuid();
       s.gid  =3D getgid();
       /* also: system uptime */

       return md_32((char *)&amp;s, sizeof(s));
   }                               /* random32 */

A.7 Computing the RTCP Transmission Interval

   The following functions implement the RTCP transmission and reception
   rules described in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>. =
 These rules are coded in several
   functions:

   o  rtcp_interval() computes the deterministic calculated interval,
      measured in seconds.  The parameters are defined in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3">Section 6.3</A>.




<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 87]</SPAN>
<A id=3Dpage-88 href=3D"http://tools.ietf.org/html/rfc3550#page-88" =
name=3Dpage-88><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  OnExpire() is called when the RTCP transmission timer expires.

   o  OnReceive() is called whenever an RTCP packet is received.

   Both OnExpire() and OnReceive() have event e as an argument.  This is
   the next scheduled event for that participant, either an RTCP report
   or a BYE packet.  It is assumed that the following functions are
   available:

   o  Schedule(time t, event e) schedules an event e to occur at time t.
      When time t arrives, the function OnExpire is called with e as an
      argument.

   o  Reschedule(time t, event e) reschedules a previously scheduled
      event e for time t.

   o  SendRTCPReport(event e) sends an RTCP report.

   o  SendBYEPacket(event e) sends a BYE packet.

   o  TypeOfEvent(event e) returns EVENT_BYE if the event being
      processed is for a BYE packet to be sent, else it returns
      EVENT_REPORT.

   o  PacketType(p) returns PACKET_RTCP_REPORT if packet p is an RTCP
      report (not BYE), PACKET_BYE if its a BYE RTCP packet, and
      PACKET_RTP if its a regular RTP data packet.

   o  ReceivedPacketSize() and SentPacketSize() return the size of the
      referenced packet in octets.

   o  NewMember(p) returns a 1 if the participant who sent packet p is
      not currently in the member list, 0 otherwise.  Note this function
      is not sufficient for a complete implementation because each CSRC
      identifier in an RTP packet and each SSRC in a BYE packet should
      be processed.

   o  NewSender(p) returns a 1 if the participant who sent packet p is
      not currently in the sender sublist of the member list, 0
      otherwise.

   o  AddMember() and RemoveMember() to add and remove participants from
      the member list.

   o  AddSender() and RemoveSender() to add and remove participants from
      the sender sublist of the member list.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 88]</SPAN>
<A id=3Dpage-89 href=3D"http://tools.ietf.org/html/rfc3550#page-89" =
name=3Dpage-89><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   These functions would have to be extended for an implementation that
   allows the RTCP bandwidth fractions for senders and non-senders to be
   specified as explicit parameters rather than fixed values of 25% and
   75%.  The extended implementation of rtcp_interval() would need to
   avoid division by zero if one of the parameters was zero.

   double rtcp_interval(int members,
                        int senders,
                        double rtcp_bw,
                        int we_sent,
                        double avg_rtcp_size,
                        int initial)
   {
       /*
        * Minimum average time between RTCP packets from this site (in
        * seconds).  This time prevents the reports from `clumping' when
        * sessions are small and the law of large numbers isn't helping
        * to smooth out the traffic.  It also keeps the report interval
        * from becoming ridiculously small during transient outages like
        * a network partition.
        */
       double const RTCP_MIN_TIME =3D 5.;
       /*
        * Fraction of the RTCP bandwidth to be shared among active
        * senders.  (This fraction was chosen so that in a typical
        * session with one or two active senders, the computed report
        * time would be roughly equal to the minimum report time so that
        * we don't unnecessarily slow down receiver reports.)  The
        * receiver fraction must be 1 - the sender fraction.
        */
       double const RTCP_SENDER_BW_FRACTION =3D 0.25;
       double const RTCP_RCVR_BW_FRACTION =3D =
(1-RTCP_SENDER_BW_FRACTION);
       /*
       /* To compensate for "timer reconsideration" converging to a
        * value below the intended average.
        */
       double const COMPENSATION =3D 2.71828 - 1.5;

       double t;                   /* interval */
       double rtcp_min_time =3D RTCP_MIN_TIME;
       int n;                      /* no. of members for computation */

       /*
        * Very first call at application start-up uses half the min
        * delay for quicker notification while still allowing some time
        * before reporting for randomization and to learn about other
        * sources so the report interval will converge to the correct
        * interval more quickly.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 89]</SPAN>
<A id=3Dpage-90 href=3D"http://tools.ietf.org/html/rfc3550#page-90" =
name=3Dpage-90><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


        */
       if (initial) {
           rtcp_min_time /=3D 2;
       }
       /*
        * Dedicate a fraction of the RTCP bandwidth to senders unless
        * the number of senders is large enough that their share is
        * more than that fraction.
        */
       n =3D members;
       if (senders &lt;=3D members * RTCP_SENDER_BW_FRACTION) {
           if (we_sent) {
               rtcp_bw *=3D RTCP_SENDER_BW_FRACTION;
               n =3D senders;
           } else {
               rtcp_bw *=3D RTCP_RCVR_BW_FRACTION;
               n -=3D senders;
           }
       }

       /*
        * The effective number of sites times the average packet size is
        * the total number of octets sent when each site sends a report.
        * Dividing this by the effective bandwidth gives the time
        * interval over which those packets must be sent in order to
        * meet the bandwidth target, with a minimum enforced.  In that
        * time interval we send one report so this time is also our
        * average time between reports.
        */
       t =3D avg_rtcp_size * n / rtcp_bw;
       if (t &lt; rtcp_min_time) t =3D rtcp_min_time;

       /*
        * To avoid traffic bursts from unintended synchronization with
        * other sites, we then pick our actual next report interval as a
        * random number uniformly distributed between 0.5*t and 1.5*t.
        */
       t =3D t * (drand48() + 0.5);
       t =3D t / COMPENSATION;
       return t;
   }

   void OnExpire(event e,
                 int    members,
                 int    senders,
                 double rtcp_bw,
                 int    we_sent,
                 double *avg_rtcp_size,



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 90]</SPAN>
<A id=3Dpage-91 href=3D"http://tools.ietf.org/html/rfc3550#page-91" =
name=3Dpage-91><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


                 int    *initial,
                 time_tp   tc,
                 time_tp   *tp,
                 int    *pmembers)
   {
       /* This function is responsible for deciding whether to send an
        * RTCP report or BYE packet now, or to reschedule transmission.
        * It is also responsible for updating the pmembers, initial, tp,
        * and avg_rtcp_size state variables.  This function should be
        * called upon expiration of the event timer used by Schedule().
        */

       double t;     /* Interval */
       double tn;    /* Next transmit time */

       /* In the case of a BYE, we use "timer reconsideration" to
        * reschedule the transmission of the BYE if necessary */

       if (TypeOfEvent(e) =3D=3D EVENT_BYE) {
           t =3D rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn =3D *tp + t;
           if (tn &lt;=3D tc) {
               SendBYEPacket(e);
               exit(1);
           } else {
               Schedule(tn, e);
           }

       } else if (TypeOfEvent(e) =3D=3D EVENT_REPORT) {
           t =3D rtcp_interval(members,
                             senders,
                             rtcp_bw,
                             we_sent,
                             *avg_rtcp_size,
                             *initial);
           tn =3D *tp + t;
           if (tn &lt;=3D tc) {
               SendRTCPReport(e);
               *avg_rtcp_size =3D (1./16.)*SentPacketSize(e) +
                   (15./16.)*(*avg_rtcp_size);
               *tp =3D tc;

               /* We must redraw the interval.  Don't reuse the



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 91]</SPAN>
<A id=3Dpage-92 href=3D"http://tools.ietf.org/html/rfc3550#page-92" =
name=3Dpage-92><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


                  one computed above, since its not actually
                  distributed the same, as we are conditioned
                  on it being small enough to cause a packet to
                  be sent */

               t =3D rtcp_interval(members,
                                 senders,
                                 rtcp_bw,
                                 we_sent,
                                 *avg_rtcp_size,
                                 *initial);

               Schedule(t+tc,e);
               *initial =3D 0;
           } else {
               Schedule(tn, e);
           }
           *pmembers =3D members;
       }
   }

   void OnReceive(packet p,
                  event e,
                  int *members,
                  int *pmembers,
                  int *senders,
                  double *avg_rtcp_size,
                  double *tp,
                  double tc,
                  double tn)
   {
       /* What we do depends on whether we have left the group, and are
        * waiting to send a BYE (TypeOfEvent(e) =3D=3D EVENT_BYE) or an =
RTCP
        * report.  p represents the packet that was just received.  */

       if (PacketType(p) =3D=3D PACKET_RTCP_REPORT) {
           if (NewMember(p) &amp;&amp; (TypeOfEvent(e) =3D=3D =
EVENT_REPORT)) {
               AddMember(p);
               *members +=3D 1;
           }
           *avg_rtcp_size =3D (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);
       } else if (PacketType(p) =3D=3D PACKET_RTP) {
           if (NewMember(p) &amp;&amp; (TypeOfEvent(e) =3D=3D =
EVENT_REPORT)) {
               AddMember(p);
               *members +=3D 1;
           }
           if (NewSender(p) &amp;&amp; (TypeOfEvent(e) =3D=3D =
EVENT_REPORT)) {



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 92]</SPAN>
<A id=3Dpage-93 href=3D"http://tools.ietf.org/html/rfc3550#page-93" =
name=3Dpage-93><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


               AddSender(p);
               *senders +=3D 1;
           }
       } else if (PacketType(p) =3D=3D PACKET_BYE) {
           *avg_rtcp_size =3D (1./16.)*ReceivedPacketSize(p) +
               (15./16.)*(*avg_rtcp_size);

           if (TypeOfEvent(e) =3D=3D EVENT_REPORT) {
               if (NewSender(p) =3D=3D FALSE) {
                   RemoveSender(p);
                   *senders -=3D 1;
               }

               if (NewMember(p) =3D=3D FALSE) {
                   RemoveMember(p);
                   *members -=3D 1;
               }

               if (*members &lt; *pmembers) {
                   tn =3D tc +
                       (((double) *members)/(*pmembers))*(tn - tc);
                   *tp =3D tc -
                       (((double) *members)/(*pmembers))*(tc - *tp);

                   /* Reschedule the next report for time tn */

                   Reschedule(tn, e);
                   *pmembers =3D *members;
               }

           } else if (TypeOfEvent(e) =3D=3D EVENT_BYE) {
               *members +=3D 1;
           }
       }
   }
















<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 93]</SPAN>
<A id=3Dpage-94 href=3D"http://tools.ietf.org/html/rfc3550#page-94" =
name=3Dpage-94><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


A.8 Estimating the Interarrival Jitter

   The code fragments below implement the algorithm given in Section
   6.4.1 for calculating an estimate of the statistical variance of the
   RTP data interarrival time to be inserted in the interarrival jitter
   field of reception reports.  The inputs are r-&gt;ts, the timestamp =
from
   the incoming packet, and arrival, the current time in the same units.
   Here s points to state for the source; s-&gt;transit holds the =
relative
   transit time for the previous packet, and s-&gt;jitter holds the
   estimated jitter.  The jitter field of the reception report is
   measured in timestamp units and expressed as an unsigned integer, but
   the jitter estimate is kept in a floating point.  As each data packet
   arrives, the jitter estimate is updated:

      int transit =3D arrival - r-&gt;ts;
      int d =3D transit - s-&gt;transit;
      s-&gt;transit =3D transit;
      if (d &lt; 0) d =3D -d;
      s-&gt;jitter +=3D (1./16.) * ((double)d - s-&gt;jitter);

   When a reception report block (to which rr points) is generated for
   this member, the current jitter estimate is returned:

      rr-&gt;jitter =3D (u_int32) s-&gt;jitter;

   Alternatively, the jitter estimate can be kept as an integer, but
   scaled to reduce round-off error.  The calculation is the same except
   for the last line:

      s-&gt;jitter +=3D d - ((s-&gt;jitter + 8) &gt;&gt; 4);

   In this case, the estimate is sampled for the reception report as:

      rr-&gt;jitter =3D s-&gt;jitter &gt;&gt; 4;

















<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 94]</SPAN>
<A id=3Dpage-95 href=3D"http://tools.ietf.org/html/rfc3550#page-95" =
name=3Dpage-95><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


Appendix B - Changes from <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>

   Most of this RFC is identical to <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>.  There are no =
changes in
   the packet formats on the wire, only changes to the rules and
   algorithms governing how the protocol is used.  The biggest change is
   an enhancement to the scalable timer algorithm for calculating when
   to send RTCP packets:

   o  The algorithm for calculating the RTCP transmission interval
      specified in Sections 6.2 and 6.3 and illustrated in Appendix A.7
      is augmented to include "reconsideration" to minimize transmission
      in excess of the intended rate when many participants join a
      session simultaneously, and "reverse reconsideration" to reduce
      the incidence and duration of false participant timeouts when the
      number of participants drops rapidly.  Reverse reconsideration is
      also used to possibly shorten the delay before sending RTCP SR
      when transitioning from passive receiver to active sender mode.

   o  <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.3.7">Section =
6.3.7</A> specifies new rules controlling when an RTCP BYE
      packet should be sent in order to avoid a flood of packets when
      many participants leave a session simultaneously.

   o  The requirement to retain state for inactive participants for a
      period long enough to span typical network partitions was removed
      from <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2.1">Section =
6.2.1</A>.  In a session where many participants join for
      a brief time and fail to send BYE, this requirement would cause a
      significant overestimate of the number of participants.  The
      reconsideration algorithm added in this revision compensates for
      the large number of new participants joining simultaneously when a
      partition heals.

   It should be noted that these enhancements only have a significant
   effect when the number of session participants is large (thousands)
   and most of the participants join or leave at the same time.  This
   makes testing in a live network difficult.  However, the algorithm
   was subjected to a thorough analysis and simulation to verify its
   performance.  Furthermore, the enhanced algorithm was designed to
   interoperate with the algorithm in <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A> such that the =
degree of
   reduction in excess RTCP bandwidth during a step join is proportional
   to the fraction of participants that implement the enhanced
   algorithm.  Interoperation of the two algorithms has been verified
   experimentally on live networks.

   Other functional changes were:

   o  <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2.1">Section =
6.2.1</A> specifies that implementations may store only a
      sampling of the participants' SSRC identifiers to allow scaling to
      very large sessions.  Algorithms are specified in <A =
href=3D"http://tools.ietf.org/html/rfc2762">RFC 2762</A> [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-21">21</A>].



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 95]</SPAN>
<A id=3Dpage-96 href=3D"http://tools.ietf.org/html/rfc3550#page-96" =
name=3Dpage-96><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  In <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A> =
it is specified that RTCP sender and non-sender
      bandwidths may be set as separate parameters of the session rather
      than a strict percentage of the session bandwidth, and may be set
      to zero.  The requirement that RTCP was mandatory for RTP sessions
      using IP multicast was relaxed.  However, a clarification was also
      added that turning off RTCP is NOT RECOMMENDED.

   o  In Sections 6.2, 6.3.1 and Appendix A.7, it is specified that the
      fraction of participants below which senders get dedicated RTCP
      bandwidth changes from the fixed 1/4 to a ratio based on the RTCP
      sender and non-sender bandwidth parameters when those are given.
      The condition that no bandwidth is dedicated to senders when there
      are no senders was removed since that is expected to be a
      transitory state.  It also keeps non-senders from using sender
      RTCP bandwidth when that is not intended.

   o  Also in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A> =
it is specified that the minimum RTCP interval
      may be scaled to smaller values for high bandwidth sessions, and
      that the initial RTCP delay may be set to zero for unicast
      sessions.

   o  Timing out a participant is to be based on inactivity for a number
      of RTCP report intervals calculated using the receiver RTCP
      bandwidth fraction even for active senders.

   o  Sections 7.2 and 7.3 specify that translators and mixers should
      send BYE packets for the sources they are no longer forwarding.

   o  Rule changes for layered encodings are defined in Sections 2.4,
      6.3.9, 8.3 and 11.  In the last of these, it is noted that the
      address and port assignment rule conflicts with the SDP
      specification, <A href=3D"http://tools.ietf.org/html/rfc2327">RFC =
2327</A> [<A href=3D"http://tools.ietf.org/html/rfc3550#ref-15">15</A>], =
but it is intended that this
      restriction will be relaxed in a revision of <A =
href=3D"http://tools.ietf.org/html/rfc2327">RFC 2327</A>.

   o  The convention for using even/odd port pairs for RTP and RTCP in
      <A href=3D"http://tools.ietf.org/html/rfc3550#section-11">Section =
11</A> was clarified to refer to destination ports.  The
      requirement to use an even/odd port pair was removed if the two
      ports are specified explicitly.  For unicast RTP sessions,
      distinct port pairs may be used for the two ends (Sections 3, 7.1
      and 11).

   o  A new <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-10">Section 10</A> =
was added to explain the requirement for
      congestion control in applications using RTP.

   o  In <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section 8.2</A>, =
the requirement that a new SSRC identifier MUST be
      chosen whenever the source transport address is changed has been
      relaxed to say that a new SSRC identifier MAY be chosen.
      Correspondingly, it was clarified that an implementation MAY



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 96]</SPAN>
<A id=3Dpage-97 href=3D"http://tools.ietf.org/html/rfc3550#page-97" =
name=3Dpage-97><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      choose to keep packets from the new source address rather than the
      existing source address when an SSRC collision occurs between two
      other participants, and SHOULD do so for applications such as
      telephony in which some sources such as mobile entities may change
      addresses during the course of an RTP session.

   o  An indentation bug in the <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A> printing of the =
pseudo-code for
      the collision detection and resolution algorithm in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-8.2">Section 8.2</A>
      has been corrected by translating the syntax to pseudo C language,
      and the algorithm has been modified to remove the restriction that
      both RTP and RTCP must be sent from the same source port number.

   o  The description of the padding mechanism for RTCP packets was
      clarified and it is specified that padding MUST only be applied to
      the last packet of a compound RTCP packet.

   o  In Section A.1, initialization of base_seq was corrected to be seq
      rather than seq - 1, and the text was corrected to say the bad
      sequence number plus 1 is stored.  The initialization of max_seq
      and other variables for the algorithm was separated from the text
      to make clear that this initialization must be done in addition to
      calling the init_seq() function (and a few words lost in <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>
      when processing the document from source to output form were
      restored).

   o  Clamping of number of packets lost in Section A.3 was corrected to
      use both positive and negative limits.

   o  The specification of "relative" NTP timestamp in the RTCP SR
      section now defines these timestamps to be based on the most
      common system-specific clock, such as system uptime, rather than
      on session elapsed time which would not be the same for multiple
      applications started on the same machine at different times.

   Non-functional changes:

   o  It is specified that a receiver MUST ignore packets with payload
      types it does not understand.

   o  In Fig. 2, the floating point NTP timestamp value was corrected,
      some missing leading zeros were added in a hex number, and the UTC
      timezone was specified.

   o  The inconsequence of NTP timestamps wrapping around in the year
      2036 is explained.






<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 97]</SPAN>
<A id=3Dpage-98 href=3D"http://tools.ietf.org/html/rfc3550#page-98" =
name=3Dpage-98><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   o  The policy for registration of RTCP packet types and SDES types
      was clarified in a new <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-15">Section 15</A>, =
IANA Considerations.  The
      suggestion that experimenters register the numbers they need and
      then unregister those which prove to be unneeded has been removed
      in favor of using APP and PRIV.  Registration of profile names was
      also specified.

   o  The reference for the UTF-8 character set was changed from an
      X/Open Preliminary Specification to be <A =
href=3D"http://tools.ietf.org/html/rfc2279">RFC 2279</A>.

   o  The reference for <A =
href=3D"http://tools.ietf.org/html/rfc1597">RFC 1597</A> was updated to =
<A href=3D"http://tools.ietf.org/html/rfc1918">RFC 1918</A> and the
      reference for <A href=3D"http://tools.ietf.org/html/rfc2543">RFC =
2543</A> was updated to <A =
href=3D"http://tools.ietf.org/html/rfc3261">RFC 3261</A>.

   o  The last paragraph of the introduction in <A =
href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>, which
      cautioned implementors to limit deployment in the Internet, was
      removed because it was deemed no longer relevant.

   o  A non-normative note regarding the use of RTP with Source-Specific
      Multicast (SSM) was added in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6">Section 6</A>.

   o  The definition of "RTP session" in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-3">Section 3</A> was =
expanded to
      acknowledge that a single session may use multiple destination
      transport addresses (as was always the case for a translator or
      mixer) and to explain that the distinguishing feature of an RTP
      session is that each corresponds to a separate SSRC identifier
      space.  A new definition of "multimedia session" was added to
      reduce confusion about the word "session".

   o  The meaning of "sampling instant" was explained in more detail as
      part of the definition of the timestamp field of the RTP header in
      <A href=3D"http://tools.ietf.org/html/rfc3550#section-5.1">Section =
5.1</A>.

   o  Small clarifications of the text have been made in several places,
      some in response to questions from readers.  In particular:

      -  In <A href=3D"http://tools.ietf.org/html/rfc1889">RFC 1889</A>, =
the first five words of the second sentence of
         <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-2.2">Section 2.2</A> =
were lost in processing the document from source to
         output form, but are now restored.

      -  A definition for "RTP media type" was added in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-3">Section 3</A> to
         allow the explanation of multiplexing RTP sessions in Section
         5.2 to be more clear regarding the multiplexing of multiple
         media.  That section also now explains that multiplexing
         multiple sources of the same medium based on SSRC identifiers
         may be appropriate and is the norm for multicast sessions.

      -  The definition for "non-RTP means" was expanded to include
         examples of other protocols constituting non-RTP means.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 98]</SPAN>
<A id=3Dpage-99 href=3D"http://tools.ietf.org/html/rfc3550#page-99" =
name=3Dpage-99><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      -  The description of the session bandwidth parameter is expanded
         in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.2">Section 6.2</A>, =
including a clarification that the control
         traffic bandwidth is in addition to the session bandwidth for
         the data traffic.

      -  The effect of varying packet duration on the jitter calculation
         was explained in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.4.4">Section =
6.4.4</A>.

      -  The method for terminating and padding a sequence of SDES items
         was clarified in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5">Section 6.5</A>.

      -  IPv6 address examples were added in the description of SDES
         CNAME in <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-6.5.1">Section =
6.5.1</A>, and "example.com" was used in place of
         other example domain names.

      -  The Security section added a formal reference to IPSEC now that
         it is available, and says that the confidentiality method
         defined in this specification is primarily to codify existing
         practice.  It is RECOMMENDED that stronger encryption
         algorithms such as Triple-DES be used in place of the default
         algorithm, and noted that the SRTP profile based on AES will be
         the correct choice in the future.  A caution about the weakness
         of the RTP header as an initialization vector was added.  It
         was also noted that payload-only encryption is necessary to
         allow for header compression.

      -  The method for partial encryption of RTCP was clarified; in
         particular, SDES CNAME is carried in only one part when the
         compound RTCP packet is split.

      -  It is clarified that only one compound RTCP packet should be
         sent per reporting interval and that if there are too many
         active sources for the reports to fit in the MTU, then a subset
         of the sources should be selected round-robin over multiple
         intervals.

      -  A note was added in Appendix A.1 that packets may be saved
         during RTP header validation and delivered upon success.

      -  <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-7.3">Section 7.3</A> =
now explains that a mixer aggregating SDES packets
         uses more RTCP bandwidth due to longer packets, and a mixer
         passing through RTCP naturally sends packets at higher than the
         single source rate, but both behaviors are valid.

      -  <A =
href=3D"http://tools.ietf.org/html/rfc3550#section-13">Section 13</A> =
clarifies that an RTP application may use multiple
         profiles but typically only one in a given session.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
         [Page 99]</SPAN>
<A id=3Dpage-100 href=3D"http://tools.ietf.org/html/rfc3550#page-100" =
name=3Dpage-100><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


      -  The terms MUST, SHOULD, MAY, etc. are used as defined in <A =
href=3D"http://tools.ietf.org/html/rfc2119">RFC</A>
         <A href=3D"http://tools.ietf.org/html/rfc2119">2119</A>.

      -  The bibliography was divided into normative and informative
         references.

References

Normative References

   [<A id=3Dref-1 name=3Dref-1>1</A>]  Schulzrinne, H. and S. Casner, =
"RTP Profile for Audio and Video
        Conferences with Minimal Control", <A =
href=3D"http://tools.ietf.org/html/rfc3551">RFC 3551</A>, July 2003.

   [<A id=3Dref-2 name=3Dref-2>2</A>]  Bradner, S., "Key Words for Use =
in RFCs to Indicate Requirement
        Levels", <A href=3D"http://tools.ietf.org/html/bcp14">BCP =
14</A>, <A href=3D"http://tools.ietf.org/html/rfc2119">RFC 2119</A>, =
March 1997.

   [<A id=3Dref-3 name=3Dref-3>3</A>]  Postel, J., "Internet Protocol", =
STD 5, <A href=3D"http://tools.ietf.org/html/rfc791">RFC 791</A>, =
September 1981.

   [<A id=3Dref-4 name=3Dref-4>4</A>]  Mills, D., "Network Time Protocol =
(Version 3) Specification,
        Implementation and Analysis", <A =
href=3D"http://tools.ietf.org/html/rfc1305">RFC 1305</A>, March 1992.

   [<A id=3Dref-5 name=3Dref-5>5</A>]  Yergeau, F., "UTF-8, a =
Transformation Format of ISO 10646", <A =
href=3D"http://tools.ietf.org/html/rfc2279">RFC</A>
        <A href=3D"http://tools.ietf.org/html/rfc2279">2279</A>, January =
1998.

   [<A id=3Dref-6 name=3Dref-6>6</A>]  Mockapetris, P., "Domain Names - =
Concepts and Facilities", STD
        13, <A href=3D"http://tools.ietf.org/html/rfc1034">RFC 1034</A>, =
November 1987.

   [<A id=3Dref-7 name=3Dref-7>7</A>]  Mockapetris, P., "Domain Names - =
Implementation and
        Specification", STD 13, <A =
href=3D"http://tools.ietf.org/html/rfc1035">RFC 1035</A>, November 1987.

   [<A id=3Dref-8 name=3Dref-8>8</A>]  Braden, R., "Requirements for =
Internet Hosts - Application and
        Support", STD 3, <A =
href=3D"http://tools.ietf.org/html/rfc1123">RFC 1123</A>, October 1989.

   [<A id=3Dref-9 name=3Dref-9>9</A>]  Resnick, P., "Internet Message =
Format", <A href=3D"http://tools.ietf.org/html/rfc2822">RFC 2822</A>, =
April 2001.

Informative References

   [<A id=3Dref-10 name=3Dref-10>10</A>] Clark, D. and D. Tennenhouse, =
"Architectural Considerations for
        a New Generation of Protocols," in SIGCOMM Symposium on
        Communications Architectures and Protocols , (Philadelphia,
        Pennsylvania), pp. 200--208, IEEE Computer Communications
        Review, Vol. 20(4), September 1990.

   [<A id=3Dref-11 name=3Dref-11>11</A>] Schulzrinne, H., "Issues in =
designing a transport protocol for
        audio and video conferences and other multiparticipant real-time
        applications." expired Internet Draft, October 1993.





<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
        [Page 100]</SPAN>
<A id=3Dpage-101 href=3D"http://tools.ietf.org/html/rfc3550#page-101" =
name=3Dpage-101><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   [<A id=3Dref-12 name=3Dref-12>12</A>] Comer, D., Internetworking with =
TCP/IP , vol. 1.  Englewood
        Cliffs, New Jersey: Prentice Hall, 1991.

   [<A id=3Dref-13 name=3Dref-13>13</A>] Rosenberg, J., Schulzrinne, H., =
Camarillo, G., Johnston, A.,
        Peterson, J., Sparks, R., Handley, M. and E. Schooler, "SIP:
        Session Initiation Protocol", <A =
href=3D"http://tools.ietf.org/html/rfc3261">RFC 3261</A>, June 2002.

   [<A id=3Dref-14 name=3Dref-14>14</A>] International Telecommunication =
Union, "Visual telephone systems
        and equipment for local area networks which provide a non-
        guaranteed quality of service", Recommendation H.323,
        Telecommunication Standardization Sector of ITU, Geneva,
        Switzerland, July 2003.

   [<A id=3Dref-15 name=3Dref-15>15</A>] Handley, M. and V. Jacobson, =
"SDP: Session Description
        Protocol", <A href=3D"http://tools.ietf.org/html/rfc2327">RFC =
2327</A>, April 1998.

   [<A id=3Dref-16 name=3Dref-16>16</A>] Schulzrinne, H., Rao, A. and R. =
Lanphier, "Real Time Streaming
        Protocol (RTSP)", <A =
href=3D"http://tools.ietf.org/html/rfc2326">RFC 2326</A>, April 1998.

   [<A id=3Dref-17 name=3Dref-17>17</A>] Eastlake 3rd, D., Crocker, S. =
and J. Schiller, "Randomness
        Recommendations for Security", <A =
href=3D"http://tools.ietf.org/html/rfc1750">RFC 1750</A>, December 1994.

   [<A id=3Dref-18 name=3Dref-18>18</A>] Bolot, J.-C., Turletti, T. and =
I. Wakeman, "Scalable Feedback
        Control for Multicast Video Distribution in the Internet", in
        SIGCOMM Symposium on Communications Architectures and Protocols,
        (London, England), pp. 58--67, ACM, August 1994.

   [<A id=3Dref-19 name=3Dref-19>19</A>] Busse, I., Deffner, B. and H. =
Schulzrinne, "Dynamic QoS Control
        of Multimedia Applications Based on RTP", Computer
        Communications , vol. 19, pp. 49--58, January 1996.

   [<A id=3Dref-20 name=3Dref-20>20</A>] Floyd, S. and V. Jacobson, "The =
Synchronization of Periodic
        Routing Messages", in SIGCOMM Symposium on Communications
        Architectures and Protocols (D. P. Sidhu, ed.), (San Francisco,
        California), pp. 33--44, ACM, September 1993.  Also in [<A =
href=3D"http://tools.ietf.org/html/rfc3550#ref-34">34</A>].

   [<A id=3Dref-21 name=3Dref-21>21</A>] Rosenberg, J. and H. =
Schulzrinne, "Sampling of the Group
        Membership in RTP", <A =
href=3D"http://tools.ietf.org/html/rfc2762">RFC 2762</A>, February 2000.

   [<A id=3Dref-22 name=3Dref-22>22</A>] Cadzow, J., Foundations of =
Digital Signal Processing and Data
        Analysis New York, New York: Macmillan, 1987.

   [<A id=3Dref-23 name=3Dref-23>23</A>] Hinden, R. and S. Deering, =
"Internet Protocol Version 6 (IPv6)
        Addressing Architecture", <A =
href=3D"http://tools.ietf.org/html/rfc3513">RFC 3513</A>, April 2003.

   [<A id=3Dref-24 name=3Dref-24>24</A>] Rekhter, Y., Moskowitz, B., =
Karrenberg, D., de Groot, G. and E.
        Lear, "Address Allocation for Private Internets", <A =
href=3D"http://tools.ietf.org/html/rfc1918">RFC 1918</A>,
        February 1996.



<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
        [Page 101]</SPAN>
<A id=3Dpage-102 href=3D"http://tools.ietf.org/html/rfc3550#page-102" =
name=3Dpage-102><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


   [<A id=3Dref-25 name=3Dref-25>25</A>] Lear, E., Fair, E., Crocker, D. =
and T. Kessler, "Network 10
        Considered Harmful (Some Practices Shouldn't be Codified)", <A =
href=3D"http://tools.ietf.org/html/rfc1627">RFC</A>
        <A href=3D"http://tools.ietf.org/html/rfc1627">1627</A>, July =
1994.

   [<A id=3Dref-26 name=3Dref-26>26</A>] Feller, W., An Introduction to =
Probability Theory and its
        Applications, vol. 1.  New York, New York: John Wiley and Sons,
        third ed., 1968.

   [<A id=3Dref-27 name=3Dref-27>27</A>] Kent, S. and R. Atkinson, =
"Security Architecture for the
        Internet Protocol", <A =
href=3D"http://tools.ietf.org/html/rfc2401">RFC 2401</A>, November 1998.

   [<A id=3Dref-28 name=3Dref-28>28</A>] Baugher, M., Blom, R., Carrara, =
E., McGrew, D., Naslund, M.,
        Norrman, K. and D. Oran, "Secure Real-time Transport Protocol",
        Work in Progress, April 2003.

   [<A id=3Dref-29 name=3Dref-29>29</A>] Balenson, D., "Privacy =
Enhancement for Internet Electronic Mail:
        Part III", <A href=3D"http://tools.ietf.org/html/rfc1423">RFC =
1423</A>, February 1993.

   [<A id=3Dref-30 name=3Dref-30>30</A>] Voydock, V. and S. Kent, =
"Security Mechanisms in High-Level
        Network Protocols", ACM Computing Surveys, vol. 15, pp. 135-171,
        June 1983.

   [<A id=3Dref-31 name=3Dref-31>31</A>] Floyd, S., "Congestion Control =
Principles", <A href=3D"http://tools.ietf.org/html/bcp41">BCP 41</A>, <A =
href=3D"http://tools.ietf.org/html/rfc2914">RFC 2914</A>,
        September 2000.

   [<A id=3Dref-32 name=3Dref-32>32</A>] Rivest, R., "The MD5 =
Message-Digest Algorithm", <A =
href=3D"http://tools.ietf.org/html/rfc1321">RFC 1321</A>, April
        1992.

   [<A id=3Dref-33 name=3Dref-33>33</A>] Stubblebine, S., "Security =
Services for Multimedia
        Conferencing", in 16th National Computer Security Conference,
        (Baltimore, Maryland), pp. 391--395, September 1993.

   [<A id=3Dref-34 name=3Dref-34>34</A>] Floyd, S. and V. Jacobson, "The =
Synchronization of Periodic
        Routing Messages", IEEE/ACM Transactions on Networking, vol. 2,
        pp. 122--136, April 1994.
















<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
        [Page 102]</SPAN>
<A id=3Dpage-103 href=3D"http://tools.ietf.org/html/rfc3550#page-103" =
name=3Dpage-103><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


Authors' Addresses

   Henning Schulzrinne
   Department of Computer Science
   Columbia University
   1214 Amsterdam Avenue
   New York, NY 10027
   United States

   EMail: schulzrinne@cs.columbia.edu


   Stephen L. Casner
   Packet Design
   3400 Hillview Avenue, Building 3
   Palo Alto, CA 94304
   United States

   EMail: casner@acm.org


   Ron Frederick
   Blue Coat Systems Inc.
   650 Almanor Avenue
   Sunnyvale, CA 94085
   United States

   EMail: ronf@bluecoat.com


   Van Jacobson
   Packet Design
   3400 Hillview Avenue, Building 3
   Palo Alto, CA 94304
   United States

   EMail: van@packetdesign.com














<SPAN class=3Dgrey>Schulzrinne, et al.         Standards Track           =
        [Page 103]</SPAN>
<A id=3Dpage-104 href=3D"http://tools.ietf.org/html/rfc3550#page-104" =
name=3Dpage-104><SPAN class=3Dbreak></SPAN></A>
<SPAN class=3Dgrey><A href=3D"http://tools.ietf.org/html/rfc3550">RFC =
3550</A>                          RTP                          July =
2003</SPAN>


Full Copyright Statement

   Copyright (C) The Internet Society (2003).  All Rights Reserved.

   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.



















Schulzrinne, et al.         Standards Track                   [Page 104]
<SPAN class=3Dbreak></SPAN>

</PRE><BR><SMALL><SMALL>Html markup produced by rfcmarkup 1.31, =
available from=20
<A=20
href=3D"http://tools.ietf.org/tools/rfcmarkup/">http://tools.ietf.org/too=
ls/rfcmarkup/</A>=20
</SMALL></SMALL></BODY></HTML>

------=_NextPart_000_0002_01C6F7DF.743F21E0
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: http://tools.ietf.org/js/MochiKit.js

/***=0A=
=0A=
    MochiKit.MochiKit 1.3.1 : PACKED VERSION=0A=
=0A=
    THIS FILE IS AUTOMATICALLY GENERATED.  If creating patches, please=0A=
    diff against the source tree, not this file.=0A=
=0A=
    See <http://mochikit.com/> for documentation, downloads, license, =
etc.=0A=
=0A=
    (c) 2005 Bob Ippolito.  All rights Reserved.=0A=
=0A=
***/=0A=
=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Base");=0A=
}=0A=
if(typeof (MochiKit)=3D=3D"undefined"){=0A=
MochiKit=3D{};=0A=
}=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
MochiKit.Base=3D{};=0A=
}=0A=
MochiKit.Base.VERSION=3D"1.3.1";=0A=
MochiKit.Base.NAME=3D"MochiKit.Base";=0A=
MochiKit.Base.update=3Dfunction(_1,_2){=0A=
if(_1=3D=3D=3Dnull){=0A=
_1=3D{};=0A=
}=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(typeof (o)!=3D"undefined"&&o!=3D=3Dnull){=0A=
for(var k in o){=0A=
_1[k]=3Do[k];=0A=
}=0A=
}=0A=
}=0A=
return _1;=0A=
};=0A=
MochiKit.Base.update(MochiKit.Base,{__repr__:function(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
},toString:function(){=0A=
return this.__repr__();=0A=
},counter:function(n){=0A=
if(arguments.length=3D=3D=3D0){=0A=
n=3D1;=0A=
}=0A=
return function(){=0A=
return n++;=0A=
};=0A=
},clone:function(_7){=0A=
var me=3Darguments.callee;=0A=
if(arguments.length=3D=3D1){=0A=
me.prototype=3D_7;=0A=
return new me();=0A=
}=0A=
},flattenArguments:function(_9){=0A=
var res=3D[];=0A=
var m=3DMochiKit.Base;=0A=
var _12=3Dm.extend(null,arguments);=0A=
while(_12.length){=0A=
var o=3D_12.shift();=0A=
if(o&&typeof (o)=3D=3D"object"&&typeof (o.length)=3D=3D"number"){=0A=
for(var i=3Do.length-1;i>=3D0;i--){=0A=
_12.unshift(o[i]);=0A=
}=0A=
}else{=0A=
res.push(o);=0A=
}=0A=
}=0A=
return res;=0A=
},extend:function(_13,obj,_15){=0A=
if(!_15){=0A=
_15=3D0;=0A=
}=0A=
if(obj){=0A=
var l=3Dobj.length;=0A=
if(typeof (l)!=3D"number"){=0A=
if(typeof (MochiKit.Iter)!=3D"undefined"){=0A=
obj=3DMochiKit.Iter.list(obj);=0A=
l=3Dobj.length;=0A=
}else{=0A=
throw new TypeError("Argument not an array-like and MochiKit.Iter not =
present");=0A=
}=0A=
}=0A=
if(!_13){=0A=
_13=3D[];=0A=
}=0A=
for(var i=3D_15;i<l;i++){=0A=
_13.push(obj[i]);=0A=
}=0A=
}=0A=
return _13;=0A=
},updatetree:function(_17,obj){=0A=
if(_17=3D=3D=3Dnull){=0A=
_17=3D{};=0A=
}=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(typeof (o)!=3D"undefined"&&o!=3D=3Dnull){=0A=
for(var k in o){=0A=
var v=3Do[k];=0A=
if(typeof (_17[k])=3D=3D"object"&&typeof (v)=3D=3D"object"){=0A=
arguments.callee(_17[k],v);=0A=
}else{=0A=
_17[k]=3Dv;=0A=
}=0A=
}=0A=
}=0A=
}=0A=
return _17;=0A=
},setdefault:function(_19,obj){=0A=
if(_19=3D=3D=3Dnull){=0A=
_19=3D{};=0A=
}=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
for(var k in o){=0A=
if(!(k in _19)){=0A=
_19[k]=3Do[k];=0A=
}=0A=
}=0A=
}=0A=
return _19;=0A=
},keys:function(obj){=0A=
var _20=3D[];=0A=
for(var _21 in obj){=0A=
_20.push(_21);=0A=
}=0A=
return _20;=0A=
},items:function(obj){=0A=
var _22=3D[];=0A=
var e;=0A=
for(var _24 in obj){=0A=
var v;=0A=
try{=0A=
v=3Dobj[_24];=0A=
}=0A=
catch(e){=0A=
continue;=0A=
}=0A=
_22.push([_24,v]);=0A=
}=0A=
return _22;=0A=
},_newNamedError:function(_25,_26,_27){=0A=
_27.prototype=3Dnew MochiKit.Base.NamedError(_25.NAME+"."+_26);=0A=
_25[_26]=3D_27;=0A=
},operator:{truth:function(a){=0A=
return !!a;=0A=
},lognot:function(a){=0A=
return !a;=0A=
},identity:function(a){=0A=
return a;=0A=
},not:function(a){=0A=
return ~a;=0A=
},neg:function(a){=0A=
return -a;=0A=
},add:function(a,b){=0A=
return a+b;=0A=
},sub:function(a,b){=0A=
return a-b;=0A=
},div:function(a,b){=0A=
return a/b;=0A=
},mod:function(a,b){=0A=
return a%b;=0A=
},mul:function(a,b){=0A=
return a*b;=0A=
},and:function(a,b){=0A=
return a&b;=0A=
},or:function(a,b){=0A=
return a|b;=0A=
},xor:function(a,b){=0A=
return a^b;=0A=
},lshift:function(a,b){=0A=
return a<<b;=0A=
},rshift:function(a,b){=0A=
return a>>b;=0A=
},zrshift:function(a,b){=0A=
return a>>>b;=0A=
},eq:function(a,b){=0A=
return a=3D=3Db;=0A=
},ne:function(a,b){=0A=
return a!=3Db;=0A=
},gt:function(a,b){=0A=
return a>b;=0A=
},ge:function(a,b){=0A=
return a>=3Db;=0A=
},lt:function(a,b){=0A=
return a<b;=0A=
},le:function(a,b){=0A=
return a<=3Db;=0A=
},ceq:function(a,b){=0A=
return MochiKit.Base.compare(a,b)=3D=3D=3D0;=0A=
},cne:function(a,b){=0A=
return MochiKit.Base.compare(a,b)!=3D=3D0;=0A=
},cgt:function(a,b){=0A=
return MochiKit.Base.compare(a,b)=3D=3D1;=0A=
},cge:function(a,b){=0A=
return MochiKit.Base.compare(a,b)!=3D-1;=0A=
},clt:function(a,b){=0A=
return MochiKit.Base.compare(a,b)=3D=3D-1;=0A=
},cle:function(a,b){=0A=
return MochiKit.Base.compare(a,b)!=3D1;=0A=
},logand:function(a,b){=0A=
return a&&b;=0A=
},logor:function(a,b){=0A=
return a||b;=0A=
},contains:function(a,b){=0A=
return b in a;=0A=
}},forwardCall:function(_30){=0A=
return function(){=0A=
return this[_30].apply(this,arguments);=0A=
};=0A=
},itemgetter:function(_31){=0A=
return function(arg){=0A=
return arg[_31];=0A=
};=0A=
},typeMatcher:function(){=0A=
var _33=3D{};=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
var typ=3Darguments[i];=0A=
_33[typ]=3Dtyp;=0A=
}=0A=
return function(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
if(!(typeof (arguments[i]) in _33)){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
};=0A=
},isNull:function(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
if(arguments[i]!=3D=3Dnull){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},isUndefinedOrNull:function(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(!(typeof (o)=3D=3D"undefined"||o=3D=3D=3Dnull)){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},isEmpty:function(obj){=0A=
return !MochiKit.Base.isNotEmpty.apply(this,arguments);=0A=
},isNotEmpty:function(obj){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(!(o&&o.length)){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},isArrayLike:function(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
var typ=3Dtypeof (o);=0A=
if((typ!=3D"object"&&!(typ=3D=3D"function"&&typeof =
(o.item)=3D=3D"function"))||o=3D=3D=3Dnull||typeof =
(o.length)!=3D"number"){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},isDateLike:function(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(typeof (o)!=3D"object"||o=3D=3D=3Dnull||typeof =
(o.getTime)!=3D"function"){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},xmap:function(fn){=0A=
if(fn=3D=3D=3Dnull){=0A=
return MochiKit.Base.extend(null,arguments,1);=0A=
}=0A=
var _36=3D[];=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
_36.push(fn(arguments[i]));=0A=
}=0A=
return _36;=0A=
},map:function(fn,lst){=0A=
var m=3DMochiKit.Base;=0A=
var itr=3DMochiKit.Iter;=0A=
var _39=3Dm.isArrayLike;=0A=
if(arguments.length<=3D2){=0A=
if(!_39(lst)){=0A=
if(itr){=0A=
lst=3Ditr.list(lst);=0A=
if(fn=3D=3D=3Dnull){=0A=
return lst;=0A=
}=0A=
}else{=0A=
throw new TypeError("Argument not an array-like and MochiKit.Iter not =
present");=0A=
}=0A=
}=0A=
if(fn=3D=3D=3Dnull){=0A=
return m.extend(null,lst);=0A=
}=0A=
var _40=3D[];=0A=
for(var i=3D0;i<lst.length;i++){=0A=
_40.push(fn(lst[i]));=0A=
}=0A=
return _40;=0A=
}else{=0A=
if(fn=3D=3D=3Dnull){=0A=
fn=3DArray;=0A=
}=0A=
var _41=3Dnull;=0A=
for(i=3D1;i<arguments.length;i++){=0A=
if(!_39(arguments[i])){=0A=
if(itr){=0A=
return itr.list(itr.imap.apply(null,arguments));=0A=
}else{=0A=
throw new TypeError("Argument not an array-like and MochiKit.Iter not =
present");=0A=
}=0A=
}=0A=
var l=3Darguments[i].length;=0A=
if(_41=3D=3D=3Dnull||_41>l){=0A=
_41=3Dl;=0A=
}=0A=
}=0A=
_40=3D[];=0A=
for(i=3D0;i<_41;i++){=0A=
var _42=3D[];=0A=
for(var j=3D1;j<arguments.length;j++){=0A=
_42.push(arguments[j][i]);=0A=
}=0A=
_40.push(fn.apply(this,_42));=0A=
}=0A=
return _40;=0A=
}=0A=
},xfilter:function(fn){=0A=
var _44=3D[];=0A=
if(fn=3D=3D=3Dnull){=0A=
fn=3DMochiKit.Base.operator.truth;=0A=
}=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var o=3Darguments[i];=0A=
if(fn(o)){=0A=
_44.push(o);=0A=
}=0A=
}=0A=
return _44;=0A=
},filter:function(fn,lst,_45){=0A=
var _46=3D[];=0A=
var m=3DMochiKit.Base;=0A=
if(!m.isArrayLike(lst)){=0A=
if(MochiKit.Iter){=0A=
lst=3DMochiKit.Iter.list(lst);=0A=
}else{=0A=
throw new TypeError("Argument not an array-like and MochiKit.Iter not =
present");=0A=
}=0A=
}=0A=
if(fn=3D=3D=3Dnull){=0A=
fn=3Dm.operator.truth;=0A=
}=0A=
if(typeof (Array.prototype.filter)=3D=3D"function"){=0A=
return Array.prototype.filter.call(lst,fn,_45);=0A=
}else{=0A=
if(typeof (_45)=3D=3D"undefined"||_45=3D=3D=3Dnull){=0A=
for(var i=3D0;i<lst.length;i++){=0A=
var o=3Dlst[i];=0A=
if(fn(o)){=0A=
_46.push(o);=0A=
}=0A=
}=0A=
}else{=0A=
for(i=3D0;i<lst.length;i++){=0A=
o=3Dlst[i];=0A=
if(fn.call(_45,o)){=0A=
_46.push(o);=0A=
}=0A=
}=0A=
}=0A=
}=0A=
return _46;=0A=
},_wrapDumbFunction:function(_47){=0A=
return function(){=0A=
switch(arguments.length){=0A=
case 0:=0A=
return _47();=0A=
case 1:=0A=
return _47(arguments[0]);=0A=
case 2:=0A=
return _47(arguments[0],arguments[1]);=0A=
case 3:=0A=
return _47(arguments[0],arguments[1],arguments[2]);=0A=
}=0A=
var _48=3D[];=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
_48.push("arguments["+i+"]");=0A=
}=0A=
return eval("(func("+_48.join(",")+"))");=0A=
};=0A=
},method:function(_49,_50){=0A=
var m=3DMochiKit.Base;=0A=
return m.bind.apply(this,m.extend([_50,_49],arguments,2));=0A=
},bind:function(_51,_52){=0A=
if(typeof (_51)=3D=3D"string"){=0A=
_51=3D_52[_51];=0A=
}=0A=
var _53=3D_51.im_func;=0A=
var _54=3D_51.im_preargs;=0A=
var _55=3D_51.im_self;=0A=
var m=3DMochiKit.Base;=0A=
if(typeof (_51)=3D=3D"function"&&typeof (_51.apply)=3D=3D"undefined"){=0A=
_51=3Dm._wrapDumbFunction(_51);=0A=
}=0A=
if(typeof (_53)!=3D"function"){=0A=
_53=3D_51;=0A=
}=0A=
if(typeof (_52)!=3D"undefined"){=0A=
_55=3D_52;=0A=
}=0A=
if(typeof (_54)=3D=3D"undefined"){=0A=
_54=3D[];=0A=
}else{=0A=
_54=3D_54.slice();=0A=
}=0A=
m.extend(_54,arguments,2);=0A=
var _56=3Dfunction(){=0A=
var _57=3Darguments;=0A=
var me=3Darguments.callee;=0A=
if(me.im_preargs.length>0){=0A=
_57=3Dm.concat(me.im_preargs,_57);=0A=
}=0A=
var _52=3Dme.im_self;=0A=
if(!_52){=0A=
_52=3Dthis;=0A=
}=0A=
return me.im_func.apply(_52,_57);=0A=
};=0A=
_56.im_self=3D_55;=0A=
_56.im_func=3D_53;=0A=
_56.im_preargs=3D_54;=0A=
return _56;=0A=
},bindMethods:function(_58){=0A=
var _59=3DMochiKit.Base.bind;=0A=
for(var k in _58){=0A=
var _60=3D_58[k];=0A=
if(typeof (_60)=3D=3D"function"){=0A=
_58[k]=3D_59(_60,_58);=0A=
}=0A=
}=0A=
},registerComparator:function(_61,_62,_63,_64){=0A=
MochiKit.Base.comparatorRegistry.register(_61,_62,_63,_64);=0A=
},_primitives:{"boolean":true,"string":true,"number":true},compare:functi=
on(a,b){=0A=
if(a=3D=3Db){=0A=
return 0;=0A=
}=0A=
var _65=3D(typeof (a)=3D=3D"undefined"||a=3D=3D=3Dnull);=0A=
var _66=3D(typeof (b)=3D=3D"undefined"||b=3D=3D=3Dnull);=0A=
if(_65&&_66){=0A=
return 0;=0A=
}else{=0A=
if(_65){=0A=
return -1;=0A=
}else{=0A=
if(_66){=0A=
return 1;=0A=
}=0A=
}=0A=
}=0A=
var m=3DMochiKit.Base;=0A=
var _67=3Dm._primitives;=0A=
if(!(typeof (a) in _67&&typeof (b) in _67)){=0A=
try{=0A=
return m.comparatorRegistry.match(a,b);=0A=
}=0A=
catch(e){=0A=
if(e!=3Dm.NotFound){=0A=
throw e;=0A=
}=0A=
}=0A=
}=0A=
if(a<b){=0A=
return -1;=0A=
}else{=0A=
if(a>b){=0A=
return 1;=0A=
}=0A=
}=0A=
var _68=3Dm.repr;=0A=
throw new TypeError(_68(a)+" and "+_68(b)+" can not be compared");=0A=
},compareDateLike:function(a,b){=0A=
return MochiKit.Base.compare(a.getTime(),b.getTime());=0A=
},compareArrayLike:function(a,b){=0A=
var _69=3DMochiKit.Base.compare;=0A=
var _70=3Da.length;=0A=
var _71=3D0;=0A=
if(_70>b.length){=0A=
_71=3D1;=0A=
_70=3Db.length;=0A=
}else{=0A=
if(_70<b.length){=0A=
_71=3D-1;=0A=
}=0A=
}=0A=
for(var i=3D0;i<_70;i++){=0A=
var cmp=3D_69(a[i],b[i]);=0A=
if(cmp){=0A=
return cmp;=0A=
}=0A=
}=0A=
return _71;=0A=
},registerRepr:function(_73,_74,_75,_76){=0A=
MochiKit.Base.reprRegistry.register(_73,_74,_75,_76);=0A=
},repr:function(o){=0A=
if(typeof (o)=3D=3D"undefined"){=0A=
return "undefined";=0A=
}else{=0A=
if(o=3D=3D=3Dnull){=0A=
return "null";=0A=
}=0A=
}=0A=
try{=0A=
if(typeof (o.__repr__)=3D=3D"function"){=0A=
return o.__repr__();=0A=
}else{=0A=
if(typeof (o.repr)=3D=3D"function"&&o.repr!=3Darguments.callee){=0A=
return o.repr();=0A=
}=0A=
}=0A=
return MochiKit.Base.reprRegistry.match(o);=0A=
}=0A=
catch(e){=0A=
if(typeof =
(o.NAME)=3D=3D"string"&&(o.toString=3D=3DFunction.prototype.toString||o.t=
oString=3D=3DObject.prototype.toString)){=0A=
return o.NAME;=0A=
}=0A=
}=0A=
try{=0A=
var _77=3D(o+"");=0A=
}=0A=
catch(e){=0A=
return "["+typeof (o)+"]";=0A=
}=0A=
if(typeof (o)=3D=3D"function"){=0A=
o=3D_77.replace(/^\s+/,"");=0A=
var idx=3Do.indexOf("{");=0A=
if(idx!=3D-1){=0A=
o=3Do.substr(0,idx)+"{...}";=0A=
}=0A=
}=0A=
return _77;=0A=
},reprArrayLike:function(o){=0A=
var m=3DMochiKit.Base;=0A=
return "["+m.map(m.repr,o).join(", ")+"]";=0A=
},reprString:function(o){=0A=
return =
("\""+o.replace(/(["\\])/g,"\\$1")+"\"").replace(/[\f]/g,"\\f").replace(/=
[\b]/g,"\\b").replace(/[\n]/g,"\\n").replace(/[\t]/g,"\\t").replace(/[\r]=
/g,"\\r");=0A=
},reprNumber:function(o){=0A=
return o+"";=0A=
},registerJSON:function(_79,_80,_81,_82){=0A=
MochiKit.Base.jsonRegistry.register(_79,_80,_81,_82);=0A=
},evalJSON:function(){=0A=
return eval("("+arguments[0]+")");=0A=
},serializeJSON:function(o){=0A=
var _83=3Dtypeof (o);=0A=
if(_83=3D=3D"undefined"){=0A=
return "undefined";=0A=
}else{=0A=
if(_83=3D=3D"number"||_83=3D=3D"boolean"){=0A=
return o+"";=0A=
}else{=0A=
if(o=3D=3D=3Dnull){=0A=
return "null";=0A=
}=0A=
}=0A=
}=0A=
var m=3DMochiKit.Base;=0A=
var _84=3Dm.reprString;=0A=
if(_83=3D=3D"string"){=0A=
return _84(o);=0A=
}=0A=
var me=3Darguments.callee;=0A=
var _85;=0A=
if(typeof (o.__json__)=3D=3D"function"){=0A=
_85=3Do.__json__();=0A=
if(o!=3D=3D_85){=0A=
return me(_85);=0A=
}=0A=
}=0A=
if(typeof (o.json)=3D=3D"function"){=0A=
_85=3Do.json();=0A=
if(o!=3D=3D_85){=0A=
return me(_85);=0A=
}=0A=
}=0A=
if(_83!=3D"function"&&typeof (o.length)=3D=3D"number"){=0A=
var res=3D[];=0A=
for(var i=3D0;i<o.length;i++){=0A=
var val=3Dme(o[i]);=0A=
if(typeof (val)!=3D"string"){=0A=
val=3D"undefined";=0A=
}=0A=
res.push(val);=0A=
}=0A=
return "["+res.join(", ")+"]";=0A=
}=0A=
try{=0A=
_85=3Dm.jsonRegistry.match(o);=0A=
return me(_85);=0A=
}=0A=
catch(e){=0A=
if(e!=3Dm.NotFound){=0A=
throw e;=0A=
}=0A=
}=0A=
if(_83=3D=3D"function"){=0A=
return null;=0A=
}=0A=
res=3D[];=0A=
for(var k in o){=0A=
var _87;=0A=
if(typeof (k)=3D=3D"number"){=0A=
_87=3D"\""+k+"\"";=0A=
}else{=0A=
if(typeof (k)=3D=3D"string"){=0A=
_87=3D_84(k);=0A=
}else{=0A=
continue;=0A=
}=0A=
}=0A=
val=3Dme(o[k]);=0A=
if(typeof (val)!=3D"string"){=0A=
continue;=0A=
}=0A=
res.push(_87+":"+val);=0A=
}=0A=
return "{"+res.join(", ")+"}";=0A=
},objEqual:function(a,b){=0A=
return (MochiKit.Base.compare(a,b)=3D=3D=3D0);=0A=
},arrayEqual:function(_88,arr){=0A=
if(_88.length!=3Darr.length){=0A=
return false;=0A=
}=0A=
return (MochiKit.Base.compare(_88,arr)=3D=3D=3D0);=0A=
},concat:function(){=0A=
var _90=3D[];=0A=
var _91=3DMochiKit.Base.extend;=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
_91(_90,arguments[i]);=0A=
}=0A=
return _90;=0A=
},keyComparator:function(key){=0A=
var m=3DMochiKit.Base;=0A=
var _93=3Dm.compare;=0A=
if(arguments.length=3D=3D1){=0A=
return function(a,b){=0A=
return _93(a[key],b[key]);=0A=
};=0A=
}=0A=
var _94=3Dm.extend(null,arguments);=0A=
return function(a,b){=0A=
var _95=3D0;=0A=
for(var i=3D0;(_95=3D=3D=3D0)&&(i<_94.length);i++){=0A=
var key=3D_94[i];=0A=
_95=3D_93(a[key],b[key]);=0A=
}=0A=
return _95;=0A=
};=0A=
},reverseKeyComparator:function(key){=0A=
var _96=3DMochiKit.Base.keyComparator.apply(this,arguments);=0A=
return function(a,b){=0A=
return _96(b,a);=0A=
};=0A=
},partial:function(_97){=0A=
var m=3DMochiKit.Base;=0A=
return m.bind.apply(this,m.extend([_97,undefined],arguments,1));=0A=
},listMinMax:function(_98,lst){=0A=
if(lst.length=3D=3D=3D0){=0A=
return null;=0A=
}=0A=
var cur=3Dlst[0];=0A=
var _100=3DMochiKit.Base.compare;=0A=
for(var i=3D1;i<lst.length;i++){=0A=
var o=3Dlst[i];=0A=
if(_100(o,cur)=3D=3D_98){=0A=
cur=3Do;=0A=
}=0A=
}=0A=
return cur;=0A=
},objMax:function(){=0A=
return MochiKit.Base.listMinMax(1,arguments);=0A=
},objMin:function(){=0A=
return MochiKit.Base.listMinMax(-1,arguments);=0A=
},findIdentical:function(lst,_101,_102,end){=0A=
if(typeof (end)=3D=3D"undefined"||end=3D=3D=3Dnull){=0A=
end=3Dlst.length;=0A=
}=0A=
for(var i=3D(_102||0);i<end;i++){=0A=
if(lst[i]=3D=3D=3D_101){=0A=
return i;=0A=
}=0A=
}=0A=
return -1;=0A=
},findValue:function(lst,_104,_105,end){=0A=
if(typeof (end)=3D=3D"undefined"||end=3D=3D=3Dnull){=0A=
end=3Dlst.length;=0A=
}=0A=
var cmp=3DMochiKit.Base.compare;=0A=
for(var i=3D(_105||0);i<end;i++){=0A=
if(cmp(lst[i],_104)=3D=3D=3D0){=0A=
return i;=0A=
}=0A=
}=0A=
return -1;=0A=
},nodeWalk:function(node,_107){=0A=
var _108=3D[node];=0A=
var _109=3DMochiKit.Base.extend;=0A=
while(_108.length){=0A=
var res=3D_107(_108.shift());=0A=
if(res){=0A=
_109(_108,res);=0A=
}=0A=
}=0A=
},nameFunctions:function(_110){=0A=
var base=3D_110.NAME;=0A=
if(typeof (base)=3D=3D"undefined"){=0A=
base=3D"";=0A=
}else{=0A=
base=3Dbase+".";=0A=
}=0A=
for(var name in _110){=0A=
var o=3D_110[name];=0A=
if(typeof (o)=3D=3D"function"&&typeof (o.NAME)=3D=3D"undefined"){=0A=
try{=0A=
o.NAME=3Dbase+name;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
}=0A=
},queryString:function(_113,_114){=0A=
if(typeof =
(MochiKit.DOM)!=3D"undefined"&&arguments.length=3D=3D1&&(typeof =
(_113)=3D=3D"string"||(typeof =
(_113.nodeType)!=3D"undefined"&&_113.nodeType>0))){=0A=
var kv=3DMochiKit.DOM.formContents(_113);=0A=
_113=3Dkv[0];=0A=
_114=3Dkv[1];=0A=
}else{=0A=
if(arguments.length=3D=3D1){=0A=
var o=3D_113;=0A=
_113=3D[];=0A=
_114=3D[];=0A=
for(var k in o){=0A=
var v=3Do[k];=0A=
if(typeof (v)!=3D"function"){=0A=
_113.push(k);=0A=
_114.push(v);=0A=
}=0A=
}=0A=
}=0A=
}=0A=
var rval=3D[];=0A=
var len=3DMath.min(_113.length,_114.length);=0A=
var _118=3DMochiKit.Base.urlEncode;=0A=
for(var i=3D0;i<len;i++){=0A=
v=3D_114[i];=0A=
if(typeof (v)!=3D"undefined"&&v!=3D=3Dnull){=0A=
rval.push(_118(_113[i])+"=3D"+_118(v));=0A=
}=0A=
}=0A=
return rval.join("&");=0A=
},parseQueryString:function(_119,_120){=0A=
var _121=3D_119.replace(/\+/g,"%20").split("&");=0A=
var o=3D{};=0A=
var _122;=0A=
if(typeof (decodeURIComponent)!=3D"undefined"){=0A=
_122=3DdecodeURIComponent;=0A=
}else{=0A=
_122=3Dunescape;=0A=
}=0A=
if(_120){=0A=
for(var i=3D0;i<_121.length;i++){=0A=
var pair=3D_121[i].split("=3D");=0A=
var name=3D_122(pair[0]);=0A=
var arr=3Do[name];=0A=
if(!(arr instanceof Array)){=0A=
arr=3D[];=0A=
o[name]=3Darr;=0A=
}=0A=
arr.push(_122(pair[1]));=0A=
}=0A=
}else{=0A=
for(i=3D0;i<_121.length;i++){=0A=
pair=3D_121[i].split("=3D");=0A=
o[_122(pair[0])]=3D_122(pair[1]);=0A=
}=0A=
}=0A=
return o;=0A=
}});=0A=
MochiKit.Base.AdapterRegistry=3Dfunction(){=0A=
this.pairs=3D[];=0A=
};=0A=
MochiKit.Base.AdapterRegistry.prototype=3D{register:function(name,_124,wr=
ap,_126){=0A=
if(_126){=0A=
this.pairs.unshift([name,_124,wrap]);=0A=
}else{=0A=
this.pairs.push([name,_124,wrap]);=0A=
}=0A=
},match:function(){=0A=
for(var i=3D0;i<this.pairs.length;i++){=0A=
var pair=3Dthis.pairs[i];=0A=
if(pair[1].apply(this,arguments)){=0A=
return pair[2].apply(this,arguments);=0A=
}=0A=
}=0A=
throw MochiKit.Base.NotFound;=0A=
},unregister:function(name){=0A=
for(var i=3D0;i<this.pairs.length;i++){=0A=
var pair=3Dthis.pairs[i];=0A=
if(pair[0]=3D=3Dname){=0A=
this.pairs.splice(i,1);=0A=
return true;=0A=
}=0A=
}=0A=
return false;=0A=
}};=0A=
MochiKit.Base.EXPORT=3D["counter","clone","extend","update","updatetree",=
"setdefault","keys","items","NamedError","operator","forwardCall","itemge=
tter","typeMatcher","isCallable","isUndefined","isUndefinedOrNull","isNul=
l","isEmpty","isNotEmpty","isArrayLike","isDateLike","xmap","map","xfilte=
r","filter","bind","bindMethods","NotFound","AdapterRegistry","registerCo=
mparator","compare","registerRepr","repr","objEqual","arrayEqual","concat=
","keyComparator","reverseKeyComparator","partial","merge","listMinMax","=
listMax","listMin","objMax","objMin","nodeWalk","zip","urlEncode","queryS=
tring","serializeJSON","registerJSON","evalJSON","parseQueryString","find=
Value","findIdentical","flattenArguments","method"];=0A=
MochiKit.Base.EXPORT_OK=3D["nameFunctions","comparatorRegistry","reprRegi=
stry","jsonRegistry","compareDateLike","compareArrayLike","reprArrayLike"=
,"reprString","reprNumber"];=0A=
MochiKit.Base._exportSymbols=3Dfunction(_127,_128){=0A=
if(typeof (MochiKit.__export__)=3D=3D"undefined"){=0A=
MochiKit.__export__=3D(MochiKit.__compat__||(typeof =
(JSAN)=3D=3D"undefined"&&typeof (dojo)=3D=3D"undefined"));=0A=
}=0A=
if(!MochiKit.__export__){=0A=
return;=0A=
}=0A=
var all=3D_128.EXPORT_TAGS[":all"];=0A=
for(var i=3D0;i<all.length;i++){=0A=
_127[all[i]]=3D_128[all[i]];=0A=
}=0A=
};=0A=
MochiKit.Base.__new__=3Dfunction(){=0A=
var m=3Dthis;=0A=
m.forward=3Dm.forwardCall;=0A=
m.find=3Dm.findValue;=0A=
if(typeof (encodeURIComponent)!=3D"undefined"){=0A=
m.urlEncode=3Dfunction(_130){=0A=
return encodeURIComponent(_130).replace(/\'/g,"%27");=0A=
};=0A=
}else{=0A=
m.urlEncode=3Dfunction(_131){=0A=
return =
escape(_131).replace(/\+/g,"%2B").replace(/\"/g,"%22").rval.replace(/\'/g=
,"%27");=0A=
};=0A=
}=0A=
m.NamedError=3Dfunction(name){=0A=
this.message=3Dname;=0A=
this.name=3Dname;=0A=
};=0A=
m.NamedError.prototype=3Dnew Error();=0A=
m.update(m.NamedError.prototype,{repr:function(){=0A=
if(this.message&&this.message!=3Dthis.name){=0A=
return this.name+"("+m.repr(this.message)+")";=0A=
}else{=0A=
return this.name+"()";=0A=
}=0A=
},toString:m.forwardCall("repr")});=0A=
m.NotFound=3Dnew m.NamedError("MochiKit.Base.NotFound");=0A=
m.listMax=3Dm.partial(m.listMinMax,1);=0A=
m.listMin=3Dm.partial(m.listMinMax,-1);=0A=
m.isCallable=3Dm.typeMatcher("function");=0A=
m.isUndefined=3Dm.typeMatcher("undefined");=0A=
m.merge=3Dm.partial(m.update,null);=0A=
m.zip=3Dm.partial(m.map,null);=0A=
m.comparatorRegistry=3Dnew m.AdapterRegistry();=0A=
m.registerComparator("dateLike",m.isDateLike,m.compareDateLike);=0A=
m.registerComparator("arrayLike",m.isArrayLike,m.compareArrayLike);=0A=
m.reprRegistry=3Dnew m.AdapterRegistry();=0A=
m.registerRepr("arrayLike",m.isArrayLike,m.reprArrayLike);=0A=
m.registerRepr("string",m.typeMatcher("string"),m.reprString);=0A=
m.registerRepr("numbers",m.typeMatcher("number","boolean"),m.reprNumber);=0A=
m.jsonRegistry=3Dnew m.AdapterRegistry();=0A=
var all=3Dm.concat(m.EXPORT,m.EXPORT_OK);=0A=
m.EXPORT_TAGS=3D{":common":m.concat(m.EXPORT_OK),":all":all};=0A=
m.nameFunctions(this);=0A=
};=0A=
MochiKit.Base.__new__();=0A=
if(!MochiKit.__compat__){=0A=
compare=3DMochiKit.Base.compare;=0A=
}=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Base);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Iter");=0A=
dojo.require("MochiKit.Base");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Iter depends on MochiKit.Base!";=0A=
}=0A=
if(typeof (MochiKit.Iter)=3D=3D"undefined"){=0A=
MochiKit.Iter=3D{};=0A=
}=0A=
MochiKit.Iter.NAME=3D"MochiKit.Iter";=0A=
MochiKit.Iter.VERSION=3D"1.3.1";=0A=
MochiKit.Base.update(MochiKit.Iter,{__repr__:function(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
},toString:function(){=0A=
return this.__repr__();=0A=
},registerIteratorFactory:function(name,_132,_133,_134){=0A=
MochiKit.Iter.iteratorRegistry.register(name,_132,_133,_134);=0A=
},iter:function(_135,_136){=0A=
var self=3DMochiKit.Iter;=0A=
if(arguments.length=3D=3D2){=0A=
return self.takewhile(function(a){=0A=
return a!=3D_136;=0A=
},_135);=0A=
}=0A=
if(typeof (_135.next)=3D=3D"function"){=0A=
return _135;=0A=
}else{=0A=
if(typeof (_135.iter)=3D=3D"function"){=0A=
return _135.iter();=0A=
}=0A=
}=0A=
try{=0A=
return self.iteratorRegistry.match(_135);=0A=
}=0A=
catch(e){=0A=
var m=3DMochiKit.Base;=0A=
if(e=3D=3Dm.NotFound){=0A=
e=3Dnew TypeError(typeof (_135)+": "+m.repr(_135)+" is not iterable");=0A=
}=0A=
throw e;=0A=
}=0A=
},count:function(n){=0A=
if(!n){=0A=
n=3D0;=0A=
}=0A=
var m=3DMochiKit.Base;=0A=
return {repr:function(){=0A=
return "count("+n+")";=0A=
},toString:m.forwardCall("repr"),next:m.counter(n)};=0A=
},cycle:function(p){=0A=
var self=3DMochiKit.Iter;=0A=
var m=3DMochiKit.Base;=0A=
var lst=3D[];=0A=
var _139=3Dself.iter(p);=0A=
return {repr:function(){=0A=
return "cycle(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
try{=0A=
var rval=3D_139.next();=0A=
lst.push(rval);=0A=
return rval;=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
if(lst.length=3D=3D=3D0){=0A=
this.next=3Dfunction(){=0A=
throw self.StopIteration;=0A=
};=0A=
}else{=0A=
var i=3D-1;=0A=
this.next=3Dfunction(){=0A=
i=3D(i+1)%lst.length;=0A=
return lst[i];=0A=
};=0A=
}=0A=
return this.next();=0A=
}=0A=
}};=0A=
},repeat:function(elem,n){=0A=
var m=3DMochiKit.Base;=0A=
if(typeof (n)=3D=3D"undefined"){=0A=
return {repr:function(){=0A=
return "repeat("+m.repr(elem)+")";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
return elem;=0A=
}};=0A=
}=0A=
return {repr:function(){=0A=
return "repeat("+m.repr(elem)+", "+n+")";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
if(n<=3D0){=0A=
throw MochiKit.Iter.StopIteration;=0A=
}=0A=
n-=3D1;=0A=
return elem;=0A=
}};=0A=
},next:function(_141){=0A=
return _141.next();=0A=
},izip:function(p,q){=0A=
var m=3DMochiKit.Base;=0A=
var next=3DMochiKit.Iter.next;=0A=
var _144=3Dm.map(iter,arguments);=0A=
return {repr:function(){=0A=
return "izip(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
return m.map(next,_144);=0A=
}};=0A=
},ifilter:function(pred,seq){=0A=
var m=3DMochiKit.Base;=0A=
seq=3DMochiKit.Iter.iter(seq);=0A=
if(pred=3D=3D=3Dnull){=0A=
pred=3Dm.operator.truth;=0A=
}=0A=
return {repr:function(){=0A=
return "ifilter(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
while(true){=0A=
var rval=3Dseq.next();=0A=
if(pred(rval)){=0A=
return rval;=0A=
}=0A=
}=0A=
return undefined;=0A=
}};=0A=
},ifilterfalse:function(pred,seq){=0A=
var m=3DMochiKit.Base;=0A=
seq=3DMochiKit.Iter.iter(seq);=0A=
if(pred=3D=3D=3Dnull){=0A=
pred=3Dm.operator.truth;=0A=
}=0A=
return {repr:function(){=0A=
return "ifilterfalse(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
while(true){=0A=
var rval=3Dseq.next();=0A=
if(!pred(rval)){=0A=
return rval;=0A=
}=0A=
}=0A=
return undefined;=0A=
}};=0A=
},islice:function(seq){=0A=
var self=3DMochiKit.Iter;=0A=
var m=3DMochiKit.Base;=0A=
seq=3Dself.iter(seq);=0A=
var _147=3D0;=0A=
var stop=3D0;=0A=
var step=3D1;=0A=
var i=3D-1;=0A=
if(arguments.length=3D=3D2){=0A=
stop=3Darguments[1];=0A=
}else{=0A=
if(arguments.length=3D=3D3){=0A=
_147=3Darguments[1];=0A=
stop=3Darguments[2];=0A=
}else{=0A=
_147=3Darguments[1];=0A=
stop=3Darguments[2];=0A=
step=3Darguments[3];=0A=
}=0A=
}=0A=
return {repr:function(){=0A=
return "islice("+["...",_147,stop,step].join(", ")+")";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
var rval;=0A=
while(i<_147){=0A=
rval=3Dseq.next();=0A=
i++;=0A=
}=0A=
if(_147>=3Dstop){=0A=
throw self.StopIteration;=0A=
}=0A=
_147+=3Dstep;=0A=
return rval;=0A=
}};=0A=
},imap:function(fun,p,q){=0A=
var m=3DMochiKit.Base;=0A=
var self=3DMochiKit.Iter;=0A=
var _151=3Dm.map(self.iter,m.extend(null,arguments,1));=0A=
var map=3Dm.map;=0A=
var next=3Dself.next;=0A=
return {repr:function(){=0A=
return "imap(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
return fun.apply(this,map(next,_151));=0A=
}};=0A=
},applymap:function(fun,seq,self){=0A=
seq=3DMochiKit.Iter.iter(seq);=0A=
var m=3DMochiKit.Base;=0A=
return {repr:function(){=0A=
return "applymap(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
return fun.apply(self,seq.next());=0A=
}};=0A=
},chain:function(p,q){=0A=
var self=3DMochiKit.Iter;=0A=
var m=3DMochiKit.Base;=0A=
if(arguments.length=3D=3D1){=0A=
return self.iter(arguments[0]);=0A=
}=0A=
var _153=3Dm.map(self.iter,arguments);=0A=
return {repr:function(){=0A=
return "chain(...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
while(_153.length>1){=0A=
try{=0A=
return _153[0].next();=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
_153.shift();=0A=
}=0A=
}=0A=
if(_153.length=3D=3D1){=0A=
var arg=3D_153.shift();=0A=
this.next=3Dm.bind("next",arg);=0A=
return this.next();=0A=
}=0A=
throw self.StopIteration;=0A=
}};=0A=
},takewhile:function(pred,seq){=0A=
var self=3DMochiKit.Iter;=0A=
seq=3Dself.iter(seq);=0A=
return {repr:function(){=0A=
return "takewhile(...)";=0A=
},toString:MochiKit.Base.forwardCall("repr"),next:function(){=0A=
var rval=3Dseq.next();=0A=
if(!pred(rval)){=0A=
this.next=3Dfunction(){=0A=
throw self.StopIteration;=0A=
};=0A=
this.next();=0A=
}=0A=
return rval;=0A=
}};=0A=
},dropwhile:function(pred,seq){=0A=
seq=3DMochiKit.Iter.iter(seq);=0A=
var m=3DMochiKit.Base;=0A=
var bind=3Dm.bind;=0A=
return {"repr":function(){=0A=
return "dropwhile(...)";=0A=
},"toString":m.forwardCall("repr"),"next":function(){=0A=
while(true){=0A=
var rval=3Dseq.next();=0A=
if(!pred(rval)){=0A=
break;=0A=
}=0A=
}=0A=
this.next=3Dbind("next",seq);=0A=
return rval;=0A=
}};=0A=
},_tee:function(_155,sync,_157){=0A=
sync.pos[_155]=3D-1;=0A=
var m=3DMochiKit.Base;=0A=
var _158=3Dm.listMin;=0A=
return {repr:function(){=0A=
return "tee("+_155+", ...)";=0A=
},toString:m.forwardCall("repr"),next:function(){=0A=
var rval;=0A=
var i=3Dsync.pos[_155];=0A=
if(i=3D=3Dsync.max){=0A=
rval=3D_157.next();=0A=
sync.deque.push(rval);=0A=
sync.max+=3D1;=0A=
sync.pos[_155]+=3D1;=0A=
}else{=0A=
rval=3Dsync.deque[i-sync.min];=0A=
sync.pos[_155]+=3D1;=0A=
if(i=3D=3Dsync.min&&_158(sync.pos)!=3Dsync.min){=0A=
sync.min+=3D1;=0A=
sync.deque.shift();=0A=
}=0A=
}=0A=
return rval;=0A=
}};=0A=
},tee:function(_159,n){=0A=
var rval=3D[];=0A=
var sync=3D{"pos":[],"deque":[],"max":-1,"min":-1};=0A=
if(arguments.length=3D=3D1){=0A=
n=3D2;=0A=
}=0A=
var self=3DMochiKit.Iter;=0A=
_159=3Dself.iter(_159);=0A=
var _tee=3Dself._tee;=0A=
for(var i=3D0;i<n;i++){=0A=
rval.push(_tee(i,sync,_159));=0A=
}=0A=
return rval;=0A=
},list:function(_161){=0A=
var m=3DMochiKit.Base;=0A=
if(typeof (_161.slice)=3D=3D"function"){=0A=
return _161.slice();=0A=
}else{=0A=
if(m.isArrayLike(_161)){=0A=
return m.concat(_161);=0A=
}=0A=
}=0A=
var self=3DMochiKit.Iter;=0A=
_161=3Dself.iter(_161);=0A=
var rval=3D[];=0A=
try{=0A=
while(true){=0A=
rval.push(_161.next());=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
return rval;=0A=
}=0A=
return undefined;=0A=
},reduce:function(fn,_162,_163){=0A=
var i=3D0;=0A=
var x=3D_163;=0A=
var self=3DMochiKit.Iter;=0A=
_162=3Dself.iter(_162);=0A=
if(arguments.length<3){=0A=
try{=0A=
x=3D_162.next();=0A=
}=0A=
catch(e){=0A=
if(e=3D=3Dself.StopIteration){=0A=
e=3Dnew TypeError("reduce() of empty sequence with no initial value");=0A=
}=0A=
throw e;=0A=
}=0A=
i++;=0A=
}=0A=
try{=0A=
while(true){=0A=
x=3Dfn(x,_162.next());=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
}=0A=
return x;=0A=
},range:function(){=0A=
var _165=3D0;=0A=
var stop=3D0;=0A=
var step=3D1;=0A=
if(arguments.length=3D=3D1){=0A=
stop=3Darguments[0];=0A=
}else{=0A=
if(arguments.length=3D=3D2){=0A=
_165=3Darguments[0];=0A=
stop=3Darguments[1];=0A=
}else{=0A=
if(arguments.length=3D=3D3){=0A=
_165=3Darguments[0];=0A=
stop=3Darguments[1];=0A=
step=3Darguments[2];=0A=
}else{=0A=
throw new TypeError("range() takes 1, 2, or 3 arguments!");=0A=
}=0A=
}=0A=
}=0A=
if(step=3D=3D=3D0){=0A=
throw new TypeError("range() step must not be 0");=0A=
}=0A=
return {next:function(){=0A=
if((step>0&&_165>=3Dstop)||(step<0&&_165<=3Dstop)){=0A=
throw MochiKit.Iter.StopIteration;=0A=
}=0A=
var rval=3D_165;=0A=
_165+=3Dstep;=0A=
return rval;=0A=
},repr:function(){=0A=
return "range("+[_165,stop,step].join(", ")+")";=0A=
},toString:MochiKit.Base.forwardCall("repr")};=0A=
},sum:function(_166,_167){=0A=
var x=3D_167||0;=0A=
var self=3DMochiKit.Iter;=0A=
_166=3Dself.iter(_166);=0A=
try{=0A=
while(true){=0A=
x+=3D_166.next();=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
}=0A=
return x;=0A=
},exhaust:function(_168){=0A=
var self=3DMochiKit.Iter;=0A=
_168=3Dself.iter(_168);=0A=
try{=0A=
while(true){=0A=
_168.next();=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
}=0A=
},forEach:function(_169,func,self){=0A=
var m=3DMochiKit.Base;=0A=
if(arguments.length>2){=0A=
func=3Dm.bind(func,self);=0A=
}=0A=
if(m.isArrayLike(_169)){=0A=
try{=0A=
for(var i=3D0;i<_169.length;i++){=0A=
func(_169[i]);=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3DMochiKit.Iter.StopIteration){=0A=
throw e;=0A=
}=0A=
}=0A=
}else{=0A=
self=3DMochiKit.Iter;=0A=
self.exhaust(self.imap(func,_169));=0A=
}=0A=
},every:function(_171,func){=0A=
var self=3DMochiKit.Iter;=0A=
try{=0A=
self.ifilterfalse(func,_171).next();=0A=
return false;=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
return true;=0A=
}=0A=
},sorted:function(_172,cmp){=0A=
var rval=3DMochiKit.Iter.list(_172);=0A=
if(arguments.length=3D=3D1){=0A=
cmp=3DMochiKit.Base.compare;=0A=
}=0A=
rval.sort(cmp);=0A=
return rval;=0A=
},reversed:function(_173){=0A=
var rval=3DMochiKit.Iter.list(_173);=0A=
rval.reverse();=0A=
return rval;=0A=
},some:function(_174,func){=0A=
var self=3DMochiKit.Iter;=0A=
try{=0A=
self.ifilter(func,_174).next();=0A=
return true;=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
return false;=0A=
}=0A=
},iextend:function(lst,_175){=0A=
if(MochiKit.Base.isArrayLike(_175)){=0A=
for(var i=3D0;i<_175.length;i++){=0A=
lst.push(_175[i]);=0A=
}=0A=
}else{=0A=
var self=3DMochiKit.Iter;=0A=
_175=3Dself.iter(_175);=0A=
try{=0A=
while(true){=0A=
lst.push(_175.next());=0A=
}=0A=
}=0A=
catch(e){=0A=
if(e!=3Dself.StopIteration){=0A=
throw e;=0A=
}=0A=
}=0A=
}=0A=
return lst;=0A=
},groupby:function(_176,_177){=0A=
var m=3DMochiKit.Base;=0A=
var self=3DMochiKit.Iter;=0A=
if(arguments.length<2){=0A=
_177=3Dm.operator.identity;=0A=
}=0A=
_176=3Dself.iter(_176);=0A=
var pk=3Dundefined;=0A=
var k=3Dundefined;=0A=
var v;=0A=
function fetch(){=0A=
v=3D_176.next();=0A=
k=3D_177(v);=0A=
}=0A=
function eat(){=0A=
var ret=3Dv;=0A=
v=3Dundefined;=0A=
return ret;=0A=
}=0A=
var _180=3Dtrue;=0A=
return {repr:function(){=0A=
return "groupby(...)";=0A=
},next:function(){=0A=
while(k=3D=3Dpk){=0A=
fetch();=0A=
if(_180){=0A=
_180=3Dfalse;=0A=
break;=0A=
}=0A=
}=0A=
pk=3Dk;=0A=
return [k,{next:function(){=0A=
if(v=3D=3Dundefined){=0A=
fetch();=0A=
}=0A=
if(k!=3Dpk){=0A=
throw self.StopIteration;=0A=
}=0A=
return eat();=0A=
}}];=0A=
}};=0A=
},groupby_as_array:function(_181,_182){=0A=
var m=3DMochiKit.Base;=0A=
var self=3DMochiKit.Iter;=0A=
if(arguments.length<2){=0A=
_182=3Dm.operator.identity;=0A=
}=0A=
_181=3Dself.iter(_181);=0A=
var _183=3D[];=0A=
var _184=3Dtrue;=0A=
var _185;=0A=
while(true){=0A=
try{=0A=
var _186=3D_181.next();=0A=
var key=3D_182(_186);=0A=
}=0A=
catch(e){=0A=
if(e=3D=3Dself.StopIteration){=0A=
break;=0A=
}=0A=
throw e;=0A=
}=0A=
if(_184||key!=3D_185){=0A=
var _187=3D[];=0A=
_183.push([key,_187]);=0A=
}=0A=
_187.push(_186);=0A=
_184=3Dfalse;=0A=
_185=3Dkey;=0A=
}=0A=
return _183;=0A=
},arrayLikeIter:function(_188){=0A=
var i=3D0;=0A=
return {repr:function(){=0A=
return "arrayLikeIter(...)";=0A=
},toString:MochiKit.Base.forwardCall("repr"),next:function(){=0A=
if(i>=3D_188.length){=0A=
throw MochiKit.Iter.StopIteration;=0A=
}=0A=
return _188[i++];=0A=
}};=0A=
},hasIterateNext:function(_189){=0A=
return (_189&&typeof (_189.iterateNext)=3D=3D"function");=0A=
},iterateNextIter:function(_190){=0A=
return {repr:function(){=0A=
return "iterateNextIter(...)";=0A=
},toString:MochiKit.Base.forwardCall("repr"),next:function(){=0A=
var rval=3D_190.iterateNext();=0A=
if(rval=3D=3D=3Dnull||rval=3D=3D=3Dundefined){=0A=
throw MochiKit.Iter.StopIteration;=0A=
}=0A=
return rval;=0A=
}};=0A=
}});=0A=
MochiKit.Iter.EXPORT_OK=3D["iteratorRegistry","arrayLikeIter","hasIterate=
Next","iterateNextIter",];=0A=
MochiKit.Iter.EXPORT=3D["StopIteration","registerIteratorFactory","iter",=
"count","cycle","repeat","next","izip","ifilter","ifilterfalse","islice",=
"imap","applymap","chain","takewhile","dropwhile","tee","list","reduce","=
range","sum","exhaust","forEach","every","sorted","reversed","some","iext=
end","groupby","groupby_as_array"];=0A=
MochiKit.Iter.__new__=3Dfunction(){=0A=
var m=3DMochiKit.Base;=0A=
this.StopIteration=3Dnew m.NamedError("StopIteration");=0A=
this.iteratorRegistry=3Dnew m.AdapterRegistry();=0A=
this.registerIteratorFactory("arrayLike",m.isArrayLike,this.arrayLikeIter=
);=0A=
this.registerIteratorFactory("iterateNext",this.hasIterateNext,this.itera=
teNextIter);=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
m.nameFunctions(this);=0A=
};=0A=
MochiKit.Iter.__new__();=0A=
if(!MochiKit.__compat__){=0A=
reduce=3DMochiKit.Iter.reduce;=0A=
}=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Iter);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Logging");=0A=
dojo.require("MochiKit.Base");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Logging depends on MochiKit.Base!";=0A=
}=0A=
if(typeof (MochiKit.Logging)=3D=3D"undefined"){=0A=
MochiKit.Logging=3D{};=0A=
}=0A=
MochiKit.Logging.NAME=3D"MochiKit.Logging";=0A=
MochiKit.Logging.VERSION=3D"1.3.1";=0A=
MochiKit.Logging.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.Logging.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.Logging.EXPORT=3D["LogLevel","LogMessage","Logger","alertListene=
r","logger","log","logError","logDebug","logFatal","logWarning"];=0A=
MochiKit.Logging.EXPORT_OK=3D["logLevelAtLeast","isLogMessage","compareLo=
gMessage"];=0A=
MochiKit.Logging.LogMessage=3Dfunction(num,_192,info){=0A=
this.num=3Dnum;=0A=
this.level=3D_192;=0A=
this.info=3Dinfo;=0A=
this.timestamp=3Dnew Date();=0A=
};=0A=
MochiKit.Logging.LogMessage.prototype=3D{repr:function(){=0A=
var m=3DMochiKit.Base;=0A=
return =
"LogMessage("+m.map(m.repr,[this.num,this.level,this.info]).join(", =
")+")";=0A=
},toString:MochiKit.Base.forwardCall("repr")};=0A=
MochiKit.Base.update(MochiKit.Logging,{logLevelAtLeast:function(_194){=0A=
var self=3DMochiKit.Logging;=0A=
if(typeof (_194)=3D=3D"string"){=0A=
_194=3Dself.LogLevel[_194];=0A=
}=0A=
return function(msg){=0A=
var _196=3Dmsg.level;=0A=
if(typeof (_196)=3D=3D"string"){=0A=
_196=3Dself.LogLevel[_196];=0A=
}=0A=
return _196>=3D_194;=0A=
};=0A=
},isLogMessage:function(){=0A=
var _197=3DMochiKit.Logging.LogMessage;=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
if(!(arguments[i] instanceof _197)){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},compareLogMessage:function(a,b){=0A=
return MochiKit.Base.compare([a.level,a.info],[b.level,b.info]);=0A=
},alertListener:function(msg){=0A=
alert("num: "+msg.num+"\nlevel: "+msg.level+"\ninfo: "+msg.info.join(" =
"));=0A=
}});=0A=
MochiKit.Logging.Logger=3Dfunction(_198){=0A=
this.counter=3D0;=0A=
if(typeof (_198)=3D=3D"undefined"||_198=3D=3D=3Dnull){=0A=
_198=3D-1;=0A=
}=0A=
this.maxSize=3D_198;=0A=
this._messages=3D[];=0A=
this.listeners=3D{};=0A=
this.useNativeConsole=3Dfalse;=0A=
};=0A=
MochiKit.Logging.Logger.prototype=3D{clear:function(){=0A=
this._messages.splice(0,this._messages.length);=0A=
},logToConsole:function(msg){=0A=
if(typeof (window)!=3D"undefined"&&window.console&&window.console.log){=0A=
window.console.log(msg);=0A=
}else{=0A=
if(typeof (opera)!=3D"undefined"&&opera.postError){=0A=
opera.postError(msg);=0A=
}else{=0A=
if(typeof (printfire)=3D=3D"function"){=0A=
printfire(msg);=0A=
}=0A=
}=0A=
}=0A=
},dispatchListeners:function(msg){=0A=
for(var k in this.listeners){=0A=
var pair=3Dthis.listeners[k];=0A=
if(pair.ident!=3Dk||(pair[0]&&!pair[0](msg))){=0A=
continue;=0A=
}=0A=
pair[1](msg);=0A=
}=0A=
},addListener:function(_199,_200,_201){=0A=
if(typeof (_200)=3D=3D"string"){=0A=
_200=3DMochiKit.Logging.logLevelAtLeast(_200);=0A=
}=0A=
var _202=3D[_200,_201];=0A=
_202.ident=3D_199;=0A=
this.listeners[_199]=3D_202;=0A=
},removeListener:function(_203){=0A=
delete this.listeners[_203];=0A=
},baseLog:function(_204,_205){=0A=
var msg=3Dnew =
MochiKit.Logging.LogMessage(this.counter,_204,MochiKit.Base.extend(null,a=
rguments,1));=0A=
this._messages.push(msg);=0A=
this.dispatchListeners(msg);=0A=
if(this.useNativeConsole){=0A=
this.logToConsole(msg.level+": "+msg.info.join(" "));=0A=
}=0A=
this.counter+=3D1;=0A=
while(this.maxSize>=3D0&&this._messages.length>this.maxSize){=0A=
this._messages.shift();=0A=
}=0A=
},getMessages:function(_206){=0A=
var _207=3D0;=0A=
if(!(typeof (_206)=3D=3D"undefined"||_206=3D=3D=3Dnull)){=0A=
_207=3DMath.max(0,this._messages.length-_206);=0A=
}=0A=
return this._messages.slice(_207);=0A=
},getMessageText:function(_208){=0A=
if(typeof (_208)=3D=3D"undefined"||_208=3D=3D=3Dnull){=0A=
_208=3D30;=0A=
}=0A=
var _209=3Dthis.getMessages(_208);=0A=
if(_209.length){=0A=
var lst=3Dmap(function(m){=0A=
return "\n  ["+m.num+"] "+m.level+": "+m.info.join(" ");=0A=
},_209);=0A=
lst.unshift("LAST "+_209.length+" MESSAGES:");=0A=
return lst.join("");=0A=
}=0A=
return "";=0A=
},debuggingBookmarklet:function(_210){=0A=
if(typeof (MochiKit.LoggingPane)=3D=3D"undefined"){=0A=
alert(this.getMessageText());=0A=
}else{=0A=
MochiKit.LoggingPane.createLoggingPane(_210||false);=0A=
}=0A=
}};=0A=
MochiKit.Logging.__new__=3Dfunction(){=0A=
this.LogLevel=3D{ERROR:40,FATAL:50,WARNING:30,INFO:20,DEBUG:10};=0A=
var m=3DMochiKit.Base;=0A=
m.registerComparator("LogMessage",this.isLogMessage,this.compareLogMessag=
e);=0A=
var _211=3Dm.partial;=0A=
var _212=3Dthis.Logger;=0A=
var _213=3D_212.prototype.baseLog;=0A=
m.update(this.Logger.prototype,{debug:_211(_213,"DEBUG"),log:_211(_213,"I=
NFO"),error:_211(_213,"ERROR"),fatal:_211(_213,"FATAL"),warning:_211(_213=
,"WARNING")});=0A=
var self=3Dthis;=0A=
var _214=3Dfunction(name){=0A=
return function(){=0A=
self.logger[name].apply(self.logger,arguments);=0A=
};=0A=
};=0A=
this.log=3D_214("log");=0A=
this.logError=3D_214("error");=0A=
this.logDebug=3D_214("debug");=0A=
this.logFatal=3D_214("fatal");=0A=
this.logWarning=3D_214("warning");=0A=
this.logger=3Dnew _212();=0A=
this.logger.useNativeConsole=3Dtrue;=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
m.nameFunctions(this);=0A=
};=0A=
if(typeof (printfire)=3D=3D"undefined"&&typeof =
(document)!=3D"undefined"&&document.createEvent&&typeof =
(dispatchEvent)!=3D"undefined"){=0A=
printfire=3Dfunction(){=0A=
printfire.args=3Darguments;=0A=
var ev=3Ddocument.createEvent("Events");=0A=
ev.initEvent("printfire",false,true);=0A=
dispatchEvent(ev);=0A=
};=0A=
}=0A=
MochiKit.Logging.__new__();=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Logging);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.DateTime");=0A=
}=0A=
if(typeof (MochiKit)=3D=3D"undefined"){=0A=
MochiKit=3D{};=0A=
}=0A=
if(typeof (MochiKit.DateTime)=3D=3D"undefined"){=0A=
MochiKit.DateTime=3D{};=0A=
}=0A=
MochiKit.DateTime.NAME=3D"MochiKit.DateTime";=0A=
MochiKit.DateTime.VERSION=3D"1.3.1";=0A=
MochiKit.DateTime.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.DateTime.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.DateTime.isoDate=3Dfunction(str){=0A=
str=3Dstr+"";=0A=
if(typeof (str)!=3D"string"||str.length=3D=3D=3D0){=0A=
return null;=0A=
}=0A=
var iso=3Dstr.split("-");=0A=
if(iso.length=3D=3D=3D0){=0A=
return null;=0A=
}=0A=
return new Date(iso[0],iso[1]-1,iso[2]);=0A=
};=0A=
MochiKit.DateTime._isoRegexp=3D/(\d{4,})(?:-(\d{1,2})(?:-(\d{1,2})(?:[T =
](\d{1,2}):(\d{1,2})(?::(\d{1,2})(?:\.(\d+))?)?(?:(Z)|([+-])(\d{1,2})(?::=
(\d{1,2}))?)?)?)?)?/;=0A=
MochiKit.DateTime.isoTimestamp=3Dfunction(str){=0A=
str=3Dstr+"";=0A=
if(typeof (str)!=3D"string"||str.length=3D=3D=3D0){=0A=
return null;=0A=
}=0A=
var res=3Dstr.match(MochiKit.DateTime._isoRegexp);=0A=
if(typeof (res)=3D=3D"undefined"||res=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
var year,month,day,hour,min,sec,msec;=0A=
year=3DparseInt(res[1],10);=0A=
if(typeof (res[2])=3D=3D"undefined"||res[2]=3D=3D=3D""){=0A=
return new Date(year);=0A=
}=0A=
month=3DparseInt(res[2],10)-1;=0A=
day=3DparseInt(res[3],10);=0A=
if(typeof (res[4])=3D=3D"undefined"||res[4]=3D=3D=3D""){=0A=
return new Date(year,month,day);=0A=
}=0A=
hour=3DparseInt(res[4],10);=0A=
min=3DparseInt(res[5],10);=0A=
sec=3D(typeof =
(res[6])!=3D"undefined"&&res[6]!=3D=3D"")?parseInt(res[6],10):0;=0A=
if(typeof (res[7])!=3D"undefined"&&res[7]!=3D=3D""){=0A=
msec=3DMath.round(1000*parseFloat("0."+res[7]));=0A=
}else{=0A=
msec=3D0;=0A=
}=0A=
if((typeof (res[8])=3D=3D"undefined"||res[8]=3D=3D=3D"")&&(typeof =
(res[9])=3D=3D"undefined"||res[9]=3D=3D=3D"")){=0A=
return new Date(year,month,day,hour,min,sec,msec);=0A=
}=0A=
var ofs;=0A=
if(typeof (res[9])!=3D"undefined"&&res[9]!=3D=3D""){=0A=
ofs=3DparseInt(res[10],10)*3600000;=0A=
if(typeof (res[11])!=3D"undefined"&&res[11]!=3D=3D""){=0A=
ofs+=3DparseInt(res[11],10)*60000;=0A=
}=0A=
if(res[9]=3D=3D"-"){=0A=
ofs=3D-ofs;=0A=
}=0A=
}else{=0A=
ofs=3D0;=0A=
}=0A=
return new Date(Date.UTC(year,month,day,hour,min,sec,msec)-ofs);=0A=
};=0A=
MochiKit.DateTime.toISOTime=3Dfunction(date,_221){=0A=
if(typeof (date)=3D=3D"undefined"||date=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
var hh=3Ddate.getHours();=0A=
var mm=3Ddate.getMinutes();=0A=
var ss=3Ddate.getSeconds();=0A=
var =
lst=3D[((_221&&(hh<10))?"0"+hh:hh),((mm<10)?"0"+mm:mm),((ss<10)?"0"+ss:ss=
)];=0A=
return lst.join(":");=0A=
};=0A=
MochiKit.DateTime.toISOTimestamp=3Dfunction(date,_225){=0A=
if(typeof (date)=3D=3D"undefined"||date=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
var sep=3D_225?"T":" ";=0A=
var foot=3D_225?"Z":"";=0A=
if(_225){=0A=
date=3Dnew Date(date.getTime()+(date.getTimezoneOffset()*60000));=0A=
}=0A=
return =
MochiKit.DateTime.toISODate(date)+sep+MochiKit.DateTime.toISOTime(date,_2=
25)+foot;=0A=
};=0A=
MochiKit.DateTime.toISODate=3Dfunction(date){=0A=
if(typeof (date)=3D=3D"undefined"||date=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
var _228=3DMochiKit.DateTime._padTwo;=0A=
return =
[date.getFullYear(),_228(date.getMonth()+1),_228(date.getDate())].join("-=
");=0A=
};=0A=
MochiKit.DateTime.americanDate=3Dfunction(d){=0A=
d=3Dd+"";=0A=
if(typeof (d)!=3D"string"||d.length=3D=3D=3D0){=0A=
return null;=0A=
}=0A=
var a=3Dd.split("/");=0A=
return new Date(a[2],a[0]-1,a[1]);=0A=
};=0A=
MochiKit.DateTime._padTwo=3Dfunction(n){=0A=
return (n>9)?n:"0"+n;=0A=
};=0A=
MochiKit.DateTime.toPaddedAmericanDate=3Dfunction(d){=0A=
if(typeof (d)=3D=3D"undefined"||d=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
var _230=3DMochiKit.DateTime._padTwo;=0A=
return =
[_230(d.getMonth()+1),_230(d.getDate()),d.getFullYear()].join("/");=0A=
};=0A=
MochiKit.DateTime.toAmericanDate=3Dfunction(d){=0A=
if(typeof (d)=3D=3D"undefined"||d=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
return [d.getMonth()+1,d.getDate(),d.getFullYear()].join("/");=0A=
};=0A=
MochiKit.DateTime.EXPORT=3D["isoDate","isoTimestamp","toISOTime","toISOTi=
mestamp","toISODate","americanDate","toPaddedAmericanDate","toAmericanDat=
e"];=0A=
MochiKit.DateTime.EXPORT_OK=3D[];=0A=
MochiKit.DateTime.EXPORT_TAGS=3D{":common":MochiKit.DateTime.EXPORT,":all=
":MochiKit.DateTime.EXPORT};=0A=
MochiKit.DateTime.__new__=3Dfunction(){=0A=
var base=3Dthis.NAME+".";=0A=
for(var k in this){=0A=
var o=3Dthis[k];=0A=
if(typeof (o)=3D=3D"function"&&typeof (o.NAME)=3D=3D"undefined"){=0A=
try{=0A=
o.NAME=3Dbase+k;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
}=0A=
};=0A=
MochiKit.DateTime.__new__();=0A=
if(typeof (MochiKit.Base)!=3D"undefined"){=0A=
MochiKit.Base._exportSymbols(this,MochiKit.DateTime);=0A=
}else{=0A=
(function(_231,_232){=0A=
if((typeof (JSAN)=3D=3D"undefined"&&typeof =
(dojo)=3D=3D"undefined")||(typeof =
(MochiKit.__compat__)=3D=3D"boolean"&&MochiKit.__compat__)){=0A=
var all=3D_232.EXPORT_TAGS[":all"];=0A=
for(var i=3D0;i<all.length;i++){=0A=
_231[all[i]]=3D_232[all[i]];=0A=
}=0A=
}=0A=
})(this,MochiKit.DateTime);=0A=
}=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Format");=0A=
}=0A=
if(typeof (MochiKit)=3D=3D"undefined"){=0A=
MochiKit=3D{};=0A=
}=0A=
if(typeof (MochiKit.Format)=3D=3D"undefined"){=0A=
MochiKit.Format=3D{};=0A=
}=0A=
MochiKit.Format.NAME=3D"MochiKit.Format";=0A=
MochiKit.Format.VERSION=3D"1.3.1";=0A=
MochiKit.Format.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.Format.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.Format._numberFormatter=3Dfunction(_233,_234,_235,_236,_237,_238=
,_239,_240,_241){=0A=
return function(num){=0A=
num=3DparseFloat(num);=0A=
if(typeof (num)=3D=3D"undefined"||num=3D=3D=3Dnull||isNaN(num)){=0A=
return _233;=0A=
}=0A=
var _242=3D_234;=0A=
var _243=3D_235;=0A=
if(num<0){=0A=
num=3D-num;=0A=
}else{=0A=
_242=3D_242.replace(/-/,"");=0A=
}=0A=
var me=3Darguments.callee;=0A=
var fmt=3DMochiKit.Format.formatLocale(_236);=0A=
if(_237){=0A=
num=3Dnum*100;=0A=
_243=3Dfmt.percent+_243;=0A=
}=0A=
num=3DMochiKit.Format.roundToFixed(num,_238);=0A=
var _245=3Dnum.split(/\./);=0A=
var _246=3D_245[0];=0A=
var frac=3D(_245.length=3D=3D1)?"":_245[1];=0A=
var res=3D"";=0A=
while(_246.length<_239){=0A=
_246=3D"0"+_246;=0A=
}=0A=
if(_240){=0A=
while(_246.length>_240){=0A=
var i=3D_246.length-_240;=0A=
res=3Dfmt.separator+_246.substring(i,_246.length)+res;=0A=
_246=3D_246.substring(0,i);=0A=
}=0A=
}=0A=
res=3D_246+res;=0A=
if(_238>0){=0A=
while(frac.length<_241){=0A=
frac=3Dfrac+"0";=0A=
}=0A=
res=3Dres+fmt.decimal+frac;=0A=
}=0A=
return _242+res+_243;=0A=
};=0A=
};=0A=
MochiKit.Format.numberFormatter=3Dfunction(_248,_249,_250){=0A=
if(typeof (_249)=3D=3D"undefined"){=0A=
_249=3D"";=0A=
}=0A=
var _251=3D_248.match(/((?:[0#]+,)?[0#]+)(?:\.([0#]+))?(%)?/);=0A=
if(!_251){=0A=
throw TypeError("Invalid pattern");=0A=
}=0A=
var _252=3D_248.substr(0,_251.index);=0A=
var _253=3D_248.substr(_251.index+_251[0].length);=0A=
if(_252.search(/-/)=3D=3D-1){=0A=
_252=3D_252+"-";=0A=
}=0A=
var _254=3D_251[1];=0A=
var frac=3D(typeof (_251[2])=3D=3D"string"&&_251[2]!=3D"")?_251[2]:"";=0A=
var _255=3D(typeof (_251[3])=3D=3D"string"&&_251[3]!=3D"");=0A=
var tmp=3D_254.split(/,/);=0A=
var _257;=0A=
if(typeof (_250)=3D=3D"undefined"){=0A=
_250=3D"default";=0A=
}=0A=
if(tmp.length=3D=3D1){=0A=
_257=3Dnull;=0A=
}else{=0A=
_257=3Dtmp[1].length;=0A=
}=0A=
var _258=3D_254.length-_254.replace(/0/g,"").length;=0A=
var _259=3Dfrac.length-frac.replace(/0/g,"").length;=0A=
var _260=3Dfrac.length;=0A=
var =
rval=3DMochiKit.Format._numberFormatter(_249,_252,_253,_250,_255,_260,_25=
8,_257,_259);=0A=
var m=3DMochiKit.Base;=0A=
if(m){=0A=
var fn=3Darguments.callee;=0A=
var args=3Dm.concat(arguments);=0A=
rval.repr=3Dfunction(){=0A=
return [self.NAME,"(",map(m.repr,args).join(", "),")"].join("");=0A=
};=0A=
}=0A=
return rval;=0A=
};=0A=
MochiKit.Format.formatLocale=3Dfunction(_262){=0A=
if(typeof (_262)=3D=3D"undefined"||_262=3D=3D=3Dnull){=0A=
_262=3D"default";=0A=
}=0A=
if(typeof (_262)=3D=3D"string"){=0A=
var rval=3DMochiKit.Format.LOCALE[_262];=0A=
if(typeof (rval)=3D=3D"string"){=0A=
rval=3Darguments.callee(rval);=0A=
MochiKit.Format.LOCALE[_262]=3Drval;=0A=
}=0A=
return rval;=0A=
}else{=0A=
return _262;=0A=
}=0A=
};=0A=
MochiKit.Format.twoDigitAverage=3Dfunction(_263,_264){=0A=
if(_264){=0A=
var res=3D_263/_264;=0A=
if(!isNaN(res)){=0A=
return MochiKit.Format.twoDigitFloat(_263/_264);=0A=
}=0A=
}=0A=
return "0";=0A=
};=0A=
MochiKit.Format.twoDigitFloat=3Dfunction(_265){=0A=
var sign=3D(_265<0?"-":"");=0A=
var s=3DMath.floor(Math.abs(_265)*100).toString();=0A=
if(s=3D=3D"0"){=0A=
return s;=0A=
}=0A=
if(s.length<3){=0A=
while(s.charAt(s.length-1)=3D=3D"0"){=0A=
s=3Ds.substring(0,s.length-1);=0A=
}=0A=
return sign+"0."+s;=0A=
}=0A=
var head=3Dsign+s.substring(0,s.length-2);=0A=
var tail=3Ds.substring(s.length-2,s.length);=0A=
if(tail=3D=3D"00"){=0A=
return head;=0A=
}else{=0A=
if(tail.charAt(1)=3D=3D"0"){=0A=
return head+"."+tail.charAt(0);=0A=
}else{=0A=
return head+"."+tail;=0A=
}=0A=
}=0A=
};=0A=
MochiKit.Format.lstrip=3Dfunction(str,_270){=0A=
str=3Dstr+"";=0A=
if(typeof (str)!=3D"string"){=0A=
return null;=0A=
}=0A=
if(!_270){=0A=
return str.replace(/^\s+/,"");=0A=
}else{=0A=
return str.replace(new RegExp("^["+_270+"]+"),"");=0A=
}=0A=
};=0A=
MochiKit.Format.rstrip=3Dfunction(str,_271){=0A=
str=3Dstr+"";=0A=
if(typeof (str)!=3D"string"){=0A=
return null;=0A=
}=0A=
if(!_271){=0A=
return str.replace(/\s+$/,"");=0A=
}else{=0A=
return str.replace(new RegExp("["+_271+"]+$"),"");=0A=
}=0A=
};=0A=
MochiKit.Format.strip=3Dfunction(str,_272){=0A=
var self=3DMochiKit.Format;=0A=
return self.rstrip(self.lstrip(str,_272),_272);=0A=
};=0A=
MochiKit.Format.truncToFixed=3Dfunction(_273,_274){=0A=
_273=3DMath.floor(_273*Math.pow(10,_274));=0A=
var res=3D(_273*Math.pow(10,-_274)).toFixed(_274);=0A=
if(res.charAt(0)=3D=3D"."){=0A=
res=3D"0"+res;=0A=
}=0A=
return res;=0A=
};=0A=
MochiKit.Format.roundToFixed=3Dfunction(_275,_276){=0A=
return MochiKit.Format.truncToFixed(_275+0.5*Math.pow(10,-_276),_276);=0A=
};=0A=
MochiKit.Format.percentFormat=3Dfunction(_277){=0A=
return MochiKit.Format.twoDigitFloat(100*_277)+"%";=0A=
};=0A=
MochiKit.Format.EXPORT=3D["truncToFixed","roundToFixed","numberFormatter"=
,"formatLocale","twoDigitAverage","twoDigitFloat","percentFormat","lstrip=
","rstrip","strip"];=0A=
MochiKit.Format.LOCALE=3D{en_US:{separator:",",decimal:".",percent:"%"},d=
e_DE:{separator:".",decimal:",",percent:"%"},fr_FR:{separator:" =
",decimal:",",percent:"%"},"default":"en_US"};=0A=
MochiKit.Format.EXPORT_OK=3D[];=0A=
MochiKit.Format.EXPORT_TAGS=3D{":all":MochiKit.Format.EXPORT,":common":Mo=
chiKit.Format.EXPORT};=0A=
MochiKit.Format.__new__=3Dfunction(){=0A=
var base=3Dthis.NAME+".";=0A=
var k,v,o;=0A=
for(k in this.LOCALE){=0A=
o=3Dthis.LOCALE[k];=0A=
if(typeof (o)=3D=3D"object"){=0A=
o.repr=3Dfunction(){=0A=
return this.NAME;=0A=
};=0A=
o.NAME=3Dbase+"LOCALE."+k;=0A=
}=0A=
}=0A=
for(k in this){=0A=
o=3Dthis[k];=0A=
if(typeof (o)=3D=3D"function"&&typeof (o.NAME)=3D=3D"undefined"){=0A=
try{=0A=
o.NAME=3Dbase+k;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
}=0A=
};=0A=
MochiKit.Format.__new__();=0A=
if(typeof (MochiKit.Base)!=3D"undefined"){=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Format);=0A=
}else{=0A=
(function(_278,_279){=0A=
if((typeof (JSAN)=3D=3D"undefined"&&typeof =
(dojo)=3D=3D"undefined")||(typeof =
(MochiKit.__compat__)=3D=3D"boolean"&&MochiKit.__compat__)){=0A=
var all=3D_279.EXPORT_TAGS[":all"];=0A=
for(var i=3D0;i<all.length;i++){=0A=
_278[all[i]]=3D_279[all[i]];=0A=
}=0A=
}=0A=
})(this,MochiKit.Format);=0A=
}=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Async");=0A=
dojo.require("MochiKit.Base");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Async depends on MochiKit.Base!";=0A=
}=0A=
if(typeof (MochiKit.Async)=3D=3D"undefined"){=0A=
MochiKit.Async=3D{};=0A=
}=0A=
MochiKit.Async.NAME=3D"MochiKit.Async";=0A=
MochiKit.Async.VERSION=3D"1.3.1";=0A=
MochiKit.Async.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.Async.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.Async.Deferred=3Dfunction(_280){=0A=
this.chain=3D[];=0A=
this.id=3Dthis._nextId();=0A=
this.fired=3D-1;=0A=
this.paused=3D0;=0A=
this.results=3D[null,null];=0A=
this.canceller=3D_280;=0A=
this.silentlyCancelled=3Dfalse;=0A=
this.chained=3Dfalse;=0A=
};=0A=
MochiKit.Async.Deferred.prototype=3D{repr:function(){=0A=
var _281;=0A=
if(this.fired=3D=3D-1){=0A=
_281=3D"unfired";=0A=
}else{=0A=
if(this.fired=3D=3D=3D0){=0A=
_281=3D"success";=0A=
}else{=0A=
_281=3D"error";=0A=
}=0A=
}=0A=
return "Deferred("+this.id+", "+_281+")";=0A=
},toString:MochiKit.Base.forwardCall("repr"),_nextId:MochiKit.Base.counte=
r(),cancel:function(){=0A=
var self=3DMochiKit.Async;=0A=
if(this.fired=3D=3D-1){=0A=
if(this.canceller){=0A=
this.canceller(this);=0A=
}else{=0A=
this.silentlyCancelled=3Dtrue;=0A=
}=0A=
if(this.fired=3D=3D-1){=0A=
this.errback(new self.CancelledError(this));=0A=
}=0A=
}else{=0A=
if((this.fired=3D=3D=3D0)&&(this.results[0] instanceof self.Deferred)){=0A=
this.results[0].cancel();=0A=
}=0A=
}=0A=
},_pause:function(){=0A=
this.paused++;=0A=
},_unpause:function(){=0A=
this.paused--;=0A=
if((this.paused=3D=3D=3D0)&&(this.fired>=3D0)){=0A=
this._fire();=0A=
}=0A=
},_continue:function(res){=0A=
this._resback(res);=0A=
this._unpause();=0A=
},_resback:function(res){=0A=
this.fired=3D((res instanceof Error)?1:0);=0A=
this.results[this.fired]=3Dres;=0A=
this._fire();=0A=
},_check:function(){=0A=
if(this.fired!=3D-1){=0A=
if(!this.silentlyCancelled){=0A=
throw new MochiKit.Async.AlreadyCalledError(this);=0A=
}=0A=
this.silentlyCancelled=3Dfalse;=0A=
return;=0A=
}=0A=
},callback:function(res){=0A=
this._check();=0A=
if(res instanceof MochiKit.Async.Deferred){=0A=
throw new Error("Deferred instances can only be chained if they are the =
result of a callback");=0A=
}=0A=
this._resback(res);=0A=
},errback:function(res){=0A=
this._check();=0A=
var self=3DMochiKit.Async;=0A=
if(res instanceof self.Deferred){=0A=
throw new Error("Deferred instances can only be chained if they are the =
result of a callback");=0A=
}=0A=
if(!(res instanceof Error)){=0A=
res=3Dnew self.GenericError(res);=0A=
}=0A=
this._resback(res);=0A=
},addBoth:function(fn){=0A=
if(arguments.length>1){=0A=
fn=3DMochiKit.Base.partial.apply(null,arguments);=0A=
}=0A=
return this.addCallbacks(fn,fn);=0A=
},addCallback:function(fn){=0A=
if(arguments.length>1){=0A=
fn=3DMochiKit.Base.partial.apply(null,arguments);=0A=
}=0A=
return this.addCallbacks(fn,null);=0A=
},addErrback:function(fn){=0A=
if(arguments.length>1){=0A=
fn=3DMochiKit.Base.partial.apply(null,arguments);=0A=
}=0A=
return this.addCallbacks(null,fn);=0A=
},addCallbacks:function(cb,eb){=0A=
if(this.chained){=0A=
throw new Error("Chained Deferreds can not be re-used");=0A=
}=0A=
this.chain.push([cb,eb]);=0A=
if(this.fired>=3D0){=0A=
this._fire();=0A=
}=0A=
return this;=0A=
},_fire:function(){=0A=
var _284=3Dthis.chain;=0A=
var _285=3Dthis.fired;=0A=
var res=3Dthis.results[_285];=0A=
var self=3Dthis;=0A=
var cb=3Dnull;=0A=
while(_284.length>0&&this.paused=3D=3D=3D0){=0A=
var pair=3D_284.shift();=0A=
var f=3Dpair[_285];=0A=
if(f=3D=3D=3Dnull){=0A=
continue;=0A=
}=0A=
try{=0A=
res=3Df(res);=0A=
_285=3D((res instanceof Error)?1:0);=0A=
if(res instanceof MochiKit.Async.Deferred){=0A=
cb=3Dfunction(res){=0A=
self._continue(res);=0A=
};=0A=
this._pause();=0A=
}=0A=
}=0A=
catch(err){=0A=
_285=3D1;=0A=
if(!(err instanceof Error)){=0A=
err=3Dnew MochiKit.Async.GenericError(err);=0A=
}=0A=
res=3Derr;=0A=
}=0A=
}=0A=
this.fired=3D_285;=0A=
this.results[_285]=3Dres;=0A=
if(cb&&this.paused){=0A=
res.addBoth(cb);=0A=
res.chained=3Dtrue;=0A=
}=0A=
}};=0A=
MochiKit.Base.update(MochiKit.Async,{evalJSONRequest:function(){=0A=
return eval("("+arguments[0].responseText+")");=0A=
},succeed:function(_287){=0A=
var d=3Dnew MochiKit.Async.Deferred();=0A=
d.callback.apply(d,arguments);=0A=
return d;=0A=
},fail:function(_288){=0A=
var d=3Dnew MochiKit.Async.Deferred();=0A=
d.errback.apply(d,arguments);=0A=
return d;=0A=
},getXMLHttpRequest:function(){=0A=
var self=3Darguments.callee;=0A=
if(!self.XMLHttpRequest){=0A=
var _289=3D[function(){=0A=
return new XMLHttpRequest();=0A=
},function(){=0A=
return new ActiveXObject("Msxml2.XMLHTTP");=0A=
},function(){=0A=
return new ActiveXObject("Microsoft.XMLHTTP");=0A=
},function(){=0A=
return new ActiveXObject("Msxml2.XMLHTTP.4.0");=0A=
},function(){=0A=
throw new MochiKit.Async.BrowserComplianceError("Browser does not =
support XMLHttpRequest");=0A=
}];=0A=
for(var i=3D0;i<_289.length;i++){=0A=
var func=3D_289[i];=0A=
try{=0A=
self.XMLHttpRequest=3Dfunc;=0A=
return func();=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
}=0A=
return self.XMLHttpRequest();=0A=
},_nothing:function(){=0A=
},_xhr_onreadystatechange:function(d){=0A=
if(this.readyState=3D=3D4){=0A=
try{=0A=
this.onreadystatechange=3Dnull;=0A=
}=0A=
catch(e){=0A=
try{=0A=
this.onreadystatechange=3DMochiKit.Async._nothing;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
var _290=3Dnull;=0A=
try{=0A=
_290=3Dthis.status;=0A=
if(!_290&&MochiKit.Base.isNotEmpty(this.responseText)){=0A=
_290=3D304;=0A=
}=0A=
}=0A=
catch(e){=0A=
}=0A=
if(_290=3D=3D200||_290=3D=3D304){=0A=
d.callback(this);=0A=
}else{=0A=
var err=3Dnew MochiKit.Async.XMLHttpRequestError(this,"Request failed");=0A=
if(err.number){=0A=
d.errback(err);=0A=
}else{=0A=
d.errback(err);=0A=
}=0A=
}=0A=
}=0A=
},_xhr_canceller:function(req){=0A=
try{=0A=
req.onreadystatechange=3Dnull;=0A=
}=0A=
catch(e){=0A=
try{=0A=
req.onreadystatechange=3DMochiKit.Async._nothing;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
req.abort();=0A=
},sendXMLHttpRequest:function(req,_293){=0A=
if(typeof (_293)=3D=3D"undefined"||_293=3D=3D=3Dnull){=0A=
_293=3D"";=0A=
}=0A=
var m=3DMochiKit.Base;=0A=
var self=3DMochiKit.Async;=0A=
var d=3Dnew self.Deferred(m.partial(self._xhr_canceller,req));=0A=
try{=0A=
req.onreadystatechange=3Dm.bind(self._xhr_onreadystatechange,req,d);=0A=
req.send(_293);=0A=
}=0A=
catch(e){=0A=
try{=0A=
req.onreadystatechange=3Dnull;=0A=
}=0A=
catch(ignore){=0A=
}=0A=
d.errback(e);=0A=
}=0A=
return d;=0A=
},doSimpleXMLHttpRequest:function(url){=0A=
var self=3DMochiKit.Async;=0A=
var req=3Dself.getXMLHttpRequest();=0A=
if(arguments.length>1){=0A=
var m=3DMochiKit.Base;=0A=
var qs=3Dm.queryString.apply(null,m.extend(null,arguments,1));=0A=
if(qs){=0A=
url+=3D"?"+qs;=0A=
}=0A=
}=0A=
req.open("GET",url,true);=0A=
return self.sendXMLHttpRequest(req);=0A=
},loadJSONDoc:function(url){=0A=
var self=3DMochiKit.Async;=0A=
var d=3Dself.doSimpleXMLHttpRequest.apply(self,arguments);=0A=
d=3Dd.addCallback(self.evalJSONRequest);=0A=
return d;=0A=
},wait:function(_296,_297){=0A=
var d=3Dnew MochiKit.Async.Deferred();=0A=
var m=3DMochiKit.Base;=0A=
if(typeof (_297)!=3D"undefined"){=0A=
d.addCallback(function(){=0A=
return _297;=0A=
});=0A=
}=0A=
var _298=3DsetTimeout(m.bind("callback",d),Math.floor(_296*1000));=0A=
d.canceller=3Dfunction(){=0A=
try{=0A=
clearTimeout(_298);=0A=
}=0A=
catch(e){=0A=
}=0A=
};=0A=
return d;=0A=
},callLater:function(_299,func){=0A=
var m=3DMochiKit.Base;=0A=
var _300=3Dm.partial.apply(m,m.extend(null,arguments,1));=0A=
return MochiKit.Async.wait(_299).addCallback(function(res){=0A=
return _300();=0A=
});=0A=
}});=0A=
MochiKit.Async.DeferredLock=3Dfunction(){=0A=
this.waiting=3D[];=0A=
this.locked=3Dfalse;=0A=
this.id=3Dthis._nextId();=0A=
};=0A=
MochiKit.Async.DeferredLock.prototype=3D{__class__:MochiKit.Async.Deferre=
dLock,acquire:function(){=0A=
d=3Dnew MochiKit.Async.Deferred();=0A=
if(this.locked){=0A=
this.waiting.push(d);=0A=
}else{=0A=
this.locked=3Dtrue;=0A=
d.callback(this);=0A=
}=0A=
return d;=0A=
},release:function(){=0A=
if(!this.locked){=0A=
throw TypeError("Tried to release an unlocked DeferredLock");=0A=
}=0A=
this.locked=3Dfalse;=0A=
if(this.waiting.length>0){=0A=
this.locked=3Dtrue;=0A=
this.waiting.shift().callback(this);=0A=
}=0A=
},_nextId:MochiKit.Base.counter(),repr:function(){=0A=
var _301;=0A=
if(this.locked){=0A=
_301=3D"locked, "+this.waiting.length+" waiting";=0A=
}else{=0A=
_301=3D"unlocked";=0A=
}=0A=
return "DeferredLock("+this.id+", "+_301+")";=0A=
},toString:MochiKit.Base.forwardCall("repr")};=0A=
MochiKit.Async.DeferredList=3Dfunction(list,_303,_304,_305,_306){=0A=
this.list=3Dlist;=0A=
this.resultList=3Dnew Array(this.list.length);=0A=
this.chain=3D[];=0A=
this.id=3Dthis._nextId();=0A=
this.fired=3D-1;=0A=
this.paused=3D0;=0A=
this.results=3D[null,null];=0A=
this.canceller=3D_306;=0A=
this.silentlyCancelled=3Dfalse;=0A=
if(this.list.length=3D=3D=3D0&&!_303){=0A=
this.callback(this.resultList);=0A=
}=0A=
this.finishedCount=3D0;=0A=
this.fireOnOneCallback=3D_303;=0A=
this.fireOnOneErrback=3D_304;=0A=
this.consumeErrors=3D_305;=0A=
var _307=3D0;=0A=
MochiKit.Base.map(MochiKit.Base.bind(function(d){=0A=
d.addCallback(MochiKit.Base.bind(this._cbDeferred,this),_307,true);=0A=
d.addErrback(MochiKit.Base.bind(this._cbDeferred,this),_307,false);=0A=
_307+=3D1;=0A=
},this),this.list);=0A=
};=0A=
MochiKit.Base.update(MochiKit.Async.DeferredList.prototype,MochiKit.Async=
.Deferred.prototype);=0A=
MochiKit.Base.update(MochiKit.Async.DeferredList.prototype,{_cbDeferred:f=
unction(_308,_309,_310){=0A=
this.resultList[_308]=3D[_309,_310];=0A=
this.finishedCount+=3D1;=0A=
if(this.fired!=3D=3D0){=0A=
if(_309&&this.fireOnOneCallback){=0A=
this.callback([_308,_310]);=0A=
}else{=0A=
if(!_309&&this.fireOnOneErrback){=0A=
this.errback(_310);=0A=
}else{=0A=
if(this.finishedCount=3D=3Dthis.list.length){=0A=
this.callback(this.resultList);=0A=
}=0A=
}=0A=
}=0A=
}=0A=
if(!_309&&this.consumeErrors){=0A=
_310=3Dnull;=0A=
}=0A=
return _310;=0A=
}});=0A=
MochiKit.Async.gatherResults=3Dfunction(_311){=0A=
var d=3Dnew MochiKit.Async.DeferredList(_311,false,true,false);=0A=
d.addCallback(function(_312){=0A=
var ret=3D[];=0A=
for(var i=3D0;i<_312.length;i++){=0A=
ret.push(_312[i][1]);=0A=
}=0A=
return ret;=0A=
});=0A=
return d;=0A=
};=0A=
MochiKit.Async.maybeDeferred=3Dfunction(func){=0A=
var self=3DMochiKit.Async;=0A=
var _313;=0A=
try{=0A=
var r=3Dfunc.apply(null,MochiKit.Base.extend([],arguments,1));=0A=
if(r instanceof self.Deferred){=0A=
_313=3Dr;=0A=
}else{=0A=
if(r instanceof Error){=0A=
_313=3Dself.fail(r);=0A=
}else{=0A=
_313=3Dself.succeed(r);=0A=
}=0A=
}=0A=
}=0A=
catch(e){=0A=
_313=3Dself.fail(e);=0A=
}=0A=
return _313;=0A=
};=0A=
MochiKit.Async.EXPORT=3D["AlreadyCalledError","CancelledError","BrowserCo=
mplianceError","GenericError","XMLHttpRequestError","Deferred","succeed",=
"fail","getXMLHttpRequest","doSimpleXMLHttpRequest","loadJSONDoc","wait",=
"callLater","sendXMLHttpRequest","DeferredLock","DeferredList","gatherRes=
ults","maybeDeferred"];=0A=
MochiKit.Async.EXPORT_OK=3D["evalJSONRequest"];=0A=
MochiKit.Async.__new__=3Dfunction(){=0A=
var m=3DMochiKit.Base;=0A=
var ne=3Dm.partial(m._newNamedError,this);=0A=
ne("AlreadyCalledError",function(_316){=0A=
this.deferred=3D_316;=0A=
});=0A=
ne("CancelledError",function(_317){=0A=
this.deferred=3D_317;=0A=
});=0A=
ne("BrowserComplianceError",function(msg){=0A=
this.message=3Dmsg;=0A=
});=0A=
ne("GenericError",function(msg){=0A=
this.message=3Dmsg;=0A=
});=0A=
ne("XMLHttpRequestError",function(req,msg){=0A=
this.req=3Dreq;=0A=
this.message=3Dmsg;=0A=
try{=0A=
this.number=3Dreq.status;=0A=
}=0A=
catch(e){=0A=
}=0A=
});=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
m.nameFunctions(this);=0A=
};=0A=
MochiKit.Async.__new__();=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Async);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.DOM");=0A=
dojo.require("MochiKit.Iter");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Iter",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Iter)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.DOM depends on MochiKit.Iter!";=0A=
}=0A=
if(typeof (MochiKit.DOM)=3D=3D"undefined"){=0A=
MochiKit.DOM=3D{};=0A=
}=0A=
MochiKit.DOM.NAME=3D"MochiKit.DOM";=0A=
MochiKit.DOM.VERSION=3D"1.3.1";=0A=
MochiKit.DOM.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.DOM.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.DOM.EXPORT=3D["formContents","currentWindow","currentDocument","=
withWindow","withDocument","registerDOMConverter","coerceToDOM","createDO=
M","createDOMFunc","getNodeAttribute","setNodeAttribute","updateNodeAttri=
butes","appendChildNodes","replaceChildNodes","removeElement","swapDOM","=
BUTTON","TT","PRE","H1","H2","H3","BR","CANVAS","HR","LABEL","TEXTAREA","=
FORM","STRONG","SELECT","OPTION","OPTGROUP","LEGEND","FIELDSET","P","UL",=
"OL","LI","TD","TR","THEAD","TBODY","TFOOT","TABLE","TH","INPUT","SPAN","=
A","DIV","IMG","getElement","$","computedStyle","getElementsByTagAndClass=
Name","addToCallStack","addLoadEvent","focusOnLoad","setElementClass","to=
ggleElementClass","addElementClass","removeElementClass","swapElementClas=
s","hasElementClass","escapeHTML","toHTML","emitHTML","setDisplayForEleme=
nt","hideElement","showElement","scrapeText","elementDimensions","element=
Position","setElementDimensions","setElementPosition","getViewportDimensi=
ons","setOpacity"];=0A=
MochiKit.DOM.EXPORT_OK=3D["domConverters"];=0A=
MochiKit.DOM.Dimensions=3Dfunction(w,h){=0A=
this.w=3Dw;=0A=
this.h=3Dh;=0A=
};=0A=
MochiKit.DOM.Dimensions.prototype.repr=3Dfunction(){=0A=
var repr=3DMochiKit.Base.repr;=0A=
return "{w: "+repr(this.w)+", h: "+repr(this.h)+"}";=0A=
};=0A=
MochiKit.DOM.Coordinates=3Dfunction(x,y){=0A=
this.x=3Dx;=0A=
this.y=3Dy;=0A=
};=0A=
MochiKit.DOM.Coordinates.prototype.repr=3Dfunction(){=0A=
var repr=3DMochiKit.Base.repr;=0A=
return "{x: "+repr(this.x)+", y: "+repr(this.y)+"}";=0A=
};=0A=
MochiKit.DOM.Coordinates.prototype.toString=3Dfunction(){=0A=
return this.repr();=0A=
};=0A=
MochiKit.Base.update(MochiKit.DOM,{setOpacity:function(elem,o){=0A=
elem=3DMochiKit.DOM.getElement(elem);=0A=
MochiKit.DOM.updateNodeAttributes(elem,{"style":{"opacity":o,"-moz-opacit=
y":o,"-khtml-opacity":o,"filter":" alpha(opacity=3D"+(o*100)+")"}});=0A=
},getViewportDimensions:function(){=0A=
var d=3Dnew MochiKit.DOM.Dimensions();=0A=
var w=3DMochiKit.DOM._window;=0A=
var b=3DMochiKit.DOM._document.body;=0A=
if(w.innerWidth){=0A=
d.w=3Dw.innerWidth;=0A=
d.h=3Dw.innerHeight;=0A=
}else{=0A=
if(b.parentElement.clientWidth){=0A=
d.w=3Db.parentElement.clientWidth;=0A=
d.h=3Db.parentElement.clientHeight;=0A=
}else{=0A=
if(b&&b.clientWidth){=0A=
d.w=3Db.clientWidth;=0A=
d.h=3Db.clientHeight;=0A=
}=0A=
}=0A=
}=0A=
return d;=0A=
},elementDimensions:function(elem){=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (elem.w)=3D=3D"number"||typeof (elem.h)=3D=3D"number"){=0A=
return new self.Dimensions(elem.w||0,elem.h||0);=0A=
}=0A=
elem=3Dself.getElement(elem);=0A=
if(!elem){=0A=
return undefined;=0A=
}=0A=
if(self.computedStyle(elem,"display")!=3D"none"){=0A=
return new self.Dimensions(elem.offsetWidth||0,elem.offsetHeight||0);=0A=
}=0A=
var s=3Delem.style;=0A=
var _322=3Ds.visibility;=0A=
var _323=3Ds.position;=0A=
s.visibility=3D"hidden";=0A=
s.position=3D"absolute";=0A=
s.display=3D"";=0A=
var _324=3Delem.offsetWidth;=0A=
var _325=3Delem.offsetHeight;=0A=
s.display=3D"none";=0A=
s.position=3D_323;=0A=
s.visibility=3D_322;=0A=
return new self.Dimensions(_324,_325);=0A=
},elementPosition:function(elem,_326){=0A=
var self=3DMochiKit.DOM;=0A=
elem=3Dself.getElement(elem);=0A=
if(!elem){=0A=
return undefined;=0A=
}=0A=
var c=3Dnew self.Coordinates(0,0);=0A=
if(elem.x&&elem.y){=0A=
c.x+=3Delem.x||0;=0A=
c.y+=3Delem.y||0;=0A=
return c;=0A=
}else{=0A=
if(elem.parentNode=3D=3D=3Dnull||self.computedStyle(elem,"display")=3D=3D=
"none"){=0A=
return undefined;=0A=
}=0A=
}=0A=
var box=3Dnull;=0A=
var _329=3Dnull;=0A=
var d=3DMochiKit.DOM._document;=0A=
var de=3Dd.documentElement;=0A=
var b=3Dd.body;=0A=
if(elem.getBoundingClientRect){=0A=
box=3Delem.getBoundingClientRect();=0A=
c.x+=3Dbox.left+(de.scrollLeft||b.scrollLeft)-(de.clientLeft||b.clientLef=
t);=0A=
c.y+=3Dbox.top+(de.scrollTop||b.scrollTop)-(de.clientTop||b.clientTop);=0A=
}else{=0A=
if(d.getBoxObjectFor){=0A=
box=3Dd.getBoxObjectFor(elem);=0A=
c.x+=3Dbox.x;=0A=
c.y+=3Dbox.y;=0A=
}else{=0A=
if(elem.offsetParent){=0A=
c.x+=3Delem.offsetLeft;=0A=
c.y+=3Delem.offsetTop;=0A=
_329=3Delem.offsetParent;=0A=
if(_329!=3Delem){=0A=
while(_329){=0A=
c.x+=3D_329.offsetLeft;=0A=
c.y+=3D_329.offsetTop;=0A=
_329=3D_329.offsetParent;=0A=
}=0A=
}=0A=
var ua=3Dnavigator.userAgent.toLowerCase();=0A=
if((typeof =
(opera)!=3D"undefined"&&parseFloat(opera.version())<9)||(ua.indexOf("safa=
ri")!=3D-1&&self.computedStyle(elem,"position")=3D=3D"absolute")){=0A=
c.x-=3Db.offsetLeft;=0A=
c.y-=3Db.offsetTop;=0A=
}=0A=
}=0A=
}=0A=
}=0A=
if(typeof (_326)!=3D"undefined"){=0A=
_326=3Darguments.callee(_326);=0A=
if(_326){=0A=
c.x-=3D(_326.x||0);=0A=
c.y-=3D(_326.y||0);=0A=
}=0A=
}=0A=
if(elem.parentNode){=0A=
_329=3Delem.parentNode;=0A=
}else{=0A=
_329=3Dnull;=0A=
}=0A=
while(_329&&_329.tagName!=3D"BODY"&&_329.tagName!=3D"HTML"){=0A=
c.x-=3D_329.scrollLeft;=0A=
c.y-=3D_329.scrollTop;=0A=
if(_329.parentNode){=0A=
_329=3D_329.parentNode;=0A=
}else{=0A=
_329=3Dnull;=0A=
}=0A=
}=0A=
return c;=0A=
},setElementDimensions:function(elem,_332,_333){=0A=
elem=3DMochiKit.DOM.getElement(elem);=0A=
if(typeof (_333)=3D=3D"undefined"){=0A=
_333=3D"px";=0A=
}=0A=
MochiKit.DOM.updateNodeAttributes(elem,{"style":{"width":_332.w+_333,"hei=
ght":_332.h+_333}});=0A=
},setElementPosition:function(elem,_334,_335){=0A=
elem=3DMochiKit.DOM.getElement(elem);=0A=
if(typeof (_335)=3D=3D"undefined"){=0A=
_335=3D"px";=0A=
}=0A=
MochiKit.DOM.updateNodeAttributes(elem,{"style":{"left":_334.x+_335,"top"=
:_334.y+_335}});=0A=
},currentWindow:function(){=0A=
return MochiKit.DOM._window;=0A=
},currentDocument:function(){=0A=
return MochiKit.DOM._document;=0A=
},withWindow:function(win,func){=0A=
var self=3DMochiKit.DOM;=0A=
var _337=3Dself._document;=0A=
var _338=3Dself._win;=0A=
var rval;=0A=
try{=0A=
self._window=3Dwin;=0A=
self._document=3Dwin.document;=0A=
rval=3Dfunc();=0A=
}=0A=
catch(e){=0A=
self._window=3D_338;=0A=
self._document=3D_337;=0A=
throw e;=0A=
}=0A=
self._window=3D_338;=0A=
self._document=3D_337;=0A=
return rval;=0A=
},formContents:function(elem){=0A=
var _339=3D[];=0A=
var _340=3D[];=0A=
var m=3DMochiKit.Base;=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (elem)=3D=3D"undefined"||elem=3D=3D=3Dnull){=0A=
elem=3Dself._document;=0A=
}else{=0A=
elem=3Dself.getElement(elem);=0A=
}=0A=
m.nodeWalk(elem,function(elem){=0A=
var name=3Delem.name;=0A=
if(m.isNotEmpty(name)){=0A=
var _341=3Delem.nodeName;=0A=
if(_341=3D=3D"INPUT"&&(elem.type=3D=3D"radio"||elem.type=3D=3D"checkbox")=
&&!elem.checked){=0A=
return null;=0A=
}=0A=
if(_341=3D=3D"SELECT"){=0A=
if(elem.selectedIndex>=3D0){=0A=
var opt=3Delem.options[elem.selectedIndex];=0A=
_339.push(name);=0A=
_340.push((opt.value)?opt.value:opt.text);=0A=
return null;=0A=
}=0A=
_339.push(name);=0A=
_340.push("");=0A=
return null;=0A=
}=0A=
if(_341=3D=3D"FORM"||_341=3D=3D"P"||_341=3D=3D"SPAN"||_341=3D=3D"DIV"){=0A=
return elem.childNodes;=0A=
}=0A=
_339.push(name);=0A=
_340.push(elem.value||"");=0A=
return null;=0A=
}=0A=
return elem.childNodes;=0A=
});=0A=
return [_339,_340];=0A=
},withDocument:function(doc,func){=0A=
var self=3DMochiKit.DOM;=0A=
var _344=3Dself._document;=0A=
var rval;=0A=
try{=0A=
self._document=3Ddoc;=0A=
rval=3Dfunc();=0A=
}=0A=
catch(e){=0A=
self._document=3D_344;=0A=
throw e;=0A=
}=0A=
self._document=3D_344;=0A=
return rval;=0A=
},registerDOMConverter:function(name,_345,wrap,_346){=0A=
MochiKit.DOM.domConverters.register(name,_345,wrap,_346);=0A=
},coerceToDOM:function(node,ctx){=0A=
var im=3DMochiKit.Iter;=0A=
var self=3DMochiKit.DOM;=0A=
var iter=3Dim.iter;=0A=
var _350=3Dim.repeat;=0A=
var imap=3Dim.imap;=0A=
var _352=3Dself.domConverters;=0A=
var _353=3Dself.coerceToDOM;=0A=
var _354=3DMochiKit.Base.NotFound;=0A=
while(true){=0A=
if(typeof (node)=3D=3D"undefined"||node=3D=3D=3Dnull){=0A=
return null;=0A=
}=0A=
if(typeof (node.nodeType)!=3D"undefined"&&node.nodeType>0){=0A=
return node;=0A=
}=0A=
if(typeof (node)=3D=3D"number"||typeof (node)=3D=3D"boolean"){=0A=
node=3Dnode.toString();=0A=
}=0A=
if(typeof (node)=3D=3D"string"){=0A=
return self._document.createTextNode(node);=0A=
}=0A=
if(typeof (node.toDOM)=3D=3D"function"){=0A=
node=3Dnode.toDOM(ctx);=0A=
continue;=0A=
}=0A=
if(typeof (node)=3D=3D"function"){=0A=
node=3Dnode(ctx);=0A=
continue;=0A=
}=0A=
var _355=3Dnull;=0A=
try{=0A=
_355=3Diter(node);=0A=
}=0A=
catch(e){=0A=
}=0A=
if(_355){=0A=
return imap(_353,_355,_350(ctx));=0A=
}=0A=
try{=0A=
node=3D_352.match(node,ctx);=0A=
continue;=0A=
}=0A=
catch(e){=0A=
if(e!=3D_354){=0A=
throw e;=0A=
}=0A=
}=0A=
return self._document.createTextNode(node.toString());=0A=
}=0A=
return undefined;=0A=
},setNodeAttribute:function(node,attr,_357){=0A=
var o=3D{};=0A=
o[attr]=3D_357;=0A=
try{=0A=
return MochiKit.DOM.updateNodeAttributes(node,o);=0A=
}=0A=
catch(e){=0A=
}=0A=
return null;=0A=
},getNodeAttribute:function(node,attr){=0A=
var self=3DMochiKit.DOM;=0A=
var _358=3Dself.attributeArray.renames[attr];=0A=
node=3Dself.getElement(node);=0A=
try{=0A=
if(_358){=0A=
return node[_358];=0A=
}=0A=
return node.getAttribute(attr);=0A=
}=0A=
catch(e){=0A=
}=0A=
return null;=0A=
},updateNodeAttributes:function(node,_359){=0A=
var elem=3Dnode;=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (node)=3D=3D"string"){=0A=
elem=3Dself.getElement(node);=0A=
}=0A=
if(_359){=0A=
var _360=3DMochiKit.Base.updatetree;=0A=
if(self.attributeArray.compliant){=0A=
for(var k in _359){=0A=
var v=3D_359[k];=0A=
if(typeof (v)=3D=3D"object"&&typeof (elem[k])=3D=3D"object"){=0A=
_360(elem[k],v);=0A=
}else{=0A=
if(k.substring(0,2)=3D=3D"on"){=0A=
if(typeof (v)=3D=3D"string"){=0A=
v=3Dnew Function(v);=0A=
}=0A=
elem[k]=3Dv;=0A=
}else{=0A=
elem.setAttribute(k,v);=0A=
}=0A=
}=0A=
}=0A=
}else{=0A=
var _361=3Dself.attributeArray.renames;=0A=
for(k in _359){=0A=
v=3D_359[k];=0A=
var _362=3D_361[k];=0A=
if(k=3D=3D"style"&&typeof (v)=3D=3D"string"){=0A=
elem.style.cssText=3Dv;=0A=
}else{=0A=
if(typeof (_362)=3D=3D"string"){=0A=
elem[_362]=3Dv;=0A=
}else{=0A=
if(typeof (elem[k])=3D=3D"object"&&typeof (v)=3D=3D"object"){=0A=
_360(elem[k],v);=0A=
}else{=0A=
if(k.substring(0,2)=3D=3D"on"){=0A=
if(typeof (v)=3D=3D"string"){=0A=
v=3Dnew Function(v);=0A=
}=0A=
elem[k]=3Dv;=0A=
}else{=0A=
elem.setAttribute(k,v);=0A=
}=0A=
}=0A=
}=0A=
}=0A=
}=0A=
}=0A=
}=0A=
return elem;=0A=
},appendChildNodes:function(node){=0A=
var elem=3Dnode;=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (node)=3D=3D"string"){=0A=
elem=3Dself.getElement(node);=0A=
}=0A=
var =
_363=3D[self.coerceToDOM(MochiKit.Base.extend(null,arguments,1),elem)];=0A=
var _364=3DMochiKit.Base.concat;=0A=
while(_363.length){=0A=
var n=3D_363.shift();=0A=
if(typeof (n)=3D=3D"undefined"||n=3D=3D=3Dnull){=0A=
}else{=0A=
if(typeof (n.nodeType)=3D=3D"number"){=0A=
elem.appendChild(n);=0A=
}else{=0A=
_363=3D_364(n,_363);=0A=
}=0A=
}=0A=
}=0A=
return elem;=0A=
},replaceChildNodes:function(node){=0A=
var elem=3Dnode;=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (node)=3D=3D"string"){=0A=
elem=3Dself.getElement(node);=0A=
arguments[0]=3Delem;=0A=
}=0A=
var _365;=0A=
while((_365=3Delem.firstChild)){=0A=
elem.removeChild(_365);=0A=
}=0A=
if(arguments.length<2){=0A=
return elem;=0A=
}else{=0A=
return self.appendChildNodes.apply(this,arguments);=0A=
}=0A=
},createDOM:function(name,_366){=0A=
var elem;=0A=
var self=3DMochiKit.DOM;=0A=
var m=3DMochiKit.Base;=0A=
if(typeof (_366)=3D=3D"string"||typeof (_366)=3D=3D"number"){=0A=
var args=3Dm.extend([name,null],arguments,1);=0A=
return arguments.callee.apply(this,args);=0A=
}=0A=
if(typeof (name)=3D=3D"string"){=0A=
if(_366&&"name" in _366&&!self.attributeArray.compliant){=0A=
name=3D("<"+name+" name=3D\""+self.escapeHTML(_366.name)+"\">");=0A=
}=0A=
elem=3Dself._document.createElement(name);=0A=
}else{=0A=
elem=3Dname;=0A=
}=0A=
if(_366){=0A=
self.updateNodeAttributes(elem,_366);=0A=
}=0A=
if(arguments.length<=3D2){=0A=
return elem;=0A=
}else{=0A=
var args=3Dm.extend([elem],arguments,2);=0A=
return self.appendChildNodes.apply(this,args);=0A=
}=0A=
},createDOMFunc:function(){=0A=
var m=3DMochiKit.Base;=0A=
return =
m.partial.apply(this,m.extend([MochiKit.DOM.createDOM],arguments));=0A=
},swapDOM:function(dest,src){=0A=
var self=3DMochiKit.DOM;=0A=
dest=3Dself.getElement(dest);=0A=
var _369=3Ddest.parentNode;=0A=
if(src){=0A=
src=3Dself.getElement(src);=0A=
_369.replaceChild(src,dest);=0A=
}else{=0A=
_369.removeChild(dest);=0A=
}=0A=
return src;=0A=
},getElement:function(id){=0A=
var self=3DMochiKit.DOM;=0A=
if(arguments.length=3D=3D1){=0A=
return ((typeof =
(id)=3D=3D"string")?self._document.getElementById(id):id);=0A=
}else{=0A=
return MochiKit.Base.map(self.getElement,arguments);=0A=
}=0A=
},computedStyle:function(_371,_372,_373){=0A=
if(arguments.length=3D=3D2){=0A=
_373=3D_372;=0A=
}=0A=
var self=3DMochiKit.DOM;=0A=
var el=3Dself.getElement(_371);=0A=
var _375=3Dself._document;=0A=
if(!el||el=3D=3D_375){=0A=
return undefined;=0A=
}=0A=
if(el.currentStyle){=0A=
return el.currentStyle[_372];=0A=
}=0A=
if(typeof (_375.defaultView)=3D=3D"undefined"){=0A=
return undefined;=0A=
}=0A=
if(_375.defaultView=3D=3D=3Dnull){=0A=
return undefined;=0A=
}=0A=
var _376=3D_375.defaultView.getComputedStyle(el,null);=0A=
if(typeof (_376)=3D=3D"undefined"||_376=3D=3D=3Dnull){=0A=
return undefined;=0A=
}=0A=
return _376.getPropertyValue(_373);=0A=
},getElementsByTagAndClassName:function(_377,_378,_379){=0A=
var self=3DMochiKit.DOM;=0A=
if(typeof (_377)=3D=3D"undefined"||_377=3D=3D=3Dnull){=0A=
_377=3D"*";=0A=
}=0A=
if(typeof (_379)=3D=3D"undefined"||_379=3D=3D=3Dnull){=0A=
_379=3Dself._document;=0A=
}=0A=
_379=3Dself.getElement(_379);=0A=
var _380=3D(_379.getElementsByTagName(_377)||self._document.all);=0A=
if(typeof (_378)=3D=3D"undefined"||_378=3D=3D=3Dnull){=0A=
return MochiKit.Base.extend(null,_380);=0A=
}=0A=
var _381=3D[];=0A=
for(var i=3D0;i<_380.length;i++){=0A=
var _382=3D_380[i];=0A=
var _383=3D_382.className.split(" ");=0A=
for(var j=3D0;j<_383.length;j++){=0A=
if(_383[j]=3D=3D_378){=0A=
_381.push(_382);=0A=
break;=0A=
}=0A=
}=0A=
}=0A=
return _381;=0A=
},_newCallStack:function(path,once){=0A=
var rval=3Dfunction(){=0A=
var _386=3Darguments.callee.callStack;=0A=
for(var i=3D0;i<_386.length;i++){=0A=
if(_386[i].apply(this,arguments)=3D=3D=3Dfalse){=0A=
break;=0A=
}=0A=
}=0A=
if(once){=0A=
try{=0A=
this[path]=3Dnull;=0A=
}=0A=
catch(e){=0A=
}=0A=
}=0A=
};=0A=
rval.callStack=3D[];=0A=
return rval;=0A=
},addToCallStack:function(_387,path,func,once){=0A=
var self=3DMochiKit.DOM;=0A=
var _388=3D_387[path];=0A=
var _389=3D_388;=0A=
if(!(typeof (_388)=3D=3D"function"&&typeof =
(_388.callStack)=3D=3D"object"&&_388.callStack!=3D=3Dnull)){=0A=
_389=3Dself._newCallStack(path,once);=0A=
if(typeof (_388)=3D=3D"function"){=0A=
_389.callStack.push(_388);=0A=
}=0A=
_387[path]=3D_389;=0A=
}=0A=
_389.callStack.push(func);=0A=
},addLoadEvent:function(func){=0A=
var self=3DMochiKit.DOM;=0A=
self.addToCallStack(self._window,"onload",func,true);=0A=
},focusOnLoad:function(_390){=0A=
var self=3DMochiKit.DOM;=0A=
self.addLoadEvent(function(){=0A=
_390=3Dself.getElement(_390);=0A=
if(_390){=0A=
_390.focus();=0A=
}=0A=
});=0A=
},setElementClass:function(_391,_392){=0A=
var self=3DMochiKit.DOM;=0A=
var obj=3Dself.getElement(_391);=0A=
if(self.attributeArray.compliant){=0A=
obj.setAttribute("class",_392);=0A=
}else{=0A=
obj.setAttribute("className",_392);=0A=
}=0A=
},toggleElementClass:function(_393){=0A=
var self=3DMochiKit.DOM;=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var obj=3Dself.getElement(arguments[i]);=0A=
if(!self.addElementClass(obj,_393)){=0A=
self.removeElementClass(obj,_393);=0A=
}=0A=
}=0A=
},addElementClass:function(_394,_395){=0A=
var self=3DMochiKit.DOM;=0A=
var obj=3Dself.getElement(_394);=0A=
var cls=3Dobj.className;=0A=
if(cls.length=3D=3D=3D0){=0A=
self.setElementClass(obj,_395);=0A=
return true;=0A=
}=0A=
if(cls=3D=3D_395){=0A=
return false;=0A=
}=0A=
var _397=3Dobj.className.split(" ");=0A=
for(var i=3D0;i<_397.length;i++){=0A=
if(_397[i]=3D=3D_395){=0A=
return false;=0A=
}=0A=
}=0A=
self.setElementClass(obj,cls+" "+_395);=0A=
return true;=0A=
},removeElementClass:function(_398,_399){=0A=
var self=3DMochiKit.DOM;=0A=
var obj=3Dself.getElement(_398);=0A=
var cls=3Dobj.className;=0A=
if(cls.length=3D=3D=3D0){=0A=
return false;=0A=
}=0A=
if(cls=3D=3D_399){=0A=
self.setElementClass(obj,"");=0A=
return true;=0A=
}=0A=
var _400=3Dobj.className.split(" ");=0A=
for(var i=3D0;i<_400.length;i++){=0A=
if(_400[i]=3D=3D_399){=0A=
_400.splice(i,1);=0A=
self.setElementClass(obj,_400.join(" "));=0A=
return true;=0A=
}=0A=
}=0A=
return false;=0A=
},swapElementClass:function(_401,_402,_403){=0A=
var obj=3DMochiKit.DOM.getElement(_401);=0A=
var res=3DMochiKit.DOM.removeElementClass(obj,_402);=0A=
if(res){=0A=
MochiKit.DOM.addElementClass(obj,_403);=0A=
}=0A=
return res;=0A=
},hasElementClass:function(_404,_405){=0A=
var obj=3DMochiKit.DOM.getElement(_404);=0A=
var _406=3Dobj.className.split(" ");=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
var good=3Dfalse;=0A=
for(var j=3D0;j<_406.length;j++){=0A=
if(_406[j]=3D=3Darguments[i]){=0A=
good=3Dtrue;=0A=
break;=0A=
}=0A=
}=0A=
if(!good){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
},escapeHTML:function(s){=0A=
return =
s.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/</g,"&lt;").repla=
ce(/>/g,"&gt;");=0A=
},toHTML:function(dom){=0A=
return MochiKit.DOM.emitHTML(dom).join("");=0A=
},emitHTML:function(dom,lst){=0A=
if(typeof (lst)=3D=3D"undefined"||lst=3D=3D=3Dnull){=0A=
lst=3D[];=0A=
}=0A=
var _409=3D[dom];=0A=
var self=3DMochiKit.DOM;=0A=
var _410=3Dself.escapeHTML;=0A=
var _411=3Dself.attributeArray;=0A=
while(_409.length){=0A=
dom=3D_409.pop();=0A=
if(typeof (dom)=3D=3D"string"){=0A=
lst.push(dom);=0A=
}else{=0A=
if(dom.nodeType=3D=3D1){=0A=
lst.push("<"+dom.nodeName.toLowerCase());=0A=
var _412=3D[];=0A=
var _413=3D_411(dom);=0A=
for(var i=3D0;i<_413.length;i++){=0A=
var a=3D_413[i];=0A=
_412.push([" ",a.name,"=3D\"",_410(a.value),"\""]);=0A=
}=0A=
_412.sort();=0A=
for(i=3D0;i<_412.length;i++){=0A=
var _414=3D_412[i];=0A=
for(var j=3D0;j<_414.length;j++){=0A=
lst.push(_414[j]);=0A=
}=0A=
}=0A=
if(dom.hasChildNodes()){=0A=
lst.push(">");=0A=
_409.push("</"+dom.nodeName.toLowerCase()+">");=0A=
var _415=3Ddom.childNodes;=0A=
for(i=3D_415.length-1;i>=3D0;i--){=0A=
_409.push(_415[i]);=0A=
}=0A=
}else{=0A=
lst.push("/>");=0A=
}=0A=
}else{=0A=
if(dom.nodeType=3D=3D3){=0A=
lst.push(_410(dom.nodeValue));=0A=
}=0A=
}=0A=
}=0A=
}=0A=
return lst;=0A=
},setDisplayForElement:function(_416,_417){=0A=
var m=3DMochiKit.Base;=0A=
var _418=3Dm.extend(null,arguments,1);=0A=
MochiKit.Iter.forEach(m.filter(null,m.map(MochiKit.DOM.getElement,_418)),=
function(_417){=0A=
_417.style.display=3D_416;=0A=
});=0A=
},scrapeText:function(node,_419){=0A=
var rval=3D[];=0A=
(function(node){=0A=
var cn=3Dnode.childNodes;=0A=
if(cn){=0A=
for(var i=3D0;i<cn.length;i++){=0A=
arguments.callee.call(this,cn[i]);=0A=
}=0A=
}=0A=
var _421=3Dnode.nodeValue;=0A=
if(typeof (_421)=3D=3D"string"){=0A=
rval.push(_421);=0A=
}=0A=
})(MochiKit.DOM.getElement(node));=0A=
if(_419){=0A=
return rval;=0A=
}else{=0A=
return rval.join("");=0A=
}=0A=
},__new__:function(win){=0A=
var m=3DMochiKit.Base;=0A=
this._document=3Ddocument;=0A=
this._window=3Dwin;=0A=
this.domConverters=3Dnew m.AdapterRegistry();=0A=
var _422=3Dthis._document.createElement("span");=0A=
var _423;=0A=
if(_422&&_422.attributes&&_422.attributes.length>0){=0A=
var _424=3Dm.filter;=0A=
_423=3Dfunction(node){=0A=
return _424(_423.ignoreAttrFilter,node.attributes);=0A=
};=0A=
_423.ignoreAttr=3D{};=0A=
MochiKit.Iter.forEach(_422.attributes,function(a){=0A=
_423.ignoreAttr[a.name]=3Da.value;=0A=
});=0A=
_423.ignoreAttrFilter=3Dfunction(a){=0A=
return (_423.ignoreAttr[a.name]!=3Da.value);=0A=
};=0A=
_423.compliant=3Dfalse;=0A=
_423.renames=3D{"class":"className","checked":"defaultChecked","usemap":"=
useMap","for":"htmlFor"};=0A=
}else{=0A=
_423=3Dfunction(node){=0A=
return node.attributes;=0A=
};=0A=
_423.compliant=3Dtrue;=0A=
_423.renames=3D{};=0A=
}=0A=
this.attributeArray=3D_423;=0A=
var _425=3Dthis.createDOMFunc;=0A=
this.UL=3D_425("ul");=0A=
this.OL=3D_425("ol");=0A=
this.LI=3D_425("li");=0A=
this.TD=3D_425("td");=0A=
this.TR=3D_425("tr");=0A=
this.TBODY=3D_425("tbody");=0A=
this.THEAD=3D_425("thead");=0A=
this.TFOOT=3D_425("tfoot");=0A=
this.TABLE=3D_425("table");=0A=
this.TH=3D_425("th");=0A=
this.INPUT=3D_425("input");=0A=
this.SPAN=3D_425("span");=0A=
this.A=3D_425("a");=0A=
this.DIV=3D_425("div");=0A=
this.IMG=3D_425("img");=0A=
this.BUTTON=3D_425("button");=0A=
this.TT=3D_425("tt");=0A=
this.PRE=3D_425("pre");=0A=
this.H1=3D_425("h1");=0A=
this.H2=3D_425("h2");=0A=
this.H3=3D_425("h3");=0A=
this.BR=3D_425("br");=0A=
this.HR=3D_425("hr");=0A=
this.LABEL=3D_425("label");=0A=
this.TEXTAREA=3D_425("textarea");=0A=
this.FORM=3D_425("form");=0A=
this.P=3D_425("p");=0A=
this.SELECT=3D_425("select");=0A=
this.OPTION=3D_425("option");=0A=
this.OPTGROUP=3D_425("optgroup");=0A=
this.LEGEND=3D_425("legend");=0A=
this.FIELDSET=3D_425("fieldset");=0A=
this.STRONG=3D_425("strong");=0A=
this.CANVAS=3D_425("canvas");=0A=
this.hideElement=3Dm.partial(this.setDisplayForElement,"none");=0A=
this.showElement=3Dm.partial(this.setDisplayForElement,"block");=0A=
this.removeElement=3Dthis.swapDOM;=0A=
this.$=3Dthis.getElement;=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
m.nameFunctions(this);=0A=
}});=0A=
MochiKit.DOM.__new__(((typeof (window)=3D=3D"undefined")?this:window));=0A=
if(!MochiKit.__compat__){=0A=
withWindow=3DMochiKit.DOM.withWindow;=0A=
withDocument=3DMochiKit.DOM.withDocument;=0A=
}=0A=
MochiKit.Base._exportSymbols(this,MochiKit.DOM);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.LoggingPane");=0A=
dojo.require("MochiKit.Logging");=0A=
dojo.require("MochiKit.Base");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Logging",[]);=0A=
JSAN.use("MochiKit.Base",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"||typeof =
(MochiKit.Logging)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.LoggingPane depends on MochiKit.Base and =
MochiKit.Logging!";=0A=
}=0A=
if(typeof (MochiKit.LoggingPane)=3D=3D"undefined"){=0A=
MochiKit.LoggingPane=3D{};=0A=
}=0A=
MochiKit.LoggingPane.NAME=3D"MochiKit.LoggingPane";=0A=
MochiKit.LoggingPane.VERSION=3D"1.3.1";=0A=
MochiKit.LoggingPane.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.LoggingPane.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.LoggingPane.createLoggingPane=3Dfunction(_426){=0A=
var m=3DMochiKit.LoggingPane;=0A=
_426=3D!(!_426);=0A=
if(m._loggingPane&&m._loggingPane.inline!=3D_426){=0A=
m._loggingPane.closePane();=0A=
m._loggingPane=3Dnull;=0A=
}=0A=
if(!m._loggingPane||m._loggingPane.closed){=0A=
m._loggingPane=3Dnew m.LoggingPane(_426,MochiKit.Logging.logger);=0A=
}=0A=
return m._loggingPane;=0A=
};=0A=
MochiKit.LoggingPane.LoggingPane=3Dfunction(_427,_428){=0A=
if(typeof (_428)=3D=3D"undefined"||_428=3D=3D=3Dnull){=0A=
_428=3DMochiKit.Logging.logger;=0A=
}=0A=
this.logger=3D_428;=0A=
var _429=3DMochiKit.Base.update;=0A=
var _430=3DMochiKit.Base.updatetree;=0A=
var bind=3DMochiKit.Base.bind;=0A=
var _431=3DMochiKit.Base.clone;=0A=
var win=3Dwindow;=0A=
var uid=3D"_MochiKit_LoggingPane";=0A=
if(typeof (MochiKit.DOM)!=3D"undefined"){=0A=
win=3DMochiKit.DOM.currentWindow();=0A=
}=0A=
if(!_427){=0A=
var url=3Dwin.location.href.split("?")[0].replace(/[:\/.><&]/g,"_");=0A=
var name=3Duid+"_"+url;=0A=
var nwin=3Dwin.open("",name,"dependent,resizable,height=3D200");=0A=
if(!nwin){=0A=
alert("Not able to open debugging window due to pop-up blocking.");=0A=
return undefined;=0A=
}=0A=
nwin.document.write("<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 =
Transitional//EN\" =
"+"\"http://www.w3.org/TR/html4/loose.dtd\">"+"<html><head><title>[MochiK=
it.LoggingPane]</title></head>"+"<body></body></html>");=0A=
nwin.document.close();=0A=
nwin.document.title+=3D" "+win.document.title;=0A=
win=3Dnwin;=0A=
}=0A=
var doc=3Dwin.document;=0A=
this.doc=3Ddoc;=0A=
var _434=3Ddoc.getElementById(uid);=0A=
var _435=3D!!_434;=0A=
if(_434&&typeof (_434.loggingPane)!=3D"undefined"){=0A=
_434.loggingPane.logger=3Dthis.logger;=0A=
_434.loggingPane.buildAndApplyFilter();=0A=
return _434.loggingPane;=0A=
}=0A=
if(_435){=0A=
var _436;=0A=
while((_436=3D_434.firstChild)){=0A=
_434.removeChild(_436);=0A=
}=0A=
}else{=0A=
_434=3Ddoc.createElement("div");=0A=
_434.id=3Duid;=0A=
}=0A=
_434.loggingPane=3Dthis;=0A=
var _437=3Ddoc.createElement("input");=0A=
var _438=3Ddoc.createElement("input");=0A=
var _439=3Ddoc.createElement("button");=0A=
var _440=3Ddoc.createElement("button");=0A=
var _441=3Ddoc.createElement("button");=0A=
var _442=3Ddoc.createElement("button");=0A=
var _443=3Ddoc.createElement("div");=0A=
var _444=3Ddoc.createElement("div");=0A=
var _445=3Duid+"_Listener";=0A=
this.colorTable=3D_431(this.colorTable);=0A=
var _446=3D[];=0A=
var _447=3Dnull;=0A=
var _448=3Dfunction(msg){=0A=
var _449=3Dmsg.level;=0A=
if(typeof (_449)=3D=3D"number"){=0A=
_449=3DMochiKit.Logging.LogLevel[_449];=0A=
}=0A=
return _449;=0A=
};=0A=
var _450=3Dfunction(msg){=0A=
return msg.info.join(" ");=0A=
};=0A=
var _451=3Dbind(function(msg){=0A=
var _452=3D_448(msg);=0A=
var text=3D_450(msg);=0A=
var c=3Dthis.colorTable[_452];=0A=
var p=3Ddoc.createElement("span");=0A=
p.className=3D"MochiKit-LogMessage MochiKit-LogLevel-"+_452;=0A=
p.style.cssText=3D"margin: 0px; white-space: -moz-pre-wrap; white-space: =
-o-pre-wrap; white-space: pre-wrap; white-space: pre-line; word-wrap: =
break-word; wrap-option: emergency; color: "+c;=0A=
p.appendChild(doc.createTextNode(_452+": "+text));=0A=
_444.appendChild(p);=0A=
_444.appendChild(doc.createElement("br"));=0A=
if(_443.offsetHeight>_443.scrollHeight){=0A=
_443.scrollTop=3D0;=0A=
}else{=0A=
_443.scrollTop=3D_443.scrollHeight;=0A=
}=0A=
},this);=0A=
var _454=3Dfunction(msg){=0A=
_446[_446.length]=3Dmsg;=0A=
_451(msg);=0A=
};=0A=
var _455=3Dfunction(){=0A=
var _456,infore;=0A=
try{=0A=
_456=3Dnew RegExp(_437.value);=0A=
infore=3Dnew RegExp(_438.value);=0A=
}=0A=
catch(e){=0A=
logDebug("Error in filter regex: "+e.message);=0A=
return null;=0A=
}=0A=
return function(msg){=0A=
return (_456.test(_448(msg))&&infore.test(_450(msg)));=0A=
};=0A=
};=0A=
var _457=3Dfunction(){=0A=
while(_444.firstChild){=0A=
_444.removeChild(_444.firstChild);=0A=
}=0A=
};=0A=
var _458=3Dfunction(){=0A=
_446=3D[];=0A=
_457();=0A=
};=0A=
var _459=3Dbind(function(){=0A=
if(this.closed){=0A=
return;=0A=
}=0A=
this.closed=3Dtrue;=0A=
if(MochiKit.LoggingPane._loggingPane=3D=3Dthis){=0A=
MochiKit.LoggingPane._loggingPane=3Dnull;=0A=
}=0A=
this.logger.removeListener(_445);=0A=
_434.loggingPane=3Dnull;=0A=
if(_427){=0A=
_434.parentNode.removeChild(_434);=0A=
}else{=0A=
this.win.close();=0A=
}=0A=
},this);=0A=
var _460=3Dfunction(){=0A=
_457();=0A=
for(var i=3D0;i<_446.length;i++){=0A=
var msg=3D_446[i];=0A=
if(_447=3D=3D=3Dnull||_447(msg)){=0A=
_451(msg);=0A=
}=0A=
}=0A=
};=0A=
this.buildAndApplyFilter=3Dfunction(){=0A=
_447=3D_455();=0A=
_460();=0A=
this.logger.removeListener(_445);=0A=
this.logger.addListener(_445,_447,_454);=0A=
};=0A=
var _461=3Dbind(function(){=0A=
_446=3Dthis.logger.getMessages();=0A=
_460();=0A=
},this);=0A=
var _462=3Dbind(function(_463){=0A=
_463=3D_463||window.event;=0A=
key=3D_463.which||_463.keyCode;=0A=
if(key=3D=3D13){=0A=
this.buildAndApplyFilter();=0A=
}=0A=
},this);=0A=
var _464=3D"display: block; z-index: 1000; left: 0px; bottom: 0px; =
position: fixed; width: 100%; background-color: white; font: =
"+this.logFont;=0A=
if(_427){=0A=
_464+=3D"; height: 10em; border-top: 2px solid black";=0A=
}else{=0A=
_464+=3D"; height: 100%;";=0A=
}=0A=
_434.style.cssText=3D_464;=0A=
if(!_435){=0A=
doc.body.appendChild(_434);=0A=
}=0A=
_464=3D{"cssText":"width: 33%; display: inline; font: "+this.logFont};=0A=
_430(_437,{"value":"FATAL|ERROR|WARNING|INFO|DEBUG","onkeypress":_462,"st=
yle":_464});=0A=
_434.appendChild(_437);=0A=
_430(_438,{"value":".*","onkeypress":_462,"style":_464});=0A=
_434.appendChild(_438);=0A=
_464=3D"width: 8%; display:inline; font: "+this.logFont;=0A=
_439.appendChild(doc.createTextNode("Filter"));=0A=
_439.onclick=3Dbind("buildAndApplyFilter",this);=0A=
_439.style.cssText=3D_464;=0A=
_434.appendChild(_439);=0A=
_440.appendChild(doc.createTextNode("Load"));=0A=
_440.onclick=3D_461;=0A=
_440.style.cssText=3D_464;=0A=
_434.appendChild(_440);=0A=
_441.appendChild(doc.createTextNode("Clear"));=0A=
_441.onclick=3D_458;=0A=
_441.style.cssText=3D_464;=0A=
_434.appendChild(_441);=0A=
_442.appendChild(doc.createTextNode("Close"));=0A=
_442.onclick=3D_459;=0A=
_442.style.cssText=3D_464;=0A=
_434.appendChild(_442);=0A=
_443.style.cssText=3D"overflow: auto; width: 100%";=0A=
_444.style.cssText=3D"width: 100%; height: "+(_427?"8em":"100%");=0A=
_443.appendChild(_444);=0A=
_434.appendChild(_443);=0A=
this.buildAndApplyFilter();=0A=
_461();=0A=
if(_427){=0A=
this.win=3Dundefined;=0A=
}else{=0A=
this.win=3Dwin;=0A=
}=0A=
this.inline=3D_427;=0A=
this.closePane=3D_459;=0A=
this.closed=3Dfalse;=0A=
return this;=0A=
};=0A=
MochiKit.LoggingPane.LoggingPane.prototype=3D{"logFont":"8pt =
Verdana,sans-serif","colorTable":{"ERROR":"red","FATAL":"darkred","WARNIN=
G":"blue","INFO":"black","DEBUG":"green"}};=0A=
MochiKit.LoggingPane.EXPORT_OK=3D["LoggingPane"];=0A=
MochiKit.LoggingPane.EXPORT=3D["createLoggingPane"];=0A=
MochiKit.LoggingPane.__new__=3Dfunction(){=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":MochiKit.Base.concat(thi=
s.EXPORT,this.EXPORT_OK)};=0A=
MochiKit.Base.nameFunctions(this);=0A=
MochiKit.LoggingPane._loggingPane=3Dnull;=0A=
};=0A=
MochiKit.LoggingPane.__new__();=0A=
MochiKit.Base._exportSymbols(this,MochiKit.LoggingPane);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Color");=0A=
dojo.require("MochiKit.Base");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Color depends on MochiKit.Base";=0A=
}=0A=
if(typeof (MochiKit.Color)=3D=3D"undefined"){=0A=
MochiKit.Color=3D{};=0A=
}=0A=
MochiKit.Color.NAME=3D"MochiKit.Color";=0A=
MochiKit.Color.VERSION=3D"1.3.1";=0A=
MochiKit.Color.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.Color.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.Color.Color=3Dfunction(red,_466,blue,_468){=0A=
if(typeof (_468)=3D=3D"undefined"||_468=3D=3D=3Dnull){=0A=
_468=3D1;=0A=
}=0A=
this.rgb=3D{r:red,g:_466,b:blue,a:_468};=0A=
};=0A=
MochiKit.Color.Color.prototype=3D{__class__:MochiKit.Color.Color,colorWit=
hAlpha:function(_469){=0A=
var rgb=3Dthis.rgb;=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromRGB(rgb.r,rgb.g,rgb.b,_469);=0A=
},colorWithHue:function(hue){=0A=
var hsl=3Dthis.asHSL();=0A=
hsl.h=3Dhue;=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromHSL(hsl);=0A=
},colorWithSaturation:function(_473){=0A=
var hsl=3Dthis.asHSL();=0A=
hsl.s=3D_473;=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromHSL(hsl);=0A=
},colorWithLightness:function(_474){=0A=
var hsl=3Dthis.asHSL();=0A=
hsl.l=3D_474;=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromHSL(hsl);=0A=
},darkerColorWithLevel:function(_475){=0A=
var hsl=3Dthis.asHSL();=0A=
hsl.l=3DMath.max(hsl.l-_475,0);=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromHSL(hsl);=0A=
},lighterColorWithLevel:function(_476){=0A=
var hsl=3Dthis.asHSL();=0A=
hsl.l=3DMath.min(hsl.l+_476,1);=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromHSL(hsl);=0A=
},blendedColor:function(_477,_478){=0A=
if(typeof (_478)=3D=3D"undefined"||_478=3D=3D=3Dnull){=0A=
_478=3D0.5;=0A=
}=0A=
var sf=3D1-_478;=0A=
var s=3Dthis.rgb;=0A=
var d=3D_477.rgb;=0A=
var df=3D_478;=0A=
return =
MochiKit.Color.Color.fromRGB((s.r*sf)+(d.r*df),(s.g*sf)+(d.g*df),(s.b*sf)=
+(d.b*df),(s.a*sf)+(d.a*df));=0A=
},compareRGB:function(_481){=0A=
var a=3Dthis.asRGB();=0A=
var b=3D_481.asRGB();=0A=
return MochiKit.Base.compare([a.r,a.g,a.b,a.a],[b.r,b.g,b.b,b.a]);=0A=
},isLight:function(){=0A=
return this.asHSL().b>0.5;=0A=
},isDark:function(){=0A=
return (!this.isLight());=0A=
},toHSLString:function(){=0A=
var c=3Dthis.asHSL();=0A=
var ccc=3DMochiKit.Color.clampColorComponent;=0A=
var rval=3Dthis._hslString;=0A=
if(!rval){=0A=
var =
mid=3D(ccc(c.h,360).toFixed(0)+","+ccc(c.s,100).toPrecision(4)+"%"+","+cc=
c(c.l,100).toPrecision(4)+"%");=0A=
var a=3Dc.a;=0A=
if(a>=3D1){=0A=
a=3D1;=0A=
rval=3D"hsl("+mid+")";=0A=
}else{=0A=
if(a<=3D0){=0A=
a=3D0;=0A=
}=0A=
rval=3D"hsla("+mid+","+a+")";=0A=
}=0A=
this._hslString=3Drval;=0A=
}=0A=
return rval;=0A=
},toRGBString:function(){=0A=
var c=3Dthis.rgb;=0A=
var ccc=3DMochiKit.Color.clampColorComponent;=0A=
var rval=3Dthis._rgbString;=0A=
if(!rval){=0A=
var =
mid=3D(ccc(c.r,255).toFixed(0)+","+ccc(c.g,255).toFixed(0)+","+ccc(c.b,25=
5).toFixed(0));=0A=
if(c.a!=3D1){=0A=
rval=3D"rgba("+mid+","+c.a+")";=0A=
}else{=0A=
rval=3D"rgb("+mid+")";=0A=
}=0A=
this._rgbString=3Drval;=0A=
}=0A=
return rval;=0A=
},asRGB:function(){=0A=
return MochiKit.Base.clone(this.rgb);=0A=
},toHexString:function(){=0A=
var m=3DMochiKit.Color;=0A=
var c=3Dthis.rgb;=0A=
var ccc=3DMochiKit.Color.clampColorComponent;=0A=
var rval=3Dthis._hexString;=0A=
if(!rval){=0A=
rval=3D("#"+m.toColorPart(ccc(c.r,255))+m.toColorPart(ccc(c.g,255))+m.toC=
olorPart(ccc(c.b,255)));=0A=
this._hexString=3Drval;=0A=
}=0A=
return rval;=0A=
},asHSV:function(){=0A=
var hsv=3Dthis.hsv;=0A=
var c=3Dthis.rgb;=0A=
if(typeof (hsv)=3D=3D"undefined"||hsv=3D=3D=3Dnull){=0A=
hsv=3DMochiKit.Color.rgbToHSV(this.rgb);=0A=
this.hsv=3Dhsv;=0A=
}=0A=
return MochiKit.Base.clone(hsv);=0A=
},asHSL:function(){=0A=
var hsl=3Dthis.hsl;=0A=
var c=3Dthis.rgb;=0A=
if(typeof (hsl)=3D=3D"undefined"||hsl=3D=3D=3Dnull){=0A=
hsl=3DMochiKit.Color.rgbToHSL(this.rgb);=0A=
this.hsl=3Dhsl;=0A=
}=0A=
return MochiKit.Base.clone(hsl);=0A=
},toString:function(){=0A=
return this.toRGBString();=0A=
},repr:function(){=0A=
var c=3Dthis.rgb;=0A=
var col=3D[c.r,c.g,c.b,c.a];=0A=
return this.__class__.NAME+"("+col.join(", ")+")";=0A=
}};=0A=
MochiKit.Base.update(MochiKit.Color.Color,{fromRGB:function(red,_486,blue=
,_487){=0A=
var _488=3DMochiKit.Color.Color;=0A=
if(arguments.length=3D=3D1){=0A=
var rgb=3Dred;=0A=
red=3Drgb.r;=0A=
_486=3Drgb.g;=0A=
blue=3Drgb.b;=0A=
if(typeof (rgb.a)=3D=3D"undefined"){=0A=
_487=3Dundefined;=0A=
}else{=0A=
_487=3Drgb.a;=0A=
}=0A=
}=0A=
return new _488(red,_486,blue,_487);=0A=
},fromHSL:function(hue,_489,_490,_491){=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromRGB(m.hslToRGB.apply(m,arguments));=0A=
},fromHSV:function(hue,_492,_493,_494){=0A=
var m=3DMochiKit.Color;=0A=
return m.Color.fromRGB(m.hsvToRGB.apply(m,arguments));=0A=
},fromName:function(name){=0A=
var _495=3DMochiKit.Color.Color;=0A=
if(name.charAt(0)=3D=3D"\""){=0A=
name=3Dname.substr(1,name.length-2);=0A=
}=0A=
var _496=3D_495._namedColors[name.toLowerCase()];=0A=
if(typeof (_496)=3D=3D"string"){=0A=
return _495.fromHexString(_496);=0A=
}else{=0A=
if(name=3D=3D"transparent"){=0A=
return _495.transparentColor();=0A=
}=0A=
}=0A=
return null;=0A=
},fromString:function(_497){=0A=
var self=3DMochiKit.Color.Color;=0A=
var _498=3D_497.substr(0,3);=0A=
if(_498=3D=3D"rgb"){=0A=
return self.fromRGBString(_497);=0A=
}else{=0A=
if(_498=3D=3D"hsl"){=0A=
return self.fromHSLString(_497);=0A=
}else{=0A=
if(_497.charAt(0)=3D=3D"#"){=0A=
return self.fromHexString(_497);=0A=
}=0A=
}=0A=
}=0A=
return self.fromName(_497);=0A=
},fromHexString:function(_499){=0A=
if(_499.charAt(0)=3D=3D"#"){=0A=
_499=3D_499.substring(1);=0A=
}=0A=
var _500=3D[];=0A=
var i,hex;=0A=
if(_499.length=3D=3D3){=0A=
for(i=3D0;i<3;i++){=0A=
hex=3D_499.substr(i,1);=0A=
_500.push(parseInt(hex+hex,16)/255);=0A=
}=0A=
}else{=0A=
for(i=3D0;i<6;i+=3D2){=0A=
hex=3D_499.substr(i,2);=0A=
_500.push(parseInt(hex,16)/255);=0A=
}=0A=
}=0A=
var _501=3DMochiKit.Color.Color;=0A=
return _501.fromRGB.apply(_501,_500);=0A=
},_fromColorString:function(pre,_503,_504,_505){=0A=
if(_505.indexOf(pre)=3D=3D=3D0){=0A=
_505=3D_505.substring(_505.indexOf("(",3)+1,_505.length-1);=0A=
}=0A=
var _506=3D_505.split(/\s*,\s*/);=0A=
var _507=3D[];=0A=
for(var i=3D0;i<_506.length;i++){=0A=
var c=3D_506[i];=0A=
var val;=0A=
var _508=3Dc.substring(c.length-3);=0A=
if(c.charAt(c.length-1)=3D=3D"%"){=0A=
val=3D0.01*parseFloat(c.substring(0,c.length-1));=0A=
}else{=0A=
if(_508=3D=3D"deg"){=0A=
val=3DparseFloat(c)/360;=0A=
}else{=0A=
if(_508=3D=3D"rad"){=0A=
val=3DparseFloat(c)/(Math.PI*2);=0A=
}else{=0A=
val=3D_504[i]*parseFloat(c);=0A=
}=0A=
}=0A=
}=0A=
_507.push(val);=0A=
}=0A=
return this[_503].apply(this,_507);=0A=
},fromComputedStyle:function(elem,_509,_510){=0A=
var d=3DMochiKit.DOM;=0A=
var cls=3DMochiKit.Color.Color;=0A=
for(elem=3Dd.getElement(elem);elem;elem=3Delem.parentNode){=0A=
var _511=3Dd.computedStyle.apply(d,arguments);=0A=
if(!_511){=0A=
continue;=0A=
}=0A=
var _512=3Dcls.fromString(_511);=0A=
if(!_512){=0A=
break;=0A=
}=0A=
if(_512.asRGB().a>0){=0A=
return _512;=0A=
}=0A=
}=0A=
return null;=0A=
},fromBackground:function(elem){=0A=
var cls=3DMochiKit.Color.Color;=0A=
return =
cls.fromComputedStyle(elem,"backgroundColor","background-color")||cls.whi=
teColor();=0A=
},fromText:function(elem){=0A=
var cls=3DMochiKit.Color.Color;=0A=
return cls.fromComputedStyle(elem,"color","color")||cls.blackColor();=0A=
},namedColors:function(){=0A=
return MochiKit.Base.clone(MochiKit.Color.Color._namedColors);=0A=
}});=0A=
MochiKit.Base.update(MochiKit.Color,{clampColorComponent:function(v,_513)=
{=0A=
v*=3D_513;=0A=
if(v<0){=0A=
return 0;=0A=
}else{=0A=
if(v>_513){=0A=
return _513;=0A=
}else{=0A=
return v;=0A=
}=0A=
}=0A=
},_hslValue:function(n1,n2,hue){=0A=
if(hue>6){=0A=
hue-=3D6;=0A=
}else{=0A=
if(hue<0){=0A=
hue+=3D6;=0A=
}=0A=
}=0A=
var val;=0A=
if(hue<1){=0A=
val=3Dn1+(n2-n1)*hue;=0A=
}else{=0A=
if(hue<3){=0A=
val=3Dn2;=0A=
}else{=0A=
if(hue<4){=0A=
val=3Dn1+(n2-n1)*(4-hue);=0A=
}else{=0A=
val=3Dn1;=0A=
}=0A=
}=0A=
}=0A=
return val;=0A=
},hsvToRGB:function(hue,_516,_517,_518){=0A=
if(arguments.length=3D=3D1){=0A=
var hsv=3Dhue;=0A=
hue=3Dhsv.h;=0A=
_516=3Dhsv.s;=0A=
_517=3Dhsv.v;=0A=
_518=3Dhsv.a;=0A=
}=0A=
var red;=0A=
var _519;=0A=
var blue;=0A=
if(_516=3D=3D=3D0){=0A=
red=3D0;=0A=
_519=3D0;=0A=
blue=3D0;=0A=
}else{=0A=
var i=3DMath.floor(hue*6);=0A=
var f=3D(hue*6)-i;=0A=
var p=3D_517*(1-_516);=0A=
var q=3D_517*(1-(_516*f));=0A=
var t=3D_517*(1-(_516*(1-f)));=0A=
switch(i){=0A=
case 1:=0A=
red=3Dq;=0A=
_519=3D_517;=0A=
blue=3Dp;=0A=
break;=0A=
case 2:=0A=
red=3Dp;=0A=
_519=3D_517;=0A=
blue=3Dt;=0A=
break;=0A=
case 3:=0A=
red=3Dp;=0A=
_519=3Dq;=0A=
blue=3D_517;=0A=
break;=0A=
case 4:=0A=
red=3Dt;=0A=
_519=3Dp;=0A=
blue=3D_517;=0A=
break;=0A=
case 5:=0A=
red=3D_517;=0A=
_519=3Dp;=0A=
blue=3Dq;=0A=
break;=0A=
case 6:=0A=
case 0:=0A=
red=3D_517;=0A=
_519=3Dt;=0A=
blue=3Dp;=0A=
break;=0A=
}=0A=
}=0A=
return {r:red,g:_519,b:blue,a:_518};=0A=
},hslToRGB:function(hue,_521,_522,_523){=0A=
if(arguments.length=3D=3D1){=0A=
var hsl=3Dhue;=0A=
hue=3Dhsl.h;=0A=
_521=3Dhsl.s;=0A=
_522=3Dhsl.l;=0A=
_523=3Dhsl.a;=0A=
}=0A=
var red;=0A=
var _524;=0A=
var blue;=0A=
if(_521=3D=3D=3D0){=0A=
red=3D_522;=0A=
_524=3D_522;=0A=
blue=3D_522;=0A=
}else{=0A=
var m2;=0A=
if(_522<=3D0.5){=0A=
m2=3D_522*(1+_521);=0A=
}else{=0A=
m2=3D_522+_521-(_522*_521);=0A=
}=0A=
var m1=3D(2*_522)-m2;=0A=
var f=3DMochiKit.Color._hslValue;=0A=
var h6=3Dhue*6;=0A=
red=3Df(m1,m2,h6+2);=0A=
_524=3Df(m1,m2,h6);=0A=
blue=3Df(m1,m2,h6-2);=0A=
}=0A=
return {r:red,g:_524,b:blue,a:_523};=0A=
},rgbToHSV:function(red,_528,blue,_529){=0A=
if(arguments.length=3D=3D1){=0A=
var rgb=3Dred;=0A=
red=3Drgb.r;=0A=
_528=3Drgb.g;=0A=
blue=3Drgb.b;=0A=
_529=3Drgb.a;=0A=
}=0A=
var max=3DMath.max(Math.max(red,_528),blue);=0A=
var min=3DMath.min(Math.min(red,_528),blue);=0A=
var hue;=0A=
var _532;=0A=
var _533=3Dmax;=0A=
if(min=3D=3Dmax){=0A=
hue=3D0;=0A=
_532=3D0;=0A=
}else{=0A=
var _534=3D(max-min);=0A=
_532=3D_534/max;=0A=
if(red=3D=3Dmax){=0A=
hue=3D(_528-blue)/_534;=0A=
}else{=0A=
if(_528=3D=3Dmax){=0A=
hue=3D2+((blue-red)/_534);=0A=
}else{=0A=
hue=3D4+((red-_528)/_534);=0A=
}=0A=
}=0A=
hue/=3D6;=0A=
if(hue<0){=0A=
hue+=3D1;=0A=
}=0A=
if(hue>1){=0A=
hue-=3D1;=0A=
}=0A=
}=0A=
return {h:hue,s:_532,v:_533,a:_529};=0A=
},rgbToHSL:function(red,_535,blue,_536){=0A=
if(arguments.length=3D=3D1){=0A=
var rgb=3Dred;=0A=
red=3Drgb.r;=0A=
_535=3Drgb.g;=0A=
blue=3Drgb.b;=0A=
_536=3Drgb.a;=0A=
}=0A=
var max=3DMath.max(red,Math.max(_535,blue));=0A=
var min=3DMath.min(red,Math.min(_535,blue));=0A=
var hue;=0A=
var _537;=0A=
var _538=3D(max+min)/2;=0A=
var _539=3Dmax-min;=0A=
if(_539=3D=3D=3D0){=0A=
hue=3D0;=0A=
_537=3D0;=0A=
}else{=0A=
if(_538<=3D0.5){=0A=
_537=3D_539/(max+min);=0A=
}else{=0A=
_537=3D_539/(2-max-min);=0A=
}=0A=
if(red=3D=3Dmax){=0A=
hue=3D(_535-blue)/_539;=0A=
}else{=0A=
if(_535=3D=3Dmax){=0A=
hue=3D2+((blue-red)/_539);=0A=
}else{=0A=
hue=3D4+((red-_535)/_539);=0A=
}=0A=
}=0A=
hue/=3D6;=0A=
if(hue<0){=0A=
hue+=3D1;=0A=
}=0A=
if(hue>1){=0A=
hue-=3D1;=0A=
}=0A=
}=0A=
return {h:hue,s:_537,l:_538,a:_536};=0A=
},toColorPart:function(num){=0A=
num=3DMath.round(num);=0A=
var _540=3Dnum.toString(16);=0A=
if(num<16){=0A=
return "0"+_540;=0A=
}=0A=
return _540;=0A=
},__new__:function(){=0A=
var m=3DMochiKit.Base;=0A=
this.Color.fromRGBString=3Dm.bind(this.Color._fromColorString,this.Color,=
"rgb","fromRGB",[1/255,1/255,1/255,1]);=0A=
this.Color.fromHSLString=3Dm.bind(this.Color._fromColorString,this.Color,=
"hsl","fromHSL",[1/360,0.01,0.01,1]);=0A=
var _541=3D1/3;=0A=
var =
_542=3D{black:[0,0,0],blue:[0,0,1],brown:[0.6,0.4,0.2],cyan:[0,1,1],darkG=
ray:[_541,_541,_541],gray:[0.5,0.5,0.5],green:[0,1,0],lightGray:[2*_541,2=
*_541,2*_541],magenta:[1,0,1],orange:[1,0.5,0],purple:[0.5,0,0.5],red:[1,=
0,0],transparent:[0,0,0,0],white:[1,1,1],yellow:[1,1,0]};=0A=
var _543=3Dfunction(name,r,g,b,a){=0A=
var rval=3Dthis.fromRGB(r,g,b,a);=0A=
this[name]=3Dfunction(){=0A=
return rval;=0A=
};=0A=
return rval;=0A=
};=0A=
for(var k in _542){=0A=
var name=3Dk+"Color";=0A=
var _545=3Dm.concat([_543,this.Color,name],_542[k]);=0A=
this.Color[name]=3Dm.bind.apply(null,_545);=0A=
}=0A=
var _546=3Dfunction(){=0A=
for(var i=3D0;i<arguments.length;i++){=0A=
if(!(arguments[i] instanceof Color)){=0A=
return false;=0A=
}=0A=
}=0A=
return true;=0A=
};=0A=
var _547=3Dfunction(a,b){=0A=
return a.compareRGB(b);=0A=
};=0A=
m.nameFunctions(this);=0A=
m.registerComparator(this.Color.NAME,_546,_547);=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
}});=0A=
MochiKit.Color.EXPORT=3D["Color"];=0A=
MochiKit.Color.EXPORT_OK=3D["clampColorComponent","rgbToHSL","hslToRGB","=
rgbToHSV","hsvToRGB","toColorPart"];=0A=
MochiKit.Color.__new__();=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Color);=0A=
MochiKit.Color.Color._namedColors=3D{aliceblue:"#f0f8ff",antiquewhite:"#f=
aebd7",aqua:"#00ffff",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc=
",bisque:"#ffe4c4",black:"#000000",blanchedalmond:"#ffebcd",blue:"#0000ff=
",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f=
9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflower=
blue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkbl=
ue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9=
",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:=
"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932=
cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darksla=
teblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturq=
uoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00b=
fff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"=
#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",fuchsia:"#ff00ff",ga=
insboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520"=
,gray:"#808080",green:"#008000",greenyellow:"#adff2f",grey:"#808080",hone=
ydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivo=
ry:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",l=
awngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:=
"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#=
d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",ligh=
tsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightsla=
tegray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lighty=
ellow:"#ffffe0",lime:"#00ff00",limegreen:"#32cd32",linen:"#faf0e6",magent=
a:"#ff00ff",maroon:"#800000",mediumaquamarine:"#66cdaa",mediumblue:"#0000=
cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371=
",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"=
#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5f=
ffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",navy:"#=
000080",oldlace:"#fdf5e6",olive:"#808000",olivedrab:"#6b8e23",orange:"#ff=
a500",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegr=
een:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:=
"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd=
",powderblue:"#b0e0e6",purple:"#800080",red:"#ff0000",rosybrown:"#bc8f8f"=
,royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#=
f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",silver:"#c=
0c0c0",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategre=
y:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:=
"#d2b48c",teal:"#008080",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#4=
0e0d0",violet:"#ee82ee",wheat:"#f5deb3",white:"#ffffff",whitesmoke:"#f5f5=
f5",yellow:"#ffff00",yellowgreen:"#9acd32"};=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Signal");=0A=
dojo.require("MochiKit.Base");=0A=
dojo.require("MochiKit.DOM");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
JSAN.use("MochiKit.DOM",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Signal depends on MochiKit.Base!";=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.DOM)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Signal depends on MochiKit.DOM!";=0A=
}=0A=
if(typeof (MochiKit.Signal)=3D=3D"undefined"){=0A=
MochiKit.Signal=3D{};=0A=
}=0A=
MochiKit.Signal.NAME=3D"MochiKit.Signal";=0A=
MochiKit.Signal.VERSION=3D"1.3.1";=0A=
MochiKit.Signal._observers=3D[];=0A=
MochiKit.Signal.Event=3Dfunction(src,e){=0A=
this._event=3De||window.event;=0A=
this._src=3Dsrc;=0A=
};=0A=
MochiKit.Base.update(MochiKit.Signal.Event.prototype,{__repr__:function()=
{=0A=
var repr=3DMochiKit.Base.repr;=0A=
var str=3D"{event(): "+repr(this.event())+", src(): =
"+repr(this.src())+", type(): "+repr(this.type())+", target(): =
"+repr(this.target())+", modifier(): "+"{alt: =
"+repr(this.modifier().alt)+", ctrl: "+repr(this.modifier().ctrl)+", =
meta: "+repr(this.modifier().meta)+", shift: =
"+repr(this.modifier().shift)+", any: "+repr(this.modifier().any)+"}";=0A=
if(this.type()&&this.type().indexOf("key")=3D=3D=3D0){=0A=
str+=3D", key(): {code: "+repr(this.key().code)+", string: =
"+repr(this.key().string)+"}";=0A=
}=0A=
if(this.type()&&(this.type().indexOf("mouse")=3D=3D=3D0||this.type().inde=
xOf("click")!=3D-1||this.type()=3D=3D"contextmenu")){=0A=
str+=3D", mouse(): {page: "+repr(this.mouse().page)+", client: =
"+repr(this.mouse().client);=0A=
if(this.type()!=3D"mousemove"){=0A=
str+=3D", button: {left: "+repr(this.mouse().button.left)+", middle: =
"+repr(this.mouse().button.middle)+", right: =
"+repr(this.mouse().button.right)+"}}";=0A=
}else{=0A=
str+=3D"}";=0A=
}=0A=
}=0A=
if(this.type()=3D=3D"mouseover"||this.type()=3D=3D"mouseout"){=0A=
str+=3D", relatedTarget(): "+repr(this.relatedTarget());=0A=
}=0A=
str+=3D"}";=0A=
return str;=0A=
},toString:function(){=0A=
return this.__repr__();=0A=
},src:function(){=0A=
return this._src;=0A=
},event:function(){=0A=
return this._event;=0A=
},type:function(){=0A=
return this._event.type||undefined;=0A=
},target:function(){=0A=
return this._event.target||this._event.srcElement;=0A=
},relatedTarget:function(){=0A=
if(this.type()=3D=3D"mouseover"){=0A=
return (this._event.relatedTarget||this._event.fromElement);=0A=
}else{=0A=
if(this.type()=3D=3D"mouseout"){=0A=
return (this._event.relatedTarget||this._event.toElement);=0A=
}=0A=
}=0A=
return undefined;=0A=
},modifier:function(){=0A=
var m=3D{};=0A=
m.alt=3Dthis._event.altKey;=0A=
m.ctrl=3Dthis._event.ctrlKey;=0A=
m.meta=3Dthis._event.metaKey||false;=0A=
m.shift=3Dthis._event.shiftKey;=0A=
m.any=3Dm.alt||m.ctrl||m.shift||m.meta;=0A=
return m;=0A=
},key:function(){=0A=
var k=3D{};=0A=
if(this.type()&&this.type().indexOf("key")=3D=3D=3D0){=0A=
if(this.type()=3D=3D"keydown"||this.type()=3D=3D"keyup"){=0A=
k.code=3Dthis._event.keyCode;=0A=
k.string=3D(MochiKit.Signal._specialKeys[k.code]||"KEY_UNKNOWN");=0A=
return k;=0A=
}else{=0A=
if(this.type()=3D=3D"keypress"){=0A=
k.code=3D0;=0A=
k.string=3D"";=0A=
if(typeof =
(this._event.charCode)!=3D"undefined"&&this._event.charCode!=3D=3D0&&!Moc=
hiKit.Signal._specialMacKeys[this._event.charCode]){=0A=
k.code=3Dthis._event.charCode;=0A=
k.string=3DString.fromCharCode(k.code);=0A=
}else{=0A=
if(this._event.keyCode&&typeof (this._event.charCode)=3D=3D"undefined"){=0A=
k.code=3Dthis._event.keyCode;=0A=
k.string=3DString.fromCharCode(k.code);=0A=
}=0A=
}=0A=
return k;=0A=
}=0A=
}=0A=
}=0A=
return undefined;=0A=
},mouse:function(){=0A=
var m=3D{};=0A=
var e=3Dthis._event;=0A=
if(this.type()&&(this.type().indexOf("mouse")=3D=3D=3D0||this.type().inde=
xOf("click")!=3D-1||this.type()=3D=3D"contextmenu")){=0A=
m.client=3Dnew MochiKit.DOM.Coordinates(0,0);=0A=
if(e.clientX||e.clientY){=0A=
m.client.x=3D(!e.clientX||e.clientX<0)?0:e.clientX;=0A=
m.client.y=3D(!e.clientY||e.clientY<0)?0:e.clientY;=0A=
}=0A=
m.page=3Dnew MochiKit.DOM.Coordinates(0,0);=0A=
if(e.pageX||e.pageY){=0A=
m.page.x=3D(!e.pageX||e.pageX<0)?0:e.pageX;=0A=
m.page.y=3D(!e.pageY||e.pageY<0)?0:e.pageY;=0A=
}else{=0A=
var de=3DMochiKit.DOM._document.documentElement;=0A=
var b=3DMochiKit.DOM._document.body;=0A=
m.page.x=3De.clientX+(de.scrollLeft||b.scrollLeft)-(de.clientLeft||b.clie=
ntLeft);=0A=
m.page.y=3De.clientY+(de.scrollTop||b.scrollTop)-(de.clientTop||b.clientT=
op);=0A=
}=0A=
if(this.type()!=3D"mousemove"){=0A=
m.button=3D{};=0A=
m.button.left=3Dfalse;=0A=
m.button.right=3Dfalse;=0A=
m.button.middle=3Dfalse;=0A=
if(e.which){=0A=
m.button.left=3D(e.which=3D=3D1);=0A=
m.button.middle=3D(e.which=3D=3D2);=0A=
m.button.right=3D(e.which=3D=3D3);=0A=
}else{=0A=
m.button.left=3D!!(e.button&1);=0A=
m.button.right=3D!!(e.button&2);=0A=
m.button.middle=3D!!(e.button&4);=0A=
}=0A=
}=0A=
return m;=0A=
}=0A=
return undefined;=0A=
},stop:function(){=0A=
this.stopPropagation();=0A=
this.preventDefault();=0A=
},stopPropagation:function(){=0A=
if(this._event.stopPropagation){=0A=
this._event.stopPropagation();=0A=
}else{=0A=
this._event.cancelBubble=3Dtrue;=0A=
}=0A=
},preventDefault:function(){=0A=
if(this._event.preventDefault){=0A=
this._event.preventDefault();=0A=
}else{=0A=
this._event.returnValue=3Dfalse;=0A=
}=0A=
}});=0A=
MochiKit.Signal._specialMacKeys=3D{3:"KEY_ENTER",63289:"KEY_NUM_PAD_CLEAR=
",63276:"KEY_PAGE_UP",63277:"KEY_PAGE_DOWN",63275:"KEY_END",63273:"KEY_HO=
ME",63234:"KEY_ARROW_LEFT",63232:"KEY_ARROW_UP",63235:"KEY_ARROW_RIGHT",6=
3233:"KEY_ARROW_DOWN",63302:"KEY_INSERT",63272:"KEY_DELETE"};=0A=
for(i=3D63236;i<=3D63242;i++){=0A=
MochiKit.Signal._specialMacKeys[i]=3D"KEY_F"+(i-63236+1);=0A=
}=0A=
MochiKit.Signal._specialKeys=3D{8:"KEY_BACKSPACE",9:"KEY_TAB",12:"KEY_NUM=
_PAD_CLEAR",13:"KEY_ENTER",16:"KEY_SHIFT",17:"KEY_CTRL",18:"KEY_ALT",19:"=
KEY_PAUSE",20:"KEY_CAPS_LOCK",27:"KEY_ESCAPE",32:"KEY_SPACEBAR",33:"KEY_P=
AGE_UP",34:"KEY_PAGE_DOWN",35:"KEY_END",36:"KEY_HOME",37:"KEY_ARROW_LEFT"=
,38:"KEY_ARROW_UP",39:"KEY_ARROW_RIGHT",40:"KEY_ARROW_DOWN",44:"KEY_PRINT=
_SCREEN",45:"KEY_INSERT",46:"KEY_DELETE",59:"KEY_SEMICOLON",91:"KEY_WINDO=
WS_LEFT",92:"KEY_WINDOWS_RIGHT",93:"KEY_SELECT",106:"KEY_NUM_PAD_ASTERISK=
",107:"KEY_NUM_PAD_PLUS_SIGN",109:"KEY_NUM_PAD_HYPHEN-MINUS",110:"KEY_NUM=
_PAD_FULL_STOP",111:"KEY_NUM_PAD_SOLIDUS",144:"KEY_NUM_LOCK",145:"KEY_SCR=
OLL_LOCK",186:"KEY_SEMICOLON",187:"KEY_EQUALS_SIGN",188:"KEY_COMMA",189:"=
KEY_HYPHEN-MINUS",190:"KEY_FULL_STOP",191:"KEY_SOLIDUS",192:"KEY_GRAVE_AC=
CENT",219:"KEY_LEFT_SQUARE_BRACKET",220:"KEY_REVERSE_SOLIDUS",221:"KEY_RI=
GHT_SQUARE_BRACKET",222:"KEY_APOSTROPHE"};=0A=
for(var i=3D48;i<=3D57;i++){=0A=
MochiKit.Signal._specialKeys[i]=3D"KEY_"+(i-48);=0A=
}=0A=
for(i=3D65;i<=3D90;i++){=0A=
MochiKit.Signal._specialKeys[i]=3D"KEY_"+String.fromCharCode(i);=0A=
}=0A=
for(i=3D96;i<=3D105;i++){=0A=
MochiKit.Signal._specialKeys[i]=3D"KEY_NUM_PAD_"+(i-96);=0A=
}=0A=
for(i=3D112;i<=3D123;i++){=0A=
MochiKit.Signal._specialKeys[i]=3D"KEY_F"+(i-112+1);=0A=
}=0A=
MochiKit.Base.update(MochiKit.Signal,{__repr__:function(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
},toString:function(){=0A=
return this.__repr__();=0A=
},_unloadCache:function(){=0A=
var self=3DMochiKit.Signal;=0A=
var _548=3Dself._observers;=0A=
for(var i=3D0;i<_548.length;i++){=0A=
self._disconnect(_548[i]);=0A=
}=0A=
delete self._observers;=0A=
try{=0A=
window.onload=3Dundefined;=0A=
}=0A=
catch(e){=0A=
}=0A=
try{=0A=
window.onunload=3Dundefined;=0A=
}=0A=
catch(e){=0A=
}=0A=
},_listener:function(src,func,obj,_549){=0A=
var E=3DMochiKit.Signal.Event;=0A=
if(!_549){=0A=
return MochiKit.Base.bind(func,obj);=0A=
}=0A=
obj=3Dobj||src;=0A=
if(typeof (func)=3D=3D"string"){=0A=
return function(_551){=0A=
obj[func].apply(obj,[new E(src,_551)]);=0A=
};=0A=
}else{=0A=
return function(_552){=0A=
func.apply(obj,[new E(src,_552)]);=0A=
};=0A=
}=0A=
},connect:function(src,sig,_554,_555){=0A=
src=3DMochiKit.DOM.getElement(src);=0A=
var self=3DMochiKit.Signal;=0A=
if(typeof (sig)!=3D"string"){=0A=
throw new Error("'sig' must be a string");=0A=
}=0A=
var obj=3Dnull;=0A=
var func=3Dnull;=0A=
if(typeof (_555)!=3D"undefined"){=0A=
obj=3D_554;=0A=
func=3D_555;=0A=
if(typeof (_555)=3D=3D"string"){=0A=
if(typeof (_554[_555])!=3D"function"){=0A=
throw new Error("'funcOrStr' must be a function on 'objOrFunc'");=0A=
}=0A=
}else{=0A=
if(typeof (_555)!=3D"function"){=0A=
throw new Error("'funcOrStr' must be a function or string");=0A=
}=0A=
}=0A=
}else{=0A=
if(typeof (_554)!=3D"function"){=0A=
throw new Error("'objOrFunc' must be a function if 'funcOrStr' is not =
given");=0A=
}else{=0A=
func=3D_554;=0A=
}=0A=
}=0A=
if(typeof (obj)=3D=3D"undefined"||obj=3D=3D=3Dnull){=0A=
obj=3Dsrc;=0A=
}=0A=
var _556=3D!!(src.addEventListener||src.attachEvent);=0A=
var _557=3Dself._listener(src,func,obj,_556);=0A=
if(src.addEventListener){=0A=
src.addEventListener(sig.substr(2),_557,false);=0A=
}else{=0A=
if(src.attachEvent){=0A=
src.attachEvent(sig,_557);=0A=
}=0A=
}=0A=
var _558=3D[src,sig,_557,_556,_554,_555];=0A=
self._observers.push(_558);=0A=
return _558;=0A=
},_disconnect:function(_559){=0A=
if(!_559[3]){=0A=
return;=0A=
}=0A=
var src=3D_559[0];=0A=
var sig=3D_559[1];=0A=
var _560=3D_559[2];=0A=
if(src.removeEventListener){=0A=
src.removeEventListener(sig.substr(2),_560,false);=0A=
}else{=0A=
if(src.detachEvent){=0A=
src.detachEvent(sig,_560);=0A=
}else{=0A=
throw new Error("'src' must be a DOM element");=0A=
}=0A=
}=0A=
},disconnect:function(_561){=0A=
var self=3DMochiKit.Signal;=0A=
var _562=3Dself._observers;=0A=
var m=3DMochiKit.Base;=0A=
if(arguments.length>1){=0A=
var src=3DMochiKit.DOM.getElement(arguments[0]);=0A=
var sig=3Darguments[1];=0A=
var obj=3Darguments[2];=0A=
var func=3Darguments[3];=0A=
for(var i=3D_562.length-1;i>=3D0;i--){=0A=
var o=3D_562[i];=0A=
if(o[0]=3D=3D=3Dsrc&&o[1]=3D=3D=3Dsig&&o[4]=3D=3D=3Dobj&&o[5]=3D=3D=3Dfun=
c){=0A=
self._disconnect(o);=0A=
_562.splice(i,1);=0A=
return true;=0A=
}=0A=
}=0A=
}else{=0A=
var idx=3Dm.findIdentical(_562,_561);=0A=
if(idx>=3D0){=0A=
self._disconnect(_561);=0A=
_562.splice(idx,1);=0A=
return true;=0A=
}=0A=
}=0A=
return false;=0A=
},disconnectAll:function(src,sig){=0A=
src=3DMochiKit.DOM.getElement(src);=0A=
var m=3DMochiKit.Base;=0A=
var _563=3Dm.flattenArguments(m.extend(null,arguments,1));=0A=
var self=3DMochiKit.Signal;=0A=
var _564=3Dself._disconnect;=0A=
var _565=3Dself._observers;=0A=
if(_563.length=3D=3D=3D0){=0A=
for(var i=3D_565.length-1;i>=3D0;i--){=0A=
var _566=3D_565[i];=0A=
if(_566[0]=3D=3D=3Dsrc){=0A=
_564(_566);=0A=
_565.splice(i,1);=0A=
}=0A=
}=0A=
}else{=0A=
var sigs=3D{};=0A=
for(var i=3D0;i<_563.length;i++){=0A=
sigs[_563[i]]=3Dtrue;=0A=
}=0A=
for(var i=3D_565.length-1;i>=3D0;i--){=0A=
var _566=3D_565[i];=0A=
if(_566[0]=3D=3D=3Dsrc&&_566[1] in sigs){=0A=
_564(_566);=0A=
_565.splice(i,1);=0A=
}=0A=
}=0A=
}=0A=
},signal:function(src,sig){=0A=
var _568=3DMochiKit.Signal._observers;=0A=
src=3DMochiKit.DOM.getElement(src);=0A=
var args=3DMochiKit.Base.extend(null,arguments,2);=0A=
var _569=3D[];=0A=
for(var i=3D0;i<_568.length;i++){=0A=
var _570=3D_568[i];=0A=
if(_570[0]=3D=3D=3Dsrc&&_570[1]=3D=3D=3Dsig){=0A=
try{=0A=
_570[2].apply(src,args);=0A=
}=0A=
catch(e){=0A=
_569.push(e);=0A=
}=0A=
}=0A=
}=0A=
if(_569.length=3D=3D1){=0A=
throw _569[0];=0A=
}else{=0A=
if(_569.length>1){=0A=
var e=3Dnew Error("Multiple errors thrown in handling 'sig', see errors =
property");=0A=
e.errors=3D_569;=0A=
throw e;=0A=
}=0A=
}=0A=
}});=0A=
MochiKit.Signal.EXPORT_OK=3D[];=0A=
MochiKit.Signal.EXPORT=3D["connect","disconnect","signal","disconnectAll"=
];=0A=
MochiKit.Signal.__new__=3Dfunction(win){=0A=
var m=3DMochiKit.Base;=0A=
this._document=3Ddocument;=0A=
this._window=3Dwin;=0A=
try{=0A=
this.connect(window,"onunload",this._unloadCache);=0A=
}=0A=
catch(e){=0A=
}=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
m.nameFunctions(this);=0A=
};=0A=
MochiKit.Signal.__new__(this);=0A=
if(!MochiKit.__compat__){=0A=
connect=3DMochiKit.Signal.connect;=0A=
disconnect=3DMochiKit.Signal.disconnect;=0A=
disconnectAll=3DMochiKit.Signal.disconnectAll;=0A=
signal=3DMochiKit.Signal.signal;=0A=
}=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Signal);=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.Visual");=0A=
dojo.require("MochiKit.Base");=0A=
dojo.require("MochiKit.DOM");=0A=
dojo.require("MochiKit.Color");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
JSAN.use("MochiKit.DOM",[]);=0A=
JSAN.use("MochiKit.Color",[]);=0A=
}=0A=
try{=0A=
if(typeof (MochiKit.Base)=3D=3D"undefined"||typeof =
(MochiKit.DOM)=3D=3D"undefined"||typeof =
(MochiKit.Color)=3D=3D"undefined"){=0A=
throw "";=0A=
}=0A=
}=0A=
catch(e){=0A=
throw "MochiKit.Visual depends on MochiKit.Base, MochiKit.DOM and =
MochiKit.Color!";=0A=
}=0A=
if(typeof (MochiKit.Visual)=3D=3D"undefined"){=0A=
MochiKit.Visual=3D{};=0A=
}=0A=
MochiKit.Visual.NAME=3D"MochiKit.Visual";=0A=
MochiKit.Visual.VERSION=3D"1.3.1";=0A=
MochiKit.Visual.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.Visual.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.Visual._RoundCorners=3Dfunction(e,_571){=0A=
e=3DMochiKit.DOM.getElement(e);=0A=
this._setOptions(_571);=0A=
if(this.options.__unstable__wrapElement){=0A=
e=3Dthis._doWrap(e);=0A=
}=0A=
var _572=3Dthis.options.color;=0A=
var C=3DMochiKit.Color.Color;=0A=
if(this.options.color=3D=3D"fromElement"){=0A=
_572=3DC.fromBackground(e);=0A=
}else{=0A=
if(!(_572 instanceof C)){=0A=
_572=3DC.fromString(_572);=0A=
}=0A=
}=0A=
this.isTransparent=3D(_572.asRGB().a<=3D0);=0A=
var _574=3Dthis.options.bgColor;=0A=
if(this.options.bgColor=3D=3D"fromParent"){=0A=
_574=3DC.fromBackground(e.offsetParent);=0A=
}else{=0A=
if(!(_574 instanceof C)){=0A=
_574=3DC.fromString(_574);=0A=
}=0A=
}=0A=
this._roundCornersImpl(e,_572,_574);=0A=
};=0A=
MochiKit.Visual._RoundCorners.prototype=3D{_doWrap:function(e){=0A=
var _575=3De.parentNode;=0A=
var doc=3DMochiKit.DOM.currentDocument();=0A=
if(typeof =
(doc.defaultView)=3D=3D"undefined"||doc.defaultView=3D=3D=3Dnull){=0A=
return e;=0A=
}=0A=
var _576=3Ddoc.defaultView.getComputedStyle(e,null);=0A=
if(typeof (_576)=3D=3D"undefined"||_576=3D=3D=3Dnull){=0A=
return e;=0A=
}=0A=
var =
_577=3DMochiKit.DOM.DIV({"style":{display:"block",marginTop:_576.getPrope=
rtyValue("padding-top"),marginRight:_576.getPropertyValue("padding-right"=
),marginBottom:_576.getPropertyValue("padding-bottom"),marginLeft:_576.ge=
tPropertyValue("padding-left"),padding:"0px"}});=0A=
_577.innerHTML=3De.innerHTML;=0A=
e.innerHTML=3D"";=0A=
e.appendChild(_577);=0A=
return e;=0A=
},_roundCornersImpl:function(e,_578,_579){=0A=
if(this.options.border){=0A=
this._renderBorder(e,_579);=0A=
}=0A=
if(this._isTopRounded()){=0A=
this._roundTopCorners(e,_578,_579);=0A=
}=0A=
if(this._isBottomRounded()){=0A=
this._roundBottomCorners(e,_578,_579);=0A=
}=0A=
},_renderBorder:function(el,_580){=0A=
var _581=3D"1px solid "+this._borderColor(_580);=0A=
var _582=3D"border-left: "+_581;=0A=
var _583=3D"border-right: "+_581;=0A=
var _584=3D"style=3D'"+_582+";"+_583+"'";=0A=
el.innerHTML=3D"<div "+_584+">"+el.innerHTML+"</div>";=0A=
},_roundTopCorners:function(el,_585,_586){=0A=
var _587=3Dthis._createCorner(_586);=0A=
for(var i=3D0;i<this.options.numSlices;i++){=0A=
_587.appendChild(this._createCornerSlice(_585,_586,i,"top"));=0A=
}=0A=
el.style.paddingTop=3D0;=0A=
el.insertBefore(_587,el.firstChild);=0A=
},_roundBottomCorners:function(el,_588,_589){=0A=
var _590=3Dthis._createCorner(_589);=0A=
for(var i=3D(this.options.numSlices-1);i>=3D0;i--){=0A=
_590.appendChild(this._createCornerSlice(_588,_589,i,"bottom"));=0A=
}=0A=
el.style.paddingBottom=3D0;=0A=
el.appendChild(_590);=0A=
},_createCorner:function(_591){=0A=
var dom=3DMochiKit.DOM;=0A=
return dom.DIV({style:{backgroundColor:_591.toString()}});=0A=
},_createCornerSlice:function(_592,_593,n,_594){=0A=
var _595=3DMochiKit.DOM.SPAN();=0A=
var _596=3D_595.style;=0A=
_596.backgroundColor=3D_592.toString();=0A=
_596.display=3D"block";=0A=
_596.height=3D"1px";=0A=
_596.overflow=3D"hidden";=0A=
_596.fontSize=3D"1px";=0A=
var _597=3Dthis._borderColor(_592,_593);=0A=
if(this.options.border&&n=3D=3D=3D0){=0A=
_596.borderTopStyle=3D"solid";=0A=
_596.borderTopWidth=3D"1px";=0A=
_596.borderLeftWidth=3D"0px";=0A=
_596.borderRightWidth=3D"0px";=0A=
_596.borderBottomWidth=3D"0px";=0A=
_596.height=3D"0px";=0A=
_596.borderColor=3D_597.toString();=0A=
}else{=0A=
if(_597){=0A=
_596.borderColor=3D_597.toString();=0A=
_596.borderStyle=3D"solid";=0A=
_596.borderWidth=3D"0px 1px";=0A=
}=0A=
}=0A=
if(!this.options.compact&&(n=3D=3D(this.options.numSlices-1))){=0A=
_596.height=3D"2px";=0A=
}=0A=
this._setMargin(_595,n,_594);=0A=
this._setBorder(_595,n,_594);=0A=
return _595;=0A=
},_setOptions:function(_598){=0A=
this.options=3D{corners:"all",color:"fromElement",bgColor:"fromParent",bl=
end:true,border:false,compact:false,__unstable__wrapElement:false};=0A=
MochiKit.Base.update(this.options,_598);=0A=
this.options.numSlices=3D(this.options.compact?2:4);=0A=
},_whichSideTop:function(){=0A=
var _599=3Dthis.options.corners;=0A=
if(this._hasString(_599,"all","top")){=0A=
return "";=0A=
}=0A=
var _600=3D(_599.indexOf("tl")!=3D-1);=0A=
var _601=3D(_599.indexOf("tr")!=3D-1);=0A=
if(_600&&_601){=0A=
return "";=0A=
}=0A=
if(_600){=0A=
return "left";=0A=
}=0A=
if(_601){=0A=
return "right";=0A=
}=0A=
return "";=0A=
},_whichSideBottom:function(){=0A=
var _602=3Dthis.options.corners;=0A=
if(this._hasString(_602,"all","bottom")){=0A=
return "";=0A=
}=0A=
var _603=3D(_602.indexOf("bl")!=3D-1);=0A=
var _604=3D(_602.indexOf("br")!=3D-1);=0A=
if(_603&&_604){=0A=
return "";=0A=
}=0A=
if(_603){=0A=
return "left";=0A=
}=0A=
if(_604){=0A=
return "right";=0A=
}=0A=
return "";=0A=
},_borderColor:function(_605,_606){=0A=
if(_605=3D=3D"transparent"){=0A=
return _606;=0A=
}else{=0A=
if(this.options.border){=0A=
return this.options.border;=0A=
}else{=0A=
if(this.options.blend){=0A=
return _606.blendedColor(_605);=0A=
}=0A=
}=0A=
}=0A=
return "";=0A=
},_setMargin:function(el,n,_607){=0A=
var _608=3Dthis._marginSize(n)+"px";=0A=
var =
_609=3D(_607=3D=3D"top"?this._whichSideTop():this._whichSideBottom());=0A=
var _610=3Del.style;=0A=
if(_609=3D=3D"left"){=0A=
_610.marginLeft=3D_608;=0A=
_610.marginRight=3D"0px";=0A=
}else{=0A=
if(_609=3D=3D"right"){=0A=
_610.marginRight=3D_608;=0A=
_610.marginLeft=3D"0px";=0A=
}else{=0A=
_610.marginLeft=3D_608;=0A=
_610.marginRight=3D_608;=0A=
}=0A=
}=0A=
},_setBorder:function(el,n,_611){=0A=
var _612=3Dthis._borderSize(n)+"px";=0A=
var =
_613=3D(_611=3D=3D"top"?this._whichSideTop():this._whichSideBottom());=0A=
var _614=3Del.style;=0A=
if(_613=3D=3D"left"){=0A=
_614.borderLeftWidth=3D_612;=0A=
_614.borderRightWidth=3D"0px";=0A=
}else{=0A=
if(_613=3D=3D"right"){=0A=
_614.borderRightWidth=3D_612;=0A=
_614.borderLeftWidth=3D"0px";=0A=
}else{=0A=
_614.borderLeftWidth=3D_612;=0A=
_614.borderRightWidth=3D_612;=0A=
}=0A=
}=0A=
},_marginSize:function(n){=0A=
if(this.isTransparent){=0A=
return 0;=0A=
}=0A=
var o=3Dthis.options;=0A=
if(o.compact&&o.blend){=0A=
var _615=3D[1,0];=0A=
return _615[n];=0A=
}else{=0A=
if(o.compact){=0A=
var _616=3D[2,1];=0A=
return _616[n];=0A=
}else{=0A=
if(o.blend){=0A=
var _617=3D[3,2,1,0];=0A=
return _617[n];=0A=
}else{=0A=
var _618=3D[5,3,2,1];=0A=
return _618[n];=0A=
}=0A=
}=0A=
}=0A=
},_borderSize:function(n){=0A=
var o=3Dthis.options;=0A=
var _619;=0A=
if(o.compact&&(o.blend||this.isTransparent)){=0A=
return 1;=0A=
}else{=0A=
if(o.compact){=0A=
_619=3D[1,0];=0A=
}else{=0A=
if(o.blend){=0A=
_619=3D[2,1,1,1];=0A=
}else{=0A=
if(o.border){=0A=
_619=3D[0,2,0,0];=0A=
}else{=0A=
if(this.isTransparent){=0A=
_619=3D[5,3,2,1];=0A=
}else{=0A=
return 0;=0A=
}=0A=
}=0A=
}=0A=
}=0A=
}=0A=
return _619[n];=0A=
},_hasString:function(str){=0A=
for(var i=3D1;i<arguments.length;i++){=0A=
if(str.indexOf(arguments[i])!=3D-1){=0A=
return true;=0A=
}=0A=
}=0A=
return false;=0A=
},_isTopRounded:function(){=0A=
return this._hasString(this.options.corners,"all","top","tl","tr");=0A=
},_isBottomRounded:function(){=0A=
return this._hasString(this.options.corners,"all","bottom","bl","br");=0A=
},_hasSingleTextChild:function(el){=0A=
return (el.childNodes.length=3D=3D1&&el.childNodes[0].nodeType=3D=3D3);=0A=
}};=0A=
MochiKit.Visual.roundElement=3Dfunction(e,_620){=0A=
new MochiKit.Visual._RoundCorners(e,_620);=0A=
};=0A=
MochiKit.Visual.roundClass=3Dfunction(_621,_622,_623){=0A=
var _624=3DMochiKit.DOM.getElementsByTagAndClassName(_621,_622);=0A=
for(var i=3D0;i<_624.length;i++){=0A=
MochiKit.Visual.roundElement(_624[i],_623);=0A=
}=0A=
};=0A=
MochiKit.Visual.Color=3DMochiKit.Color.Color;=0A=
MochiKit.Visual.getElementsComputedStyle=3DMochiKit.DOM.computedStyle;=0A=
MochiKit.Visual.__new__=3Dfunction(){=0A=
var m=3DMochiKit.Base;=0A=
m.nameFunctions(this);=0A=
this.EXPORT_TAGS=3D{":common":this.EXPORT,":all":m.concat(this.EXPORT,thi=
s.EXPORT_OK)};=0A=
};=0A=
MochiKit.Visual.EXPORT=3D["roundElement","roundClass"];=0A=
MochiKit.Visual.EXPORT_OK=3D[];=0A=
MochiKit.Visual.__new__();=0A=
MochiKit.Base._exportSymbols(this,MochiKit.Visual);=0A=
if(typeof (MochiKit)=3D=3D"undefined"){=0A=
MochiKit=3D{};=0A=
}=0A=
if(typeof (MochiKit.MochiKit)=3D=3D"undefined"){=0A=
MochiKit.MochiKit=3D{};=0A=
}=0A=
MochiKit.MochiKit.NAME=3D"MochiKit.MochiKit";=0A=
MochiKit.MochiKit.VERSION=3D"1.3.1";=0A=
MochiKit.MochiKit.__repr__=3Dfunction(){=0A=
return "["+this.NAME+" "+this.VERSION+"]";=0A=
};=0A=
MochiKit.MochiKit.toString=3Dfunction(){=0A=
return this.__repr__();=0A=
};=0A=
MochiKit.MochiKit.SUBMODULES=3D["Base","Iter","Logging","DateTime","Forma=
t","Async","DOM","LoggingPane","Color","Signal","Visual"];=0A=
if(typeof (JSAN)!=3D"undefined"||typeof (dojo)!=3D"undefined"){=0A=
if(typeof (dojo)!=3D"undefined"){=0A=
dojo.provide("MochiKit.MochiKit");=0A=
dojo.require("MochiKit.*");=0A=
}=0A=
if(typeof (JSAN)!=3D"undefined"){=0A=
JSAN.use("MochiKit.Base",[]);=0A=
JSAN.use("MochiKit.Iter",[]);=0A=
JSAN.use("MochiKit.Logging",[]);=0A=
JSAN.use("MochiKit.DateTime",[]);=0A=
JSAN.use("MochiKit.Format",[]);=0A=
JSAN.use("MochiKit.Async",[]);=0A=
JSAN.use("MochiKit.DOM",[]);=0A=
JSAN.use("MochiKit.LoggingPane",[]);=0A=
JSAN.use("MochiKit.Color",[]);=0A=
JSAN.use("MochiKit.Signal",[]);=0A=
JSAN.use("MochiKit.Visual",[]);=0A=
}=0A=
(function(){=0A=
var _625=3DMochiKit.Base.extend;=0A=
var self=3DMochiKit.MochiKit;=0A=
var _626=3Dself.SUBMODULES;=0A=
var _627=3D[];=0A=
var _628=3D[];=0A=
var _629=3D{};=0A=
var i,k,m,all;=0A=
for(i=3D0;i<_626.length;i++){=0A=
m=3DMochiKit[_626[i]];=0A=
_625(_627,m.EXPORT);=0A=
_625(_628,m.EXPORT_OK);=0A=
for(k in m.EXPORT_TAGS){=0A=
_629[k]=3D_625(_629[k],m.EXPORT_TAGS[k]);=0A=
}=0A=
all=3Dm.EXPORT_TAGS[":all"];=0A=
if(!all){=0A=
all=3D_625(null,m.EXPORT,m.EXPORT_OK);=0A=
}=0A=
var j;=0A=
for(j=3D0;j<all.length;j++){=0A=
k=3Dall[j];=0A=
self[k]=3Dm[k];=0A=
}=0A=
}=0A=
self.EXPORT=3D_627;=0A=
self.EXPORT_OK=3D_628;=0A=
self.EXPORT_TAGS=3D_629;=0A=
}());=0A=
}else{=0A=
if(typeof (MochiKit.__compat__)=3D=3D"undefined"){=0A=
MochiKit.__compat__=3Dtrue;=0A=
}=0A=
(function(){=0A=
var _630=3Ddocument.getElementsByTagName("script");=0A=
var =
_631=3D"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";=0A=
var base=3Dnull;=0A=
var _632=3Dnull;=0A=
var _633=3D{};=0A=
var i;=0A=
for(i=3D0;i<_630.length;i++){=0A=
var src=3D_630[i].getAttribute("src");=0A=
if(!src){=0A=
continue;=0A=
}=0A=
_633[src]=3Dtrue;=0A=
if(src.match(/MochiKit.js$/)){=0A=
base=3Dsrc.substring(0,src.lastIndexOf("MochiKit.js"));=0A=
_632=3D_630[i];=0A=
}=0A=
}=0A=
if(base=3D=3D=3Dnull){=0A=
return;=0A=
}=0A=
var _634=3DMochiKit.MochiKit.SUBMODULES;=0A=
for(var i=3D0;i<_634.length;i++){=0A=
if(MochiKit[_634[i]]){=0A=
continue;=0A=
}=0A=
var uri=3Dbase+_634[i]+".js";=0A=
if(uri in _633){=0A=
continue;=0A=
}=0A=
if(document.documentElement&&document.documentElement.namespaceURI=3D=3D_=
631){=0A=
var s=3Ddocument.createElementNS(_631,"script");=0A=
s.setAttribute("id","MochiKit_"+base+_634[i]);=0A=
s.setAttribute("src",uri);=0A=
s.setAttribute("type","application/x-javascript");=0A=
_632.parentNode.appendChild(s);=0A=
}else{=0A=
document.write("<script src=3D\""+uri+"\" =
type=3D\"text/javascript\"></script>");=0A=
}=0A=
}=0A=
})();=0A=
}=0A=
=0A=
=0A=

------=_NextPart_000_0002_01C6F7DF.743F21E0--
